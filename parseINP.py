# -*- coding: utf-8 -*-
"""
Created on Tue Jul 27 15:55:41 2021

@author: toj
"""
import numpy as np

def readINP(inpFile):
    """
    readINP _summary_

    Parameters
    ----------
    inpFile : _type_
        _description_

    Returns
    -------
    _type_
        _description_
    """    
    # Parse an Abaqus .inp file
    
    ### Currently only obtaining mesh
    parts = [{'NodeCoords':[],'NodeConn':[]}]
    partid = 0
    firstpart = True
    with open(inpFile) as file:
        txtlines = file.readlines()
    parsingNode = False
    parsingElem = False
    parsingBC = False
    parsingMaterial = False
   
    for line in txtlines:
        # Set Parse Mode
        if ('*Part' in line) or ('*Instance' in line):
            if firstpart:
                firstpart = False
                continue
            else:
                partid += 1
                parts.append({'NodeCoords':[],'NodeConn':[]})
                
        if '*Node' in line or '*NODE' in line:
            parsingNode = True
            parsingElem = False
            parsingBC = False
            parsingMaterial = False
            continue
        elif '*Element' in line or '*ELEMENT' in line:
            parsingNode = False
            parsingElem = True
            parsingBC = False
            parsingMaterial = False
            continue
        elif '*' in line:
            parsingNode = False
            parsingElem = False
            parsingBC = False
            parsingMaterial = False
            continue
            
        if parsingNode:
            parts[partid]['NodeCoords'].append([float(i) for i in line[0:-1].split(', ')][1:])
        elif parsingElem:
            # Converts node numbering to be 0 index
            parts[partid]['NodeConn'].append([int(i)-1 for i in line[0:-1].split(', ')][1:])
    
    return parts

def writeINP(filename,parts):
    """
    writeINP _summary_

    Parameters
    ----------
    filename : _type_
        _description_
    parts : _type_
        _description_
    """    
    # filename: (str) the name and path of the file. If ".inp" isn't included, it will be added
    # parts: (list) list of part dicts, each containing ['NodeCoords'] and ['NodeConn']
    if '.inp' not in filename:
        filename += '.inp'
    with open(filename,'w') as f:
        f.write('*Heading\n')
        f.write('** Job name: model Model name: model\n')
        f.write('** Generated by: toj\n')
        f.write('*Preprint, echo=NO, model=NO, history=NO, contact=NO\n')
        f.write('**\n')
        f.write('** PARTS\n')
        f.write('**\n')
        
        for j in range(len(parts)):
            f.write('*Part, name=Part-'+str(j+1)+'\n')
            f.write('*Node\n')
            for i in range(len(parts[j]['NodeCoords'])):
                f.write(str(i+1) + ', ' + str(parts[j]['NodeCoords'][i]).replace('[','').replace(']','') +'\n')
            if type(parts[j]['ElemType']) == str:
                # Single element type
                f.write('*Element, type='+parts[j]['ElemType']+'\n')
                for i in range(len(parts[j]['NodeConn'])):
                    # NodeConn[i] + 1 so that nodes are properly 1-index
                    f.write(str(i+1) + ', ' + str([parts[j]['NodeConn'][i][k]+1 for k in range(len(parts[j]['NodeConn'][i]))]).replace('[','').replace(']','') +'\n')
                f.write('*End Part\n')
            else:
                # Mixed element type
                assert type(parts[j]['ElemType']) == list and len(parts[j]['ElemType']) == len(parts[j]['NodeConn']),"ElemType must be either a str or a list with the same length as NodeConn"
                unqType = np.unique(parts[j]['ElemType']).tolist()
                ElemsByType = [[] for i in range(len(unqType))]
                for i in range(len(parts[j]['NodeConn'])):
                    elemIdx = unqType.index(parts[j]['ElemType'][i])
                    ElemsByType[elemIdx].append(parts[j]['NodeConn'][i])
                cElem = 1
                for i in range(len(unqType)):
                    f.write('*Element, type='+unqType[i]+'\n')
                    for k in range(len(ElemsByType[i])):
                        # NodeConn[i] + 1 so that nodes are properly 1-index
                        f.write(str(cElem) + ', ' + str([ElemsByType[i][k][l]+1 for l in range(len(ElemsByType[i][k]))]).replace('[','').replace(']','') +'\n')
                        cElem+=1
                f.write('*End Part\n')
                
            