
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mesh.ImplicitMesh &#8212; Mesh 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for Mesh.ImplicitMesh</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Fri Jan 14 17:43:57 2022</span>

<span class="sd">@author: toj</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># %%</span>

<span class="kn">import</span> <span class="nn">plotly.express</span> <span class="k">as</span> <span class="nn">px</span>
<span class="kn">import</span> <span class="nn">plotly.graph_objects</span> <span class="k">as</span> <span class="nn">go</span>
<span class="kn">from</span> <span class="nn">plotly.offline</span> <span class="kn">import</span> <span class="n">plot</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">interpolate</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">bisect</span>
<span class="kn">import</span> <span class="nn">meshio</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">MeshUtils</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">MarchingCubes</span><span class="p">,</span> <span class="n">Quality</span><span class="p">,</span> <span class="n">Improvement</span><span class="p">,</span> <span class="n">TetGen</span><span class="p">,</span> <span class="n">Rays</span><span class="p">,</span> <span class="n">Octree</span><span class="p">,</span> <span class="n">mesh</span>


<span class="c1"># SDF Primitives</span>
<div class="viewcode-block" id="gyroid"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.gyroid">[docs]</a><span class="k">def</span> <span class="nf">gyroid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="lidinoid"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.lidinoid">[docs]</a><span class="k">def</span> <span class="nf">lidinoid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Z</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Z</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Z</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.15</span></div>

<div class="viewcode-block" id="primitive"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.primitive">[docs]</a><span class="k">def</span> <span class="nf">primitive</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span></div>

<div class="viewcode-block" id="neovius"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.neovius">[docs]</a><span class="k">def</span> <span class="nf">neovius</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span>
    <span class="k">return</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">))</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span></div>

<div class="viewcode-block" id="diamond"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.diamond">[docs]</a><span class="k">def</span> <span class="nf">diamond</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span></div>


<div class="viewcode-block" id="cylinder"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.cylinder">[docs]</a><span class="k">def</span> <span class="nf">cylinder</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span></div>

<div class="viewcode-block" id="cube"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.cube">[docs]</a><span class="k">def</span> <span class="nf">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">):</span>    
    <span class="k">return</span> <span class="n">intersection</span><span class="p">(</span><span class="n">intersection</span><span class="p">(</span><span class="n">intersection</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="o">-</span><span class="n">x2</span><span class="p">),</span><span class="n">intersection</span><span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y</span><span class="p">,</span><span class="n">y</span><span class="o">-</span><span class="n">y2</span><span class="p">)),</span><span class="n">intersection</span><span class="p">(</span><span class="n">z1</span><span class="o">-</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="o">-</span><span class="n">z2</span><span class="p">))</span></div>

<div class="viewcode-block" id="xplane"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.xplane">[docs]</a><span class="k">def</span> <span class="nf">xplane</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">x0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x0</span><span class="o">-</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="yplane"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.yplane">[docs]</a><span class="k">def</span> <span class="nf">yplane</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">y0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">y0</span><span class="o">-</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="zplane"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.zplane">[docs]</a><span class="k">def</span> <span class="nf">zplane</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">z0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">z0</span><span class="o">-</span><span class="n">z</span><span class="p">)</span></div>

<div class="viewcode-block" id="sphere"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.sphere">[docs]</a><span class="k">def</span> <span class="nf">sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span></div>

<span class="c1"># SDF Operators</span>
<div class="viewcode-block" id="offset"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.offset">[docs]</a><span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span><span class="n">offset</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">fval</span><span class="o">-</span><span class="n">offset</span></div>

<div class="viewcode-block" id="union"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.union">[docs]</a><span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">):</span>
<span class="c1">#    return np.minimum(fval1,fval2)</span>
    <span class="k">return</span> <span class="n">rMin</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">)</span></div>

<div class="viewcode-block" id="diff"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.diff">[docs]</a><span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">):</span>
<span class="c1">#    return np.minimum(fval1,-fval2)</span>
    <span class="k">return</span> <span class="n">rMin</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="o">-</span><span class="n">fval2</span><span class="p">)</span></div>

<div class="viewcode-block" id="intersection"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.intersection">[docs]</a><span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">):</span>
<span class="c1">#    return np.maximum(fval1,fval2)</span>
    <span class="k">return</span> <span class="n">rMax</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">)</span></div>

<div class="viewcode-block" id="rMax"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.rMax">[docs]</a><span class="k">def</span> <span class="nf">rMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="c1"># R-Function version of max(a,b) to yield a smoothly differentiable max - R0</span>
    <span class="c1"># Implicit Functions With Guaranteed Differential Properties - Shapiro &amp; Tsukanov</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span></div>

<div class="viewcode-block" id="rMin"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.rMin">[docs]</a><span class="k">def</span> <span class="nf">rMin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="c1"># R-Function version of min(a,b) to yield a smoothly differentiable min - R0</span>
    <span class="c1"># Implicit Functions With Guaranteed Differential Properties - Shapiro &amp; Tsukanov</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span></div>

<div class="viewcode-block" id="sMax"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.sMax">[docs]</a><span class="k">def</span> <span class="nf">sMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
    <span class="c1"># p-norm smooth maximum</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">],</span><span class="nb">ord</span><span class="o">=</span><span class="n">p</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="sMin"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.sMin">[docs]</a><span class="k">def</span> <span class="nf">sMin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
    <span class="c1"># polynomial smooth minimum</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">k</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">))],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">k</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span></div>

<div class="viewcode-block" id="sUnion"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.sUnion">[docs]</a><span class="k">def</span> <span class="nf">sUnion</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sMin</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">,</span><span class="n">k</span><span class="p">)</span></div>

<div class="viewcode-block" id="plotSDF"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.plotSDF">[docs]</a><span class="k">def</span> <span class="nf">plotSDF</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">sdf</span><span class="p">,</span><span class="n">isomax</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="c1"># h = .01</span>
    <span class="c1"># x, y, z = np.mgrid[0:1:(1/h)*1j,0:1:(1/h)*1j,0:1:(1/h)*1j]</span>
    <span class="c1"># x = x.flatten()</span>
    <span class="c1"># y = y.flatten()</span>
    <span class="c1"># z = z.flatten()</span>
    <span class="c1"># sVal = sdf(x,y,z)</span>
    <span class="c1"># plotSDF(x,y,z,sVal)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">go</span><span class="o">.</span><span class="n">Volume</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="n">sdf</span><span class="p">,</span>
        <span class="n">opacity</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">isomin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sdf</span><span class="p">),</span>
        <span class="n">isomax</span><span class="o">=</span><span class="n">isomax</span>
        <span class="p">))</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="VoxelMesh"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.VoxelMesh">[docs]</a><span class="k">def</span> <span class="nf">VoxelMesh</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">xlims</span><span class="p">,</span><span class="n">ylims</span><span class="p">,</span><span class="n">zlims</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;liberal&#39;</span><span class="p">,</span><span class="n">reinitialize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    VoxelMesh Generate voxel mesh of a signed distance function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdf : function</span>
<span class="sd">        DESCRIPTION.</span>
<span class="sd">    xlims : list</span>
<span class="sd">        [xmin, xmax]</span>
<span class="sd">    ylims : list</span>
<span class="sd">        [ymin, ymax].</span>
<span class="sd">    zlims : list</span>
<span class="sd">        [zmin, zmax].</span>
<span class="sd">    h : numeric</span>
<span class="sd">        Element side length.</span>
<span class="sd">    mode : str</span>
<span class="sd">        Voxel trimming model</span>
<span class="sd">        notrim - will keep all voxels in the grid</span>
<span class="sd">        liberal - will keep all voxels with at least 1 node inside the negative region of the field (val &lt;= 0)</span>
<span class="sd">        moderate - will keep all voxels with the centroid inside the negative region of the field (val &lt;= 0)</span>
<span class="sd">        conservative - will keep only voxels that are entirely inside the negative region of the field (val &lt;= 0)</span>
<span class="sd">        The default is liberal.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates for the voxel mesh</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal connectivity list for the voxel mesh </span>

<span class="sd">    &quot;&quot;&quot;</span>        
    
    <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn1</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">makeGrid</span><span class="p">(</span><span class="n">xlims</span><span class="p">,</span><span class="n">ylims</span><span class="p">,</span><span class="n">zlims</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
    <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">reinitialize</span><span class="p">:</span>
        <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">FastMarchingMethod</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn1</span><span class="p">,</span><span class="n">NodeVals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;notrim&#39;</span><span class="p">:</span>
        <span class="n">NodeConn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;conservative&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]):</span>
                    <span class="n">NodeConn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;moderate&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>                   
                    <span class="n">NodeConn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span><span class="s1">&#39;liberal&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]):</span>
                    <span class="n">NodeConn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>   
        <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">NodeConn1</span>
    <span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">OriginalIds</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">removeNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">NodeVals</span> <span class="o">=</span> <span class="p">[</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">OriginalIds</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeVals</span></div>

<div class="viewcode-block" id="grid2fun"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.grid2fun">[docs]</a><span class="k">def</span> <span class="nf">grid2fun</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">,</span><span class="n">NodeVals</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    grid2fun converts a voxel grid mesh (as made by VoxelMesh(mode=&#39;notrim&#39;) </span>
<span class="sd">    or converter.makeGrid) into a function that can be evaluated at any point</span>
<span class="sd">    within the bounds of the grid</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : List of Lists</span>
<span class="sd">        List of nodal coordinates for the voxel mesh</span>
<span class="sd">    VoxelConn : List of Lists</span>
<span class="sd">       Nodal connectivity list for the voxel mesh.</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of values at each node.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fun : function</span>
<span class="sd">        Interpolation function, takes arguments (x,y,z), to return an</span>
<span class="sd">        evaluation of the function at the specified point.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">VoxelCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">,[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">)])</span>
    
    <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interpn</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fun</span></div>

<div class="viewcode-block" id="grid2grad"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.grid2grad">[docs]</a><span class="k">def</span> <span class="nf">grid2grad</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">,</span><span class="n">NodeVals</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    grid2grad converts a voxel grid mesh (as made by VoxelMesh(mode=&#39;notrim&#39;) </span>
<span class="sd">    or converter.makeGrid) into a function that can be evaluated at any point</span>
<span class="sd">    within the bounds of the grid to return the gradient of the function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : List of Lists</span>
<span class="sd">        List of nodal coordinates for the voxel mesh</span>
<span class="sd">    VoxelConn : List of Lists</span>
<span class="sd">       Nodal connectivity list for the voxel mesh.</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of values at each node.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frad : function</span>
<span class="sd">        Interpolation function, takes arguments (x,y,z), to return an</span>
<span class="sd">        evaluation of the function gradient at the specified point.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">VoxelCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">,[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">)])</span>
    <span class="c1"># Assumes (and requires) that all voxels are cubic and the same size</span>
    <span class="n">VoxelSize</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]))</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">VoxelSize</span><span class="p">)</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interpn</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>
    
    <span class="k">return</span> <span class="n">grad</span></div>

<div class="viewcode-block" id="FastMarchingMethod"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.FastMarchingMethod">[docs]</a><span class="k">def</span> <span class="nf">FastMarchingMethod</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span> <span class="n">VoxelConn</span><span class="p">,</span> <span class="n">NodeVals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FastMarchingMethod based on J.A. Sethian. A Fast Marching Level Set Method</span>
<span class="sd">    for Monotonically Advancing Fronts, Proc. Natl. Acad. Sci., 93, 4, </span>
<span class="sd">    pp.1591--1595, 1996</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : list</span>
<span class="sd">        List of nodal coordinates for the voxel mesh.</span>
<span class="sd">    VoxelConn : list</span>
<span class="sd">        Nodal connectivity list for the voxel mesh.</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of value at each node.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T : list</span>
<span class="sd">        Lists of reinitialized node values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># </span>
    <span class="c1"># 3D</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="c1"># For now this is only for obtaining a signed distance function, so F = 1 everywhere</span>
    <span class="n">F</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)</span>
    <span class="c1"># Get Neighbors</span>
    <span class="n">NodeNeighbors</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span> <span class="n">VoxelConn</span><span class="p">)</span>
    <span class="n">xNeighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">))]</span>
    <span class="n">yNeighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">))]</span>
    <span class="n">zNeighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">))]</span>
    <span class="c1"># Assumes (and requires) that all voxels are the same size</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])))</span>
    <span class="c1"># Initialize Labels - Accepted if on the surface, Narrow Band if an adjacent node has a different sign (i.e. cross the surface), otherwise Far</span>
    <span class="n">Accepted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">Narrow</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Accepted</span><span class="p">]</span>
    <span class="n">NarrowVals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Narrow</span><span class="p">:</span>
        <span class="n">crosses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]):</span>
                <span class="n">crosses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="mi">0</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">yNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]):</span>
                <span class="n">crosses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="mi">0</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">zNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]):</span>
                <span class="n">crosses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="mi">0</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
        <span class="c1"># NarrowVals.append(np.mean(crosses))</span>
        <span class="n">NarrowVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">crosses</span><span class="p">))</span>
    <span class="n">Far</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">Accepted</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">Narrow</span><span class="p">)))</span>
    <span class="c1"># Initialize Values (inf for Far, 0 for accepted)</span>
    <span class="n">infty</span> <span class="o">=</span> <span class="mf">1e16</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">infty</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NarrowVals</span><span class="p">)):</span>
        <span class="n">T</span><span class="p">[</span><span class="n">Narrow</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">NarrowVals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Accepted</span><span class="p">:</span>
        <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">Nar</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">NarrowVals</span><span class="p">,</span><span class="n">Narrow</span><span class="p">))],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Far</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nar</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nar</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">Nar</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">Far</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">Nar</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">))</span>
        <span class="n">Accepted</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="n">Nar</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">pt</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Far</span><span class="p">:</span>
                <span class="n">Far</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">Nar</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">Nar</span><span class="p">,</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">)),</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Accepted</span><span class="p">:</span>
                <span class="c1"># Eikonal Update:</span>
                <span class="n">Tx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">T</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xNeighbors</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
                <span class="n">Ty</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">T</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">yNeighbors</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
                <span class="n">Tz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">T</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zNeighbors</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
                
                <span class="n">discriminant</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">Tx</span><span class="p">,</span><span class="n">Ty</span><span class="p">,</span><span class="n">Tz</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">N</span><span class="o">*</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">Tx</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">Ty</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">Tz</span><span class="o">**</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">discriminant</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">N</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="n">Tx</span><span class="p">,</span><span class="n">Ty</span><span class="p">,</span><span class="n">Tz</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">N</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">discriminant</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="n">F</span> <span class="o">+</span> <span class="nb">min</span><span class="p">([</span><span class="n">Tx</span><span class="p">,</span><span class="n">Ty</span><span class="p">,</span><span class="n">Tz</span><span class="p">])</span>
                                
                <span class="n">Nar</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">Nar</span><span class="p">,</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">Nar</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">Nar</span><span class="p">,</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">)),</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">))</span>        
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">t</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">else</span> <span class="n">t</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">T</span></div>

<div class="viewcode-block" id="mesh2sdf"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.mesh2sdf">[docs]</a><span class="k">def</span> <span class="nf">mesh2sdf</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;nodes+centroids&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    mesh2sdf Generates a signed distance field for a mesh</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : mesh.mesh</span>
<span class="sd">        Mesh object that will be used to define the distance field.</span>
<span class="sd">    VoxelCoords : list</span>
<span class="sd">        List of nodal coordinates for the voxel mesh on which the distance</span>
<span class="sd">        field will be evaluated.</span>
<span class="sd">    VoxelConn : list</span>
<span class="sd">        Nodal connectivity list for the voxel mesh on which the distance field</span>
<span class="sd">        will be evaluated.</span>
<span class="sd">    method : str</span>
<span class="sd">        Method to be used </span>
<span class="sd">        nodes </span>
<span class="sd">        nodes+centroids</span>
<span class="sd">        centroids</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of signed distance values evaluated at each node in the voxel grid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nodes&#39;</span><span class="p">:</span>
        <span class="n">Normals</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeNormals</span>
        <span class="n">SurfNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">))</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">SurfNodes</span> <span class="k">else</span> <span class="p">[</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;centroids&#39;</span><span class="p">:</span>
        <span class="n">Normals</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ElemNormals</span><span class="p">()</span>
        <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nodes+centroids&#39;</span><span class="p">:</span>
        <span class="n">Normals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeNormals</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">ElemNormals</span><span class="p">)</span>
        <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">SurfNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">))</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">SurfNodes</span> <span class="k">else</span> <span class="p">[</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid method - use &quot;nodes&quot;, &quot;centroids&quot;, or &quot;nodes+centroids&quot;&#39;</span><span class="p">)</span>
    
    <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">Coords</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
    <span class="n">Out</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">Out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">Out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">VoxelCoords</span> <span class="o">-</span> <span class="n">Coords</span><span class="p">[</span><span class="n">cs</span><span class="p">]</span>
    <span class="n">normals</span> <span class="o">=</span> <span class="p">[</span><span class="n">Normals</span><span class="p">[</span><span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">))]</span>
    <span class="n">signs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">Normals</span><span class="p">[</span><span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">))]</span>
    <span class="n">NodeVals</span> <span class="o">=</span> <span class="p">[</span><span class="n">signs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">))]</span>
    
    <span class="k">return</span> <span class="n">NodeVals</span></div>

<div class="viewcode-block" id="mesh2udf"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.mesh2udf">[docs]</a><span class="k">def</span> <span class="nf">mesh2udf</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">,</span><span class="n">pool</span><span class="o">=</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">backend</span><span class="o">=</span><span class="s1">&#39;threading&#39;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    mesh2udf Generates an unsigned distance field for a mesh</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : mesh.mesh</span>
<span class="sd">        Mesh object that will be used to define the distance field.</span>
<span class="sd">    VoxelCoords : list</span>
<span class="sd">        List of nodal coordinates for the voxel mesh on which the distance</span>
<span class="sd">        field will be evaluated.</span>
<span class="sd">    VoxelConn : list</span>
<span class="sd">        Nodal connectivity list for the voxel mesh on which the distance field</span>
<span class="sd">        will be evaluated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of signed distance values evaluated at each node in the voxel grid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">([</span><span class="n">n</span><span class="p">],</span><span class="n">NodeCoords</span><span class="p">))</span>
    
    <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">pool</span><span class="p">(</span><span class="n">delayed</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">VoxelCoords</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">NodeVals</span></div>

<div class="viewcode-block" id="DoubleDualResampling"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.DoubleDualResampling">[docs]</a><span class="k">def</span> <span class="nf">DoubleDualResampling</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277284. https://doi.org/10.1115/1.1559153</span>
    <span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">gradP</span> <span class="o">=</span> <span class="n">DualMeshOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span><span class="n">return_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">DualNeighbors</span><span class="p">,</span><span class="n">ElemConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">ElemType</span><span class="o">=</span><span class="s1">&#39;polygon&#39;</span><span class="p">)</span>
    <span class="n">NewNodeCoords</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))]</span>
    <span class="n">gradPnorms</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradP</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradP</span><span class="p">))]</span>
    <span class="n">Normals</span> <span class="o">=</span> <span class="p">[</span><span class="n">gradP</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">gradPnorms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">if</span> <span class="n">gradPnorms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,[</span><span class="n">DualConn</span><span class="p">[</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]])[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)):</span>
        <span class="n">Ps</span> <span class="o">=</span> <span class="n">DualConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># Ns = [gradP[j]/gradPnorms[j] if gradPnorms[j] &gt; 0 else MeshUtils.CalcFaceNormal(DualCoords,[Ps])[0] for j in Ps]</span>
        <span class="n">ks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">Pj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ps</span><span class="p">):</span>
            <span class="n">NeighborPs</span> <span class="o">=</span> <span class="n">DualNeighbors</span><span class="p">[</span><span class="n">Pj</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span>
            <span class="c1"># NNPs =[gradP[k]/gradPnorms[k] for k in NeighborPs]</span>
            <span class="c1"># ks.append(sum([np.arccos(np.dot(Ns[j],NNPs[k]))/(np.linalg.norm(DualCoords[Pj])*np.linalg.norm(DualCoords[NeighborPs[k]]))  for k in range(len(NNPs))]))</span>
            
            <span class="n">ks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Normals</span><span class="p">[</span><span class="n">Pj</span><span class="p">],</span><span class="n">Normals</span><span class="p">[</span><span class="n">NeighborPs</span><span class="p">[</span><span class="n">k</span><span class="p">]]),</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">[</span><span class="n">Pj</span><span class="p">],</span><span class="n">DualCoords</span><span class="p">[</span><span class="n">NeighborPs</span><span class="p">[</span><span class="n">k</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NeighborPs</span><span class="p">))]))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;merp&#39;</span><span class="p">)</span>
        
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">ki</span> <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">]</span>
        
        <span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">DualCoords</span><span class="p">[</span><span class="n">Ps</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ps</span><span class="p">))])</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">NewNodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span></div>
    
<div class="viewcode-block" id="DualMeshOptimization"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.DualMeshOptimization">[docs]</a><span class="k">def</span> <span class="nf">DualMeshOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">return_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277284. https://doi.org/10.1115/1.1559153</span>
    <span class="k">def</span> <span class="nf">GradF</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">g</span><span class="p">])</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">g</span><span class="p">])</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">z</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">g</span><span class="p">])</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">dF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
        <span class="n">dFq</span> <span class="o">=</span> <span class="p">[</span><span class="n">dF</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">dF</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">dF</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">dFq</span>
    <span class="k">def</span> <span class="nf">bisection</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">eps</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">fa</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">fa</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;Invalid bounds for bisection&#39;</span>
        
        <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">thinking</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">fc</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
            <span class="c1"># if fc == 0 or (np.linalg.norm(b-a)/2) &lt; tol:</span>
                <span class="c1"># merp = &#39;meep&#39;</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">fa</span><span class="p">):</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="n">fa</span> <span class="o">=</span> <span class="n">fc</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="n">fb</span> <span class="o">=</span> <span class="n">fc</span>                
        <span class="k">return</span> <span class="n">c</span>
    <span class="k">def</span> <span class="nf">secant</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">eps</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">fa</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">fa</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;Invalid bounds for secant method&#39;</span>
        <span class="n">origA</span><span class="p">,</span> <span class="n">origB</span><span class="p">,</span> <span class="n">origFa</span><span class="p">,</span> <span class="n">origFb</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">fb</span>
        <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">thinking</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">fb</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">fb</span><span class="o">-</span><span class="n">fa</span><span class="p">))</span>
            <span class="n">fc</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fc</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span><span class="n">c</span>
                <span class="n">fa</span><span class="p">,</span><span class="n">fb</span> <span class="o">=</span> <span class="n">fb</span><span class="p">,</span><span class="n">fc</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="ow">or</span> <span class="n">fa</span> <span class="o">==</span> <span class="n">fb</span><span class="p">:</span>
                <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">origA</span><span class="p">,</span> <span class="n">origB</span><span class="p">,</span> <span class="n">origFa</span><span class="p">,</span> <span class="n">origFb</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">])):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">origA</span><span class="p">,</span> <span class="n">origB</span><span class="p">,</span> <span class="n">origFa</span><span class="p">,</span> <span class="n">origFb</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">c</span>
    <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    
    <span class="c1"># _,ElemConn = MeshUtils.getNodeNeighbors(NodeCoords,NodeConn)</span>
    <span class="c1"># DualCoords,DualConn = converter.surf2dual(ArrayCoords,NodeConn,ElemConn=ElemConn)</span>
    
    <span class="c1"># Optimize dual mesh coordinates     </span>
    <span class="n">gradP</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">P</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">):</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
        <span class="n">edgelengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">edgelengths</span><span class="p">)</span>
        <span class="n">lamb</span> <span class="o">=</span> <span class="n">e</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">fP</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">P</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fP</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_grad</span><span class="p">:</span>
                <span class="n">gradP</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">GradF</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">lamb</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
                <span class="c1"># gradP[c] = gradF(*P)[0]</span>
            <span class="k">continue</span>
        
        <span class="n">Q</span> <span class="o">=</span> <span class="n">P</span>
        <span class="n">fQ</span> <span class="o">=</span> <span class="n">fP</span>

        <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">thinking</span><span class="p">:</span>
            <span class="n">dfQ</span> <span class="o">=</span> <span class="n">GradF</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">lamb</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
            <span class="c1"># dfQ = gradF(*Q)[0]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">dfQ</span><span class="p">,</span><span class="n">fQ</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">+</span> <span class="n">lamb</span><span class="o">*</span><span class="n">d</span>
            <span class="n">fR</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">R</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fQ</span><span class="o">*</span><span class="n">fR</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">P2</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">fQ</span><span class="p">,</span> <span class="n">fR</span><span class="p">)</span>
                <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">Q</span> <span class="o">=</span> <span class="n">R</span>
                <span class="n">fQ</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">Q</span><span class="p">)</span>
                <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">it</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">lamb</span> <span class="o">=</span> <span class="n">lamb</span><span class="o">/</span><span class="mi">2</span>
                <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
                    <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">P2</span> <span class="o">=</span> <span class="n">P</span>
                    <span class="c1"># raise Exception(&quot;Too many iterations - This probably shouldn&#39;t happen&quot;)</span>
        <span class="c1">#if np.linalg.norm(np.subtract(P2,P)) &lt; e:</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">P2</span>
        <span class="n">fS</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">S</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fP</span><span class="o">*</span><span class="n">fS</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">P3</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">fP</span><span class="p">,</span> <span class="n">fS</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">P2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">P3</span><span class="p">)):</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">P2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">P3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">P2</span>
        <span class="c1"># P = P2</span>
        <span class="n">DualCoords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span>
        <span class="k">if</span> <span class="n">return_grad</span><span class="p">:</span> <span class="n">gradP</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">GradF</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">lamb</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
        <span class="c1"># if return_grad: gradP[c] = gradF(*P)[0]</span>
        
    <span class="k">if</span> <span class="n">return_grad</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span><span class="p">,</span> <span class="n">gradP</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span></div>
    
<div class="viewcode-block" id="AdaptiveSubdivision"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.AdaptiveSubdivision">[docs]</a><span class="k">def</span> <span class="nf">AdaptiveSubdivision</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
    <span class="c1"># Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277284. https://doi.org/10.1115/1.1559153</span>
    <span class="k">def</span> <span class="nf">gradF</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">h</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">])</span>
        <span class="n">gradx</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="n">h</span>
        <span class="n">grady</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="n">h</span>
        <span class="n">gradz</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">h</span>
        <span class="n">gradf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">gradx</span><span class="p">,</span><span class="n">grady</span><span class="p">,</span><span class="n">gradz</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gradf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">gradf</span> <span class="o">=</span> <span class="n">gradf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">gradf</span>
    
    <span class="n">NewNodeCoords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">NewNodeConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getElemNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>

    <span class="c1">###</span>
    <span class="n">Points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cross</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">cross</span><span class="o">/</span><span class="n">norm</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">Area</span> <span class="o">=</span> <span class="n">norm</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">splitCentroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                          <span class="p">]),</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">splitCentroids2</span> <span class="o">=</span> <span class="n">splitCentroids</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">splitCentroids</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">gradFCi</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">splitCentroids2</span><span class="p">)</span>
    <span class="n">mCi</span> <span class="o">=</span> <span class="n">gradFCi</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradFCi</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">mCi2</span> <span class="o">=</span> <span class="n">mCi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">splitCentroids</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">en</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ElemNormals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">mCi2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">))])</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">en</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">id01</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
            <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">id12</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
            <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">id20</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
            <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">NewNodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">id01</span><span class="p">,</span><span class="n">id20</span><span class="p">],</span>
                <span class="p">[</span><span class="n">id01</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">id12</span><span class="p">],</span>
                <span class="p">[</span><span class="n">id20</span><span class="p">,</span><span class="n">id12</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">id01</span><span class="p">,</span><span class="n">id12</span><span class="p">,</span><span class="n">id20</span><span class="p">]</span>
                <span class="p">]</span>

    <span class="c1"># Check for neighbors of split elements</span>
    <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;1-4&#39;</span>
    <span class="k">while</span> <span class="n">thinking</span><span class="p">:</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NewNodeConn</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="c1"># Already subdivided</span>
                <span class="k">continue</span>
            <span class="n">nSplitNeighbors</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">SplitNeighbors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewNodeConn</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeConn</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span> 
                    <span class="n">nSplitNeighbors</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">SplitNeighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;1-4&#39;</span> <span class="ow">and</span> <span class="n">nSplitNeighbors</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">changes</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">id01</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">id12</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">id20</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">NewNodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">id01</span><span class="p">,</span><span class="n">id20</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">id01</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">id12</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">id20</span><span class="p">,</span><span class="n">id12</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">id01</span><span class="p">,</span><span class="n">id12</span><span class="p">,</span><span class="n">id20</span><span class="p">]</span>
                    <span class="p">]</span>
                
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;1-2&#39;</span> <span class="ow">and</span> <span class="n">nSplitNeighbors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">changes</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">SplitNeighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="ow">and</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">SplitNeighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                    <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">NewNodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">idx</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                        <span class="p">]</span>
                <span class="k">elif</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">SplitNeighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="ow">and</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">SplitNeighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                    <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">NewNodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">idx</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                    <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">NewNodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">idx</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">idx</span><span class="p">]</span>
                        <span class="p">]</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;1-4&#39;</span> <span class="ow">and</span> <span class="n">changes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># After all necessary 1-4 splits are completed, perform 1-2 splits</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;1-2&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;1-2&#39;</span> <span class="ow">and</span> <span class="n">changes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
            
    <span class="n">NewNodeConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NewNodeConn</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NewNodeConn</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span>
    <span class="n">NewNodeCoords</span><span class="p">,</span><span class="n">NewNodeConn</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">,</span><span class="n">NewNodeConn</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">NewNodeCoords</span><span class="p">,</span><span class="n">NewNodeConn</span></div>
     
<div class="viewcode-block" id="DualPrimalOptimization"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.DualPrimalOptimization">[docs]</a><span class="k">def</span> <span class="nf">DualPrimalOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">nIter</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277284. https://doi.org/10.1115/1.1559153</span>
       
    <span class="k">def</span> <span class="nf">PrimalMeshOptimization</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">gradP</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">DualConn</span><span class="p">),</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">DualCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">)</span>
        <span class="n">DualNeighbors</span><span class="p">,</span><span class="n">ElemConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">ElemType</span><span class="o">=</span><span class="s1">&#39;polygon&#39;</span><span class="p">)</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
        <span class="n">gradPnorms</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradP</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradP</span><span class="p">))]</span>
        <span class="n">TransCoords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">Pis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">DualConn</span><span class="p">):</span>
            
            <span class="c1"># Transfrom Coordinates to local system centered on the centroid</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="c1"># Normal vector TODO: gradP[i] could = 0 at sharp features, in this case, need to use something else (maybe the element normal of the primal element corresponding to the dual node)</span>
            <span class="c1"># Ns = [np.divide(gradP[i],gradPnorms[i]) for i in Pis]</span>
            <span class="n">Ns</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">gradP</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">gradPnorms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">if</span> <span class="n">gradPnorms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,[</span><span class="n">DualConn</span><span class="p">[</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]])[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Pis</span><span class="p">]</span>
            
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">DualCoords</span><span class="p">[</span><span class="n">Pis</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">*</span><span class="mi">2</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)]),</span> 
                         <span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)]),</span>
                         <span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)])])</span>
            
            <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">TransCoords</span><span class="p">[</span><span class="n">Pis</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)]),</span> 
                 <span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">TransCoords</span><span class="p">[</span><span class="n">Pis</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)]),</span>
                 <span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">TransCoords</span><span class="p">[</span><span class="n">Pis</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)])]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">rcond</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">tau</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="c1"># Reset TransCoords</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ArrayCoords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    
    <span class="n">OptCoords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">OptConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">3</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIter</span><span class="p">):</span>
        <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">surf2dual</span><span class="p">(</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">sort</span><span class="o">=</span><span class="s1">&#39;ccw&#39;</span><span class="p">)</span>
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_Dual.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
        <span class="n">OptCoords</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">DoubleDualResampling</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_PrimalResampled.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
        <span class="n">DualCoords</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_Dual2.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
        <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span><span class="p">,</span> <span class="n">gradP</span> <span class="o">=</span> <span class="n">DualMeshOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span><span class="n">return_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_DualOpt.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
        <span class="n">OptCoords</span> <span class="o">=</span> <span class="n">PrimalMeshOptimization</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">gradP</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_PrimalOpt.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
        <span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span> <span class="o">=</span> <span class="n">AdaptiveSubdivision</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_PrimalOptSub.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">tau</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span><span class="o">/</span><span class="mi">10</span>
    <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">surf2dual</span><span class="p">(</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">sort</span><span class="o">=</span><span class="s1">&#39;ccw&#39;</span><span class="p">)</span>
    <span class="n">OptCoords</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">DoubleDualResampling</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
    <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_PrimalResampled.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
    <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span><span class="p">,</span> <span class="n">gradP</span> <span class="o">=</span> <span class="n">DualMeshOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span><span class="n">return_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
    <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_DualOpt.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
    <span class="n">OptCoords</span> <span class="o">=</span> <span class="n">PrimalMeshOptimization</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">gradP</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_PrimalOpt.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span></div>

<div class="viewcode-block" id="SurfFlowOptimization"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.SurfFlowOptimization">[docs]</a><span class="k">def</span> <span class="nf">SurfFlowOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">ZRIter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">NZRIter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">NZIter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">Subdivision</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">FixedNodes</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
    
    <span class="n">C</span> <span class="o">=</span> <span class="mf">0.1</span>     <span class="c1"># Positive Constant</span>
    <span class="n">FreeNodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">FixedNodes</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">gradF</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mf">1e-6</span>    <span class="c1"># Finite Diff Step Size</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">])</span>
        <span class="n">gradx</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="n">h</span>
        <span class="n">grady</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="n">h</span>
        <span class="n">gradz</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">h</span>
        <span class="n">gradf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">gradx</span><span class="p">,</span><span class="n">grady</span><span class="p">,</span><span class="n">gradz</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gradf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">gradf</span> <span class="o">=</span> <span class="n">gradf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">gradf</span>
    <span class="k">def</span> <span class="nf">NFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">gradC</span> <span class="o">=</span> <span class="o">-</span><span class="n">gradF</span><span class="p">(</span><span class="n">Centroids</span><span class="p">)</span>
        <span class="n">gradCnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gradCnorm</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradC</span><span class="p">),</span><span class="mi">1</span><span class="p">)))</span>
        
        <span class="c1"># This is a slower but more straightforward version of what is done below</span>
        <span class="c1"># A = np.array([sum([Area[e] for e in ElemConn[i]]) for i in range(len(NodeCoords))])</span>
        <span class="c1"># tau = 1/(1000*max(A))</span>
        <span class="c1"># N1 = tau*np.array([1/sum(Area[T] for T in ElemConn[i]) * sum([Area[T]*np.dot((Centroids[T]-P),m[T])*m[T] for T in ElemConn[i]]) for i,P in enumerate(NodeCoords)])</span>

        <span class="c1"># Converting the ragged ElemConn array to a padded rectangular array (R) for significant speed improvements</span>
        <span class="n">Area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Area</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">m</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">Centroids2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Centroids</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">Area2</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">tf</span><span class="o">*</span><span class="mf">.75</span> <span class="c1"># 1/(100*max(A))</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m2</span><span class="p">[</span><span class="n">R</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">Centroids2</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">-</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">m2</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Area2</span><span class="p">[</span><span class="n">R</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">C</span>
        <span class="k">return</span> <span class="n">N</span>
    <span class="k">def</span> <span class="nf">N2Flow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">):</span>
        
        <span class="c1"># Orthocenter coordinates: https://en.wikipedia.org/wiki/Triangle_center#Position_vectors</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">Points</span> <span class="o">=</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">wA</span> <span class="o">=</span> <span class="n">a</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">wB</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">wC</span> <span class="o">=</span> <span class="n">c</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># Orthocenters</span>
        <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">wA</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">wB</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wC</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">wA</span> <span class="o">+</span> <span class="n">wB</span> <span class="o">+</span> <span class="n">wC</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">H</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
        <span class="c1"># </span>
        <span class="n">lens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ElemConn</span><span class="p">]</span>
        <span class="n">maxlens</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Mask0</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">Masknan</span> <span class="o">=</span> <span class="n">Mask0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">Masknan</span><span class="p">[</span><span class="n">Mask0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="n">PH</span> <span class="o">=</span> <span class="p">(</span><span class="n">H2</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">-</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:])</span><span class="o">*</span><span class="n">Mask0</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">PHnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">PH</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">PH</span><span class="o">/</span><span class="n">PHnorm</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span>

        <span class="c1"># For each point, gives the node connectivity of each incident element</span>
        <span class="n">IncidentNodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)[</span><span class="n">R</span><span class="p">]</span><span class="o">*</span><span class="n">Masknan</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="c1">## TODO: This needs a speedup</span>
        <span class="n">OppositeEdges</span> <span class="o">=</span> <span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="o">==</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">else</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">IncidentNodes</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">IncidentNodes</span><span class="p">))]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Mask0</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">##</span>
        <span class="n">OppositeLength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">OppositeEdges</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">OppositeEdges</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">TriAntiGradient</span> <span class="o">=</span> <span class="n">e</span><span class="o">*</span><span class="n">OppositeLength</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">PointAntiGradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">TriAntiGradient</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="k">for</span> <span class="n">E</span> <span class="ow">in</span> <span class="n">ElemConn</span><span class="p">])</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">degree</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span> <span class="o">*</span> <span class="n">PointAntiGradient</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">N</span>
    <span class="k">def</span> <span class="nf">ZFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">fP</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">gradP</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="c1"># A = np.array([sum([Area[T] for T in ElemConn[i]]) for i in range(len(NodeCoords))])</span>
        <span class="n">Area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Area</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Area2</span><span class="p">[</span><span class="n">R</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># tau = 1/(500*max(A))</span>
        <span class="c1"># Z = np.divide(-2*(tau*A)[:,None]*(fP[:,None]*gradP),np.linalg.norm(fP[:,None]*gradP,axis=1)[:,None],where=(fP!=0)[:,None])</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">tf</span><span class="o">*</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fP</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">gradP</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">A</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">fP</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">gradP</span>
        <span class="k">return</span> <span class="n">Z</span>
    <span class="k">def</span> <span class="nf">Z2Flow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">):</span>
        <span class="n">fC</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="n">Centroids</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Centroids</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">Centroids</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">gradC</span> <span class="o">=</span> <span class="o">-</span><span class="n">gradF</span><span class="p">(</span><span class="n">Centroids</span><span class="p">)</span>
        <span class="n">Area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Area</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">fC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fC</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gradC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">gradC</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Area2</span><span class="p">[</span><span class="n">R</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Area2</span><span class="p">[</span><span class="n">R</span><span class="p">][:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">gradC</span><span class="p">[</span><span class="n">R</span><span class="p">]</span><span class="o">*</span><span class="n">fC</span><span class="p">[</span><span class="n">R</span><span class="p">][:,:,</span><span class="kc">None</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span>
        <span class="k">return</span> <span class="n">Z</span>
    <span class="k">def</span> <span class="nf">RFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">):</span>
        <span class="c1">### Old slow version ###</span>
        <span class="c1">#     U = [1/len(N)*sum([np.subtract(NodeCoords[n],NodeCoords[i]) for n in N]) for i,N in enumerate(NodeNeighbors)]</span>
        <span class="c1">#     R = C*np.array([U[i] - np.dot(U[i],NodeNormals[i])*NodeNormals[i] for i in range(len(NodeCoords))])</span>
        <span class="c1">###</span>
        <span class="n">lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">])</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="n">U</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lens</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Q</span> <span class="o">-</span> <span class="n">ArrayCoords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">U</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">NodeNormals</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">NodeNormals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">R</span>
    <span class="k">def</span> <span class="nf">NZRFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">NFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">ZFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">RFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">)</span>
        <span class="n">NZR</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="n">Z</span> <span class="o">+</span> <span class="n">R</span>
        <span class="k">return</span> <span class="n">NZR</span>
    <span class="k">def</span> <span class="nf">ZRFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">ZFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">RFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">)</span>
        <span class="n">ZR</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">+</span> <span class="n">R</span>
        <span class="k">return</span> <span class="n">ZR</span>
    <span class="k">def</span> <span class="nf">NZFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span> <span class="n">tf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">NFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">ZFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
        <span class="n">NZ</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="n">Z</span>
        <span class="k">return</span> <span class="n">NZ</span>
    <span class="k">def</span> <span class="nf">Flip</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">ElemNormals</span><span class="p">,</span> <span class="n">ElemNeighbors</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
        <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">NewConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
        <span class="n">gradC</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">Centroids</span><span class="p">)</span>
        <span class="n">gradCnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gradCnorm</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradC</span><span class="p">),</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">NormalError</span> <span class="o">=</span> <span class="n">Area</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ElemNormals</span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="n">T</span><span class="p">]))</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ElemNormals</span><span class="p">))])</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">NormalError</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
            <span class="n">restart</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">while</span> <span class="n">restart</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># This condition checks if the flip will be legal</span>
                        <span class="k">continue</span>

                    <span class="n">Newi</span><span class="p">,</span><span class="n">Newj</span> <span class="o">=</span> <span class="n">Improvement</span><span class="o">.</span><span class="n">FlipEdge</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                    <span class="p">[</span><span class="n">Ci</span><span class="p">,</span><span class="n">Cj</span><span class="p">]</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Newi</span><span class="p">,</span><span class="n">Newj</span><span class="p">]))</span>
                    <span class="n">gradC</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Ci</span><span class="p">,</span><span class="n">Cj</span><span class="p">]))</span>
                    <span class="n">gradCnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">mi</span> <span class="o">=</span> <span class="n">gradC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">gradCnorm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">mj</span> <span class="o">=</span> <span class="n">gradC</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">gradCnorm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">Ni</span><span class="p">,</span><span class="n">Nj</span><span class="p">]</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Newi</span><span class="p">,</span><span class="n">Newj</span><span class="p">]))</span>
                    
                    <span class="n">Ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newi</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newi</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newi</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newi</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span><span class="o">/</span><span class="mi">2</span>
                    <span class="n">Aj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newj</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newj</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newj</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newj</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span><span class="o">/</span><span class="mi">2</span>
                    <span class="n">Ei</span> <span class="o">=</span> <span class="n">Ai</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ni</span><span class="p">,</span><span class="n">mi</span><span class="p">))</span>
                    <span class="n">Ej</span> <span class="o">=</span> <span class="n">Aj</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Nj</span><span class="p">,</span><span class="n">mj</span><span class="p">))</span>
                    <span class="c1"># Ei = np.arccos(np.dot(Ni,mi))</span>
                    <span class="c1"># Ej = np.arccos(np.dot(Nj,mj))</span>
                    <span class="n">OldError</span> <span class="o">=</span> <span class="n">NormalError</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">NormalError</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">NewError</span> <span class="o">=</span> <span class="n">Ei</span> <span class="o">+</span> <span class="n">Ej</span>
                    <span class="k">if</span> <span class="n">NewError</span> <span class="o">&lt;</span> <span class="n">OldError</span><span class="p">:</span>
                        <span class="n">NormalError</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ei</span><span class="p">;</span> <span class="n">NormalError</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ej</span>
                        <span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Newi</span><span class="p">;</span> <span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Newj</span>
                        
                        <span class="n">ENi</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">ENj</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">Si</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">Newi</span><span class="p">);</span> <span class="n">Sj</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">Newj</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Si</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="n">ENi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sj</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="n">ENj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                        <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENi</span><span class="p">;</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENj</span>
                        <span class="n">restart</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">restart</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">NewConn</span><span class="p">,</span> <span class="n">ElemNeighbors</span>
    <span class="k">def</span> <span class="nf">Error</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">ElemNormals</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">):</span>
        <span class="n">fP</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">gradP</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">gradPnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradP</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">gradC</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">Centroids</span><span class="p">)</span>
        <span class="n">gradCnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gradCnorm</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradC</span><span class="p">),</span><span class="mi">1</span><span class="p">)))</span>

        <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Area</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">area</span><span class="p">[</span><span class="n">R</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">VertexError</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">Area</span><span class="p">))</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">((</span><span class="n">fP</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">gradPnorm</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">A</span><span class="p">)</span>
        <span class="n">NormalError</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">Area</span><span class="p">))</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Area</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemNormals</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">VertexError</span><span class="p">,</span> <span class="n">NormalError</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">surf2edges</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Input mesh should be closed and contain no exposed edges.&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># mesh.mesh(NodeCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>

    <span class="k">if</span> <span class="n">Subdivision</span><span class="p">:</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">AdaptiveSubdivision</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
    <span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="c1"># mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>

    <span class="n">NodeNeighbors</span><span class="p">,</span><span class="n">ElemConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span> 
    <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getElemNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
    <span class="c1"># NodeConn, ElemNeighbors = Improvement.ValenceImprovementFlips(NodeCoords,NodeConn,NodeNeighbors,ElemNeighbors)</span>
    <span class="c1"># vE = [];    nE = []   </span>
    <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">MeshUtils</span><span class="o">.</span><span class="n">Face2NodeNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">ElemNormals</span><span class="p">))</span>
    
    <span class="n">tfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">ZRIter</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ZRIter</span><span class="p">):</span>
        <span class="n">tf</span> <span class="o">=</span> <span class="n">tfs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">Points</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
        <span class="n">Area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>   
        <span class="n">Centroids</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
        <span class="c1"># v,n = Error(NewCoords, ElemConn, ElemNormals, Area, Centroids); vE.append(v); nE.append(n)</span>
        <span class="n">NewCoords</span><span class="p">[</span><span class="n">FreeNodes</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ZRFlow</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span> <span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span>
        <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">MeshUtils</span><span class="o">.</span><span class="n">Face2NodeNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">ElemNormals</span><span class="p">))</span>
        <span class="c1"># mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NZRIter</span><span class="p">):</span>
        <span class="n">Points</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
        <span class="n">Area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>   
        <span class="n">Centroids</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
        <span class="c1"># v,n = Error(NewCoords, ElemConn, ElemNormals, Area, Centroids); vE.append(v); nE.append(n)</span>
        <span class="n">NewCoords</span><span class="p">[</span><span class="n">FreeNodes</span><span class="p">]</span> <span class="o">+=</span> <span class="n">NZRFlow</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span>
        <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">MeshUtils</span><span class="o">.</span><span class="n">Face2NodeNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">ElemNormals</span><span class="p">))</span>
        <span class="c1"># mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>
    <span class="k">if</span> <span class="n">NZIter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">Subdivision</span><span class="p">:</span> <span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">AdaptiveSubdivision</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">NewCoords</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
        <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">)</span>
        <span class="n">NodeNeighbors</span><span class="p">,</span><span class="n">ElemConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>    
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getElemNeighbors</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
        <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
        <span class="n">tfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">NZIter</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NZIter</span><span class="p">):</span>
        <span class="n">tf</span> <span class="o">=</span> <span class="n">tfs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">Points</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
        <span class="n">Area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>   
        <span class="n">Centroids</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>

        <span class="c1"># v,n = Error(NewCoords, ElemConn, ElemNormals, Area, Centroids)</span>
        <span class="c1"># vE.append(v); nE.append(n)</span>

        <span class="n">NewCoords</span><span class="p">[</span><span class="n">FreeNodes</span><span class="p">]</span> <span class="o">+=</span> <span class="n">NZFlow</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="p">[],</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span>
        
        <span class="n">NewElemNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">MeshUtils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">))</span>

        <span class="c1">### Check for near-intersections ###</span>
        <span class="c1"># Angles:</span>
        <span class="n">Points</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
        <span class="n">v01</span> <span class="o">=</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span> <span class="n">l01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v01</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">v12</span> <span class="o">=</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">];</span> <span class="n">l12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v12</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">v20</span> <span class="o">=</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">];</span> <span class="n">l20</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v20</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v01</span><span class="o">*-</span><span class="n">v20</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">l01</span><span class="o">*</span><span class="n">l20</span><span class="p">))</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v12</span><span class="o">*-</span><span class="n">v01</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">l12</span><span class="o">*</span><span class="n">l01</span><span class="p">))</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v20</span><span class="o">*-</span><span class="n">v12</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">l20</span><span class="o">*</span><span class="n">l12</span><span class="p">))</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Dihedrals:</span>
        <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">DihedralAngles</span><span class="p">(</span><span class="n">NewElemNormals</span><span class="p">,</span><span class="n">ElemNeighbors</span><span class="p">)</span>
        <span class="c1"># Normal Flipping:</span>
        <span class="n">NormDot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">NewElemNormals</span> <span class="o">*</span> <span class="n">ElemNormals</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">Risk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">angles</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dihedrals</span> <span class="o">&gt;</span> <span class="mi">175</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">NormDot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">Intersected</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">NZIter</span><span class="o">-</span><span class="mi">5</span><span class="p">:</span>
            <span class="c1"># NodeConn, ElemNeighbors = Flip(NewCoords,NodeConn,ElemNormals,ElemNeighbors,Area,Centroids)</span>
            <span class="n">IntersectionPairs</span> <span class="o">=</span> <span class="n">Rays</span><span class="o">.</span><span class="n">SurfSelfIntersection</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
            <span class="n">Intersected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">IntersectionPairs</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Risk</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">Intersected</span><span class="p">):</span>
            <span class="c1"># print(&#39;possible intersection&#39;)</span>
            <span class="n">ArrayConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
            <span class="n">AtRiskElems</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Risk</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">Intersected</span>
            <span class="n">NeighborhoodElems</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ArrayConn</span><span class="p">[</span><span class="n">AtRiskElems</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">PatchConn</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">NeighborhoodElems</span><span class="p">]</span> 
            <span class="n">BoundaryEdges</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">surf2edges</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">PatchConn</span><span class="p">)</span>
            <span class="n">FixedNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">BoundaryEdges</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">])</span>
            <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Improvement</span><span class="o">.</span><span class="n">LocalLaplacianSmoothing</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">PatchConn</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">FixedNodes</span><span class="o">=</span><span class="n">FixedNodes</span><span class="p">))</span>

            <span class="c1"># NodeConn = Improvement.AngleReductionFlips(NewCoords,NodeConn,NodeNeighbors)</span>
            <span class="n">NodeNeighbors</span><span class="p">,</span><span class="n">ElemConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>    
            <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getElemNeighbors</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
            <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">MeshUtils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">NewElemNormals</span>
        <span class="c1"># mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>
    <span class="c1"># px.line(y=vE).show()</span>
    <span class="c1"># px.line(y=nE).show()</span>
    <span class="k">return</span> <span class="n">NewCoords</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">NodeConn</span></div>

<div class="viewcode-block" id="HexCore"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.HexCore">[docs]</a><span class="k">def</span> <span class="nf">HexCore</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">bounds</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">nBL</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">nPeel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">TetgenSwitches</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;-pq1.1/25&#39;</span><span class="p">,</span><span class="s1">&#39;-Y&#39;</span><span class="p">,</span><span class="s1">&#39;-o/150&#39;</span><span class="p">],</span>
           <span class="n">MCInterp</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">,</span><span class="n">SurfOpt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">TetOpt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">GLS</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">SkewThreshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
           <span class="n">BLStiffnessFactor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">BLMaxThickness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">TetSliverThreshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    HexCore - Generate a mesh with a core of regular hexahedral elements, </span>
<span class="sd">    wrapped in a layer of pyramids and tetrahedrons, and (optionally) boundary </span>
<span class="sd">    layer wedge elements for a given signed distance function</span>
<span class="sd">    (or similar isosurface implicit function)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdf : function</span>
<span class="sd">        Signed distance (or similar) function that takes x, y, z coordinates</span>
<span class="sd">        and returns a value</span>
<span class="sd">    bounds : list</span>
<span class="sd">        Bounds of the domain of interest in the form </span>
<span class="sd">        [xmin,xmax,ymin,ymax,zmin,zmax].</span>
<span class="sd">    h : Element Size</span>
<span class="sd">        Element size of the initial voxel field</span>
<span class="sd">    nBL : int, optional</span>
<span class="sd">        Number of boundary layers. Specify 0 for no boundary layers. </span>
<span class="sd">        The default is 3.</span>
<span class="sd">    nPeel : int, optional</span>
<span class="sd">        Number of layers of voxel elements to peel off when generating</span>
<span class="sd">        the hexahedral core. The default is 1.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Specifies whether or not to print status updates during runtime. The default is True.</span>
<span class="sd">    TetgenSwitches : list, optional</span>
<span class="sd">        List of TetGen switches to specify tetrahedral meshing options. </span>
<span class="sd">        See https://www.wias-berlin.de/software/tetgen/switches.html </span>
<span class="sd">        The default is [&#39;-pq&#39;, &#39;-Y&#39;].</span>
<span class="sd">    SkewThreshold : float, optional</span>
<span class="sd">        Skewness threshold above which triangles will be considered slivers</span>
<span class="sd">        and collapsed. The default is 0.9.</span>
<span class="sd">    pool : joblib.parallel.Parallel, optional</span>
<span class="sd">        Parallel pool for joblib execution. The default is Parallel(n_jobs=1).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hexcore : mesh.mesh</span>
<span class="sd">        mesh object containing the generated mesh.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">VoxelTime</span> <span class="o">=</span> <span class="n">MarchingTime</span> <span class="o">=</span> <span class="n">SurfOptTime</span> <span class="o">=</span> <span class="n">TetTime</span> <span class="o">=</span> <span class="n">BLTime</span> <span class="o">=</span> <span class="n">AssemblyTime</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">BLMaxThickness</span><span class="p">)</span> <span class="ow">and</span> <span class="n">BLMaxThickness</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">nPeel</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">h</span><span class="p">:</span>
        <span class="n">nPeel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">BLMaxThickness</span><span class="o">/</span><span class="n">h</span><span class="o">+</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Increasing number of peel layers to </span><span class="si">{:d}</span><span class="s1"> accomdate BLThickness&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nPeel</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating Initial Voxel Mesh...&#39;</span><span class="p">)</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">sdf</span><span class="p">,[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="p">],[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="p">],[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="p">],</span><span class="n">h</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;liberal&#39;</span><span class="p">)</span>
    <span class="n">VoxelTime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Performing Marching Cubes Surface Construction...&#39;</span><span class="p">)</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span> <span class="o">=</span> <span class="n">MarchingCubes</span><span class="o">.</span><span class="n">ParchingCubes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">NodeVals</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="n">MCInterp</span><span class="p">,</span><span class="n">pool</span><span class="o">=</span><span class="n">pool</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;33&#39;</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">MarchingTime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
    <span class="c1"># if verbose: print(&#39;Surface Optimization...&#39;)</span>
    <span class="c1"># tic = time.time()</span>
    <span class="c1"># ImprovedCoords,ImprovedConn = SurfFlowOptimization(sdf,TriNodeCoords,TriNodeConn,h)</span>
    <span class="c1"># SurfOptTime = time.time()-tic</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Surface Optimization...&#39;</span><span class="p">)</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>  
    <span class="k">if</span> <span class="n">SurfOpt</span><span class="p">:</span>
        <span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span> <span class="o">=</span> <span class="n">SurfFlowOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">GLS</span><span class="p">:</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">TriNodeCoords</span> <span class="o">=</span> <span class="n">Improvement</span><span class="o">.</span><span class="n">GlobalLaplacianSmoothing</span><span class="p">(</span><span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span><span class="p">,[],</span><span class="n">FeatureWeight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">BaryWeight</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">SurfOpt</span> <span class="ow">or</span> <span class="n">GLS</span><span class="p">):</span>
        <span class="n">TriNodeCoords</span> <span class="o">=</span> <span class="n">TriNodeCoords</span>
        <span class="n">TriNodeConn</span> <span class="o">=</span> <span class="n">TriNodeConn</span>
    
    <span class="k">if</span> <span class="n">SkewThreshold</span><span class="p">:</span>
        <span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span> <span class="o">=</span> <span class="n">Improvement</span><span class="o">.</span><span class="n">CollapseSlivers</span><span class="p">(</span><span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span><span class="p">,</span><span class="n">skewThreshold</span><span class="o">=</span><span class="n">SkewThreshold</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">SurfOptTime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
    <span class="c1"># mesh.mesh(TriNodeCoords,TriNodeConn).Mesh2Meshio().write(&#39;opt.vtu&#39;)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Peeling Voxels...&#39;</span><span class="p">)</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">cutvoxels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">sum</span><span class="p">([</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">])</span>  <span class="c1"># Voxels cut by marching cubes</span>
    <span class="n">PeeledCoords</span><span class="p">,</span> <span class="n">PeeledConn</span><span class="p">,</span> <span class="n">PeelCoords</span><span class="p">,</span> <span class="n">PeelConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PeelHex</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cutvoxels</span><span class="p">],</span><span class="n">nLayers</span><span class="o">=</span><span class="n">nPeel</span><span class="p">)</span>
    <span class="n">PeelTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tic</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating Pyramids...&#39;</span><span class="p">)</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">PeeledConn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">PyramidCoords</span><span class="p">,</span> <span class="n">PyramidConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">makePyramidLayer</span><span class="p">(</span><span class="n">PeeledCoords</span><span class="p">,</span><span class="n">PeeledConn</span><span class="p">)</span>
        <span class="n">PyrSurf</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2surface</span><span class="p">(</span><span class="n">PyramidCoords</span><span class="p">,</span><span class="n">PyramidConn</span><span class="p">)</span>
        <span class="n">TriSurf</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">PyrSurf</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">TriCoords</span><span class="p">,</span><span class="n">TriSurf</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">PyramidCoords</span><span class="p">,</span><span class="n">TriSurf</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">TriCoords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">TriSurf</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">PyramidTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tet Meshing with Tetgen...&#39;</span><span class="p">)</span>    
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">BoundaryCoords</span> <span class="o">=</span> <span class="n">TriCoords</span> <span class="o">+</span> <span class="n">TriNodeCoords</span>
    <span class="n">BoundaryConn</span> <span class="o">=</span> <span class="n">TriSurf</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">TriNodeConn</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">TriCoords</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="n">FixedNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TriCoords</span><span class="p">)))</span>
    <span class="n">BoundaryCoords</span> <span class="o">=</span> <span class="n">Improvement</span><span class="o">.</span><span class="n">ResolveSurfSelfIntersections</span><span class="p">(</span><span class="n">BoundaryCoords</span><span class="p">,</span><span class="n">BoundaryConn</span><span class="p">,</span><span class="n">FixedNodes</span><span class="o">=</span><span class="n">FixedNodes</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">PeeledConn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">PeeledCoords</span><span class="p">,</span><span class="n">PeeledConn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># if &#39;-Y&#39; not in TetgenSwitches:</span>
    <span class="c1">#     TetgenSwitches.append(&#39;-Y&#39;) </span>
    <span class="c1">#     warnings.warn(&#39;-Y switch is required to maintain the surface mesh input to tetgen. Proceeding with -Y&#39;)</span>
    <span class="n">TetCoords</span><span class="p">,</span> <span class="n">TetConn</span> <span class="o">=</span> <span class="n">TetGen</span><span class="o">.</span><span class="n">tetgen</span><span class="p">(</span><span class="n">BoundaryCoords</span><span class="p">,</span><span class="n">BoundaryConn</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="n">BoundingBox</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">holes</span><span class="o">=</span><span class="n">holes</span><span class="p">,</span><span class="n">switches</span><span class="o">=</span><span class="n">TetgenSwitches</span><span class="p">)</span>
    <span class="n">TetTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
    <span class="c1">### Tet Optimization</span>
    <span class="k">if</span> <span class="n">TetOpt</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Optimizing Tetrahedral Mesh...&#39;</span><span class="p">)</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Tets = [elem for elem in hexcore.NodeConn if len(elem)==4]</span>
        <span class="c1"># skew = Quality.Skewness(hexcore.NodeCoords,Tets)</span>
        <span class="c1"># BadElems = set(np.where(skew&gt;0.9)[0])</span>
        <span class="c1"># ElemNeighbors = MeshUtils.getElemNeighbors(hexcore.NodeCoords,Tets)</span>
        <span class="c1"># BadElems.update([e for i in BadElems for e in ElemNeighbors[i]])</span>
        <span class="c1"># BadNodes = set([n for i in BadElems for n in Tets[i]])</span>

        <span class="c1"># SurfConn = converter.solid2surface(hexcore.NodeCoords,Tets)</span>
        <span class="c1"># SurfNodes = set([n for elem in SurfConn for n in elem])</span>

        <span class="c1"># FreeNodes = BadNodes.difference(SurfNodes)</span>
        <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2surface</span><span class="p">(</span><span class="n">TetCoords</span><span class="p">,</span><span class="n">TetConn</span><span class="p">)</span>
        <span class="n">SurfNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">SurfConn</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span>
        <span class="n">FreeNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TetCoords</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">SurfNodes</span><span class="p">)</span>
        <span class="n">TetCoords</span> <span class="o">=</span> <span class="n">Improvement</span><span class="o">.</span><span class="n">TetOpt</span><span class="p">(</span><span class="n">TetCoords</span><span class="p">,</span><span class="n">TetConn</span><span class="p">,</span><span class="n">FreeNodes</span><span class="o">=</span><span class="n">FreeNodes</span><span class="p">,</span><span class="n">objective</span><span class="o">=</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;BFGS&#39;</span><span class="p">,</span><span class="n">iterate</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">TetTime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assembling Mesh...&#39;</span><span class="p">)</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">hexcore</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">hexcore</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">tets</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">TetCoords</span><span class="p">,</span><span class="n">TetConn</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">PeeledConn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">core</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">PeeledCoords</span><span class="p">,</span><span class="n">PeeledConn</span><span class="p">)</span>
        <span class="n">pyramids</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">PyramidCoords</span><span class="p">,</span><span class="n">PyramidConn</span><span class="p">)</span>
        <span class="n">hexcore</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">core</span><span class="p">,</span><span class="n">pyramids</span><span class="p">,</span><span class="n">tets</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hexcore</span> <span class="o">=</span> <span class="n">tets</span>
    <span class="n">hexcore</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">hexcore</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">removeNodes</span><span class="p">(</span><span class="n">hexcore</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">hexcore</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">hexcore</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">cleanup</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">AssemblyTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tic</span>
    
    <span class="n">NonTetNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hexcore</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">!=</span><span class="mi">4</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]))</span>

    <span class="c1"># if verbose: print(&#39;Creating Boundary Layers...&#39;)</span>
    <span class="c1"># tic = time.time()</span>
    <span class="c1"># if nBL &gt; 0:</span>
    <span class="c1">#     # Create boundary layer elements, only allowing tet elements to be moved to make room</span>
    <span class="c1">#     hexcore.reset(&#39;SurfConn&#39;)</span>
    <span class="c1">#     NonTetNodes = set(np.unique([n for i,elem in enumerate(hexcore.NodeConn) if len(elem)!=4 for n in elem]))</span>
    <span class="c1">#     hexcore.CreateBoundaryLayer(nBL,FixedNodes=NonTetNodes,StiffnessFactor=BLStiffnessFactor,Thickness=BLMaxThickness)</span>
    <span class="c1">#     hexcore.verbose = verbose</span>
        
    <span class="c1">#     BLTime += time.time()-tic</span>
    
    
    <span class="k">if</span> <span class="n">TetSliverThreshold</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Peeling Surface Tet Slivers...&#39;</span><span class="p">)</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">hexcore</span><span class="o">.</span><span class="n">NodeConn</span> <span class="o">=</span> <span class="n">Improvement</span><span class="o">.</span><span class="n">SliverPeel</span><span class="p">(</span><span class="o">*</span><span class="n">hexcore</span><span class="p">,</span><span class="n">skewThreshold</span><span class="o">=</span><span class="n">TetSliverThreshold</span><span class="p">)</span>
        <span class="n">TetTime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
    
    <span class="c1">### </span>

    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">hexcore</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
    <span class="n">hexcore</span><span class="o">.</span><span class="n">validate</span><span class="p">()</span>
    <span class="n">AssemblyTime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;------------------------------------------&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Voxel Mesh Generated in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">VoxelTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Marching Cubes Performed in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">MarchingTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Surface Optimization Completed in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">SurfOptTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Voxels Peeled in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">PeelTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pyramids Generated in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">PyramidTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tets Generated in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">TetTime</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nBL</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Boundary Layers Created in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">BLTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Meshes Assembled in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">AssemblyTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total Meshing Time: </span><span class="si">%.4f</span><span class="s1"> min&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">VoxelTime</span> <span class="o">+</span> <span class="n">MarchingTime</span> <span class="o">+</span> <span class="n">SurfOptTime</span>  <span class="o">+</span> <span class="n">BLTime</span> <span class="o">+</span> <span class="n">PeelTime</span> <span class="o">+</span> <span class="n">PyramidTime</span> <span class="o">+</span> <span class="n">TetTime</span> <span class="o">+</span> <span class="n">AssemblyTime</span><span class="p">)</span><span class="o">/</span><span class="mi">60</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;------------------------------------------&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hexcore</span>  </div>

<div class="viewcode-block" id="TetMesh"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.TetMesh">[docs]</a><span class="k">def</span> <span class="nf">TetMesh</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">bounds</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">TetgenSwitches</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;-pq1.1/25&#39;</span><span class="p">,</span><span class="s1">&#39;-Y&#39;</span><span class="p">,</span><span class="s1">&#39;-o/150&#39;</span><span class="p">],</span>
            <span class="n">MCInterp</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">,</span><span class="n">SurfOpt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">GLS</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">SkewThreshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">pool</span><span class="o">=</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TetMesh - Generate a Tetrahedral Mesh for a given signed distance function</span>
<span class="sd">    (or similar isosurface implicit function)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdf : function</span>
<span class="sd">        Signed distance (or similar) function that takes x, y, z coordinates</span>
<span class="sd">        and returns a value</span>
<span class="sd">    bounds : list</span>
<span class="sd">        Bounds of the domain of interest in the form </span>
<span class="sd">        [xmin,xmax,ymin,ymax,zmin,zmax].</span>
<span class="sd">    h : Element Size</span>
<span class="sd">        Element size of the initial voxel field</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Specifies whether or not to print status updates during runtime. The default is True.</span>
<span class="sd">    TetgenSwitches : list, optional</span>
<span class="sd">        List of TetGen switches to specify tetrahedral meshing options. </span>
<span class="sd">        See https://www.wias-berlin.de/software/tetgen/switches.html </span>
<span class="sd">        The default is [&#39;-pq&#39;, &#39;-Y&#39;].</span>
<span class="sd">    MCInterp : Interpolaton method for marching cubes. </span>
<span class="sd">        Options are: &#39;midpoint&#39;, &#39;linear&#39;.</span>
<span class="sd">        The default is &#39;midpoint&#39;.</span>
<span class="sd">    SurfOpt : Perform Surface Flow Optimization. The default is True.</span>
<span class="sd">    GLS : Perform Global Laplacian Smoothing on the surface mesh. The default is False.</span>
<span class="sd">    skewThreshold : float, optional</span>
<span class="sd">        Skewness threshold above which triangles will be considered slivers</span>
<span class="sd">        and collapsed. The default is None.</span>
<span class="sd">    pool : joblib.parallel.Parallel, optional</span>
<span class="sd">        Parallel pool for joblib execution. The default is Parallel(n_jobs=1).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tetmesh : mesh.mesh</span>
<span class="sd">        mesh object containing the generated mesh.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">VoxelTime</span> <span class="o">=</span> <span class="n">MarchingTime</span> <span class="o">=</span> <span class="n">SurfOptTime</span> <span class="o">=</span> <span class="n">SmoothingTime</span> <span class="o">=</span> <span class="n">SliverTime</span> <span class="o">=</span> <span class="n">TetTime</span> <span class="o">=</span> <span class="n">AssemblyTime</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating Initial Voxel Mesh...&#39;</span><span class="p">)</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">sdf</span><span class="p">,[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="p">],[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="p">],[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="p">],</span><span class="n">h</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;liberal&#39;</span><span class="p">)</span>
    <span class="n">VoxelTime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Performing Marching Cubes Surface Construction...&#39;</span><span class="p">)</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span> <span class="o">=</span> <span class="n">MarchingCubes</span><span class="o">.</span><span class="n">ParchingCubes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">NodeVals</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="n">MCInterp</span><span class="p">,</span><span class="n">pool</span><span class="o">=</span><span class="n">pool</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;33&#39;</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">MarchingTime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
    <span class="k">if</span> <span class="n">SurfOpt</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Surface Optimization...&#39;</span><span class="p">)</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>        
        <span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span> <span class="o">=</span> <span class="n">SurfFlowOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span><span class="p">)</span>
        <span class="n">SurfOptTime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
   
    <span class="k">if</span> <span class="n">GLS</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Smoothing Mesh...&#39;</span><span class="p">)</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">TriNodeCoords</span> <span class="o">=</span> <span class="n">Improvement</span><span class="o">.</span><span class="n">GlobalLaplacianSmoothing</span><span class="p">(</span><span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span><span class="p">,[],</span><span class="n">FeatureWeight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">BaryWeight</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">SurfOptTime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>

    <span class="k">if</span> <span class="n">SkewThreshold</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Collapsing Surface Mesh Slivers...&#39;</span><span class="p">)</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span> <span class="o">=</span> <span class="n">Improvement</span><span class="o">.</span><span class="n">CollapseSlivers</span><span class="p">(</span><span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span><span class="p">,</span><span class="n">skewThreshold</span><span class="o">=</span><span class="n">SkewThreshold</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span><span class="n">pool</span><span class="o">=</span><span class="n">pool</span><span class="p">)</span>
        <span class="n">SurfOptTime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
    <span class="c1"># mesh.mesh(TriNodeCoords,TriNodeConn).Mesh2Meshio().write(&#39;opt.vtu&#39;)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tet Meshing with TetGen...&#39;</span><span class="p">)</span>    
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)</span>
    <span class="n">hconn</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span> <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="n">holes</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">hconn</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="s1">&#39;-Y&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">TetgenSwitches</span><span class="p">:</span>
        <span class="n">TetgenSwitches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;-Y&#39;</span><span class="p">)</span> 
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;-Y switch is required to maintain the surface mesh input to tetgen. Proceeding with -Y&#39;</span><span class="p">)</span>
    <span class="n">TetCoords</span><span class="p">,</span> <span class="n">TetConn</span> <span class="o">=</span> <span class="n">TetGen</span><span class="o">.</span><span class="n">tetgen</span><span class="p">(</span><span class="n">TriNodeCoords</span><span class="p">,</span><span class="n">TriNodeConn</span><span class="p">,</span><span class="n">holes</span><span class="o">=</span><span class="n">holes</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="n">BoundingBox</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">switches</span><span class="o">=</span><span class="n">TetgenSwitches</span><span class="p">)</span>
    <span class="n">TetTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assembling Mesh...&#39;</span><span class="p">)</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">tetmesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">TetCoords</span><span class="p">,</span><span class="n">TetConn</span><span class="p">)</span>
    <span class="n">tetmesh</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
    <span class="n">tetmesh</span><span class="o">.</span><span class="n">validate</span><span class="p">()</span>
    <span class="n">AssemblyTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tic</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;------------------------------------------&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Voxel Mesh Generated in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">VoxelTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Marching Cubes Performed in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">MarchingTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Surface Optimization Completed in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">SurfOptTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tets Generated in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">TetTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Meshes Assembled in </span><span class="si">%.4f</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="n">AssemblyTime</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total Meshing Time: </span><span class="si">%.4f</span><span class="s1"> min&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">VoxelTime</span> <span class="o">+</span> <span class="n">MarchingTime</span> <span class="o">+</span> <span class="n">SurfOptTime</span> <span class="o">+</span> <span class="n">SmoothingTime</span> <span class="o">+</span> <span class="n">SliverTime</span> <span class="o">+</span> <span class="n">TetTime</span> <span class="o">+</span> <span class="n">AssemblyTime</span><span class="p">)</span><span class="o">/</span><span class="mi">60</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;------------------------------------------&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tetmesh</span> </div>

<div class="viewcode-block" id="scaffold"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.scaffold">[docs]</a><span class="k">def</span> <span class="nf">scaffold</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="c1"># scale = 2</span>
    <span class="c1"># thickness = 0.35</span>
    <span class="n">sdf</span> <span class="o">=</span> <span class="n">primitive</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">thickness</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="o">-</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">intersection</span><span class="p">(</span><span class="o">-</span><span class="n">diff</span><span class="p">(</span><span class="n">offn</span><span class="p">,</span><span class="n">offp</span><span class="p">),</span><span class="mi">10</span><span class="o">*</span><span class="n">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="scaffold_capped"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.scaffold_capped">[docs]</a><span class="k">def</span> <span class="nf">scaffold_capped</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="n">sdf</span> <span class="o">=</span> <span class="n">primitive</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">thickness</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="o">-</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  
    <span class="n">scaff</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span><span class="o">-</span><span class="n">diff</span><span class="p">(</span><span class="n">offn</span><span class="p">,</span><span class="n">offp</span><span class="p">),</span><span class="mi">10</span><span class="o">*</span><span class="n">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">))</span>
    <span class="n">cap</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">)</span>
    <span class="n">cup</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">union</span><span class="p">(</span><span class="n">union</span><span class="p">(</span><span class="n">scaff</span><span class="p">,</span><span class="n">cap</span><span class="p">),</span><span class="n">cup</span><span class="p">)</span></div>

<div class="viewcode-block" id="fluid"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.fluid">[docs]</a><span class="k">def</span> <span class="nf">fluid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="c1"># scale = 2</span>
    <span class="c1"># thickness = 0.35</span>
    <span class="n">sdf</span> <span class="o">=</span> <span class="n">gyroid</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">thickness</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="o">-</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">intersection</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">offn</span><span class="p">,</span><span class="n">offp</span><span class="p">),</span><span class="mi">10</span><span class="o">*</span><span class="n">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="fluid_buffered"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.fluid_buffered">[docs]</a><span class="k">def</span> <span class="nf">fluid_buffered</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="n">sdf</span> <span class="o">=</span> <span class="n">gyroid</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">thickness</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="o">-</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  
    <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="mf">.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="o">-</span><span class="mf">.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">diff</span><span class="p">(</span><span class="n">intersection</span><span class="p">(</span><span class="o">-</span><span class="n">diff</span><span class="p">(</span><span class="n">offn</span><span class="p">,</span><span class="n">offp</span><span class="p">),</span><span class="mi">10</span><span class="o">*</span><span class="n">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">)),</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="fluid_tank"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.fluid_tank">[docs]</a><span class="k">def</span> <span class="nf">fluid_tank</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="n">buff</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="n">buff</span><span class="p">,</span><span class="mi">1</span><span class="o">+</span><span class="n">buff</span><span class="p">,</span><span class="o">-</span><span class="n">buff</span><span class="p">,</span><span class="mi">1</span><span class="o">+</span><span class="n">buff</span><span class="p">,</span><span class="o">-</span><span class="mf">0.09999</span><span class="p">,</span><span class="mf">1.099999</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">diff</span><span class="p">(</span><span class="n">scaffold_capped</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="n">c</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="scaffold3x3"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.scaffold3x3">[docs]</a><span class="k">def</span> <span class="nf">scaffold3x3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="n">sdf</span> <span class="o">=</span> <span class="n">primitive</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">thickness</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="o">-</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">intersection</span><span class="p">(</span><span class="n">intersection</span><span class="p">(</span><span class="o">-</span><span class="n">diff</span><span class="p">(</span><span class="n">offn</span><span class="p">,</span><span class="n">offp</span><span class="p">),</span><span class="n">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span><span class="n">cylinder</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mf">1.5</span><span class="p">))</span></div>

<div class="viewcode-block" id="fluid3x3"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.fluid3x3">[docs]</a><span class="k">def</span> <span class="nf">fluid3x3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="n">sdf</span> <span class="o">=</span> <span class="n">primitive</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">thickness</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="o">-</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">intersection</span><span class="p">(</span><span class="n">intersection</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">offn</span><span class="p">,</span><span class="n">offp</span><span class="p">),</span><span class="n">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span><span class="n">cylinder</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mf">1.5</span><span class="p">))</span></div>

<div class="viewcode-block" id="fluidball"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.fluidball">[docs]</a><span class="k">def</span> <span class="nf">fluidball</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">thickness</span> <span class="o">=</span> <span class="mf">0.35</span>
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">gyroid</span><span class="p">(</span>
        <span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">gyroid</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="o">-</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">intersection</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">offn</span><span class="p">,</span><span class="n">offp</span><span class="p">),</span><span class="n">sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.5</span><span class="p">]))</span></div>

<div class="viewcode-block" id="demo"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.demo">[docs]</a><span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="n">hexcore</span> <span class="o">=</span> <span class="n">HexCore</span><span class="p">(</span><span class="n">fluid_buffered</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nBL</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">tetmesh</span> <span class="o">=</span> <span class="n">TetMesh</span><span class="p">(</span><span class="n">scaffold</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tetmesh</span><span class="p">,</span><span class="n">hexcore</span></div>
<div class="viewcode-block" id="writeVTK"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.writeVTK">[docs]</a><span class="k">def</span> <span class="nf">writeVTK</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">):</span>
    
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# vtk DataFile Version 5.1</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ASCII</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;DATASET UNSTRUCTURED_GRID</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;POINTS </span><span class="si">{:d}</span><span class="s1"> float</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">NodeCoords</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:f}</span><span class="s1"> </span><span class="si">{:f}</span><span class="s1"> </span><span class="si">{:f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">))</span>
        
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;CELLS </span><span class="si">{:d}</span><span class="s1"> </span><span class="si">{:d}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">),</span><span class="nb">len</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)))</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;OFFSETS vtktypeint64</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;CONNECTIVITY vtktypeint64</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;CELL_TYPES </span><span class="si">{:d}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;7</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TPMSGeometricAnalysis"><a class="viewcode-back" href="../../Mesh.html#Mesh.ImplicitMesh.TPMSGeometricAnalysis">[docs]</a><span class="k">def</span> <span class="nf">TPMSGeometricAnalysis</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">writeVTUs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">SurfOpt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">return_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">MCInterp</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
    <span class="c1"># func should be the implicit function of the TPMS, before offsetting/thickening</span>
    <span class="k">def</span> <span class="nf">scaffold</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">L</span>
        <span class="n">thickness</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">func</span>
        <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">y</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span><span class="n">z</span><span class="o">/</span><span class="n">scale</span><span class="p">),</span><span class="o">-</span><span class="n">thickness</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  
        <span class="k">return</span> <span class="n">intersection</span><span class="p">(</span><span class="o">-</span><span class="n">diff</span><span class="p">(</span><span class="n">offn</span><span class="p">,</span><span class="n">offp</span><span class="p">),</span><span class="mi">10</span><span class="o">*</span><span class="n">cube</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># return -diff(offn,offp)</span>
    
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">L</span><span class="p">]</span>
    <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">scaffold</span><span class="p">,[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="p">],[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="p">],[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">,</span><span class="n">bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">h</span><span class="p">],</span><span class="n">h</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;notrim&#39;</span><span class="p">,</span><span class="n">reinitialize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># sdf = FastMarchingMethod(NodeCoords,NodeConn,NodeVals)</span>
    <span class="c1"># print(max(sdf),min(sdf))</span>
    <span class="n">ScaffCoords</span><span class="p">,</span><span class="n">ScaffConn</span> <span class="o">=</span> <span class="n">MarchingCubes</span><span class="o">.</span><span class="n">ParchingCubes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">NodeVals</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="n">MCInterp</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;33&#39;</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">SurfOpt</span><span class="p">:</span> <span class="n">ScaffCoords</span><span class="p">,</span><span class="n">ScaffConn</span> <span class="o">=</span> <span class="n">SurfFlowOptimization</span><span class="p">(</span><span class="n">scaffold</span><span class="p">,</span><span class="n">ScaffCoords</span><span class="p">,</span><span class="n">ScaffConn</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    
    <span class="n">M</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">ScaffCoords</span><span class="p">,</span><span class="n">ScaffConn</span><span class="p">)</span>
    <span class="n">M</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">writeVTUs</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">Mesh2Meshio</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Scaffold.vtu&#39;</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">mesh2sdf</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">writeVTUs</span><span class="p">:</span> <span class="n">meshio</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,[(</span><span class="s1">&#39;hexahedron&#39;</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)],</span><span class="n">point_data</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;v&#39;</span><span class="p">:</span><span class="n">NodeVals</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">:</span><span class="n">v</span><span class="p">})</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;sdf.vtu&#39;</span><span class="p">)</span>

    <span class="n">TPMSCoords</span><span class="p">,</span><span class="n">TPMSConn</span><span class="p">,</span><span class="n">TPMSVals</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">func</span><span class="p">,[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">],[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">],[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">],</span><span class="n">h</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;notrim&#39;</span><span class="p">,</span><span class="n">reinitialize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">TPMSSurfCoords</span><span class="p">,</span><span class="n">TPMSSurfConn</span> <span class="o">=</span> <span class="n">MarchingCubes</span><span class="o">.</span><span class="n">ParchingCubes</span><span class="p">(</span><span class="n">TPMSCoords</span><span class="p">,</span><span class="n">TPMSConn</span><span class="p">,</span><span class="n">TPMSVals</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;33&#39;</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">TPMSSurfCoords</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">TPMSSurfConn</span><span class="p">)]</span>
    <span class="n">Area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">Atpms</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Area</span><span class="p">)</span>
    <span class="n">Vtpms</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">TriSurfVol</span><span class="p">(</span><span class="n">ScaffCoords</span><span class="p">,</span> <span class="n">ScaffConn</span><span class="p">)</span>
    <span class="n">Vcell</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">Vtpms</span><span class="o">/</span><span class="n">Vcell</span>   
    <span class="n">t</span> <span class="o">=</span> <span class="n">Vtpms</span><span class="o">/</span><span class="n">Atpms</span>

    <span class="c1"># Thickness v2: (Not necessarily better...)</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">v</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="c1"># t = 2*radius</span>
    <span class="nb">print</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">writeVTUs</span><span class="p">:</span> 
        <span class="n">sphereSDF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">radius</span><span class="p">,</span><span class="n">center</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">,</span><span class="n">conn</span><span class="p">,</span><span class="n">vals</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">sphereSDF</span><span class="p">,(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">,</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">),(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">,</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">),(</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">,</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">),</span><span class="n">radius</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;notrim&#39;</span><span class="p">,</span><span class="n">reinitialize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">sCoords</span><span class="p">,</span><span class="n">sConn</span> <span class="o">=</span> <span class="n">MarchingCubes</span><span class="o">.</span><span class="n">ParchingCubes</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">conn</span><span class="p">,</span><span class="n">vals</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;33&#39;</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">sCoords</span><span class="p">,</span><span class="n">sConn</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Thickness_Sphere.vtu&#39;</span><span class="p">)</span>

    <span class="c1"># Pore Size:</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">v</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">writeVTUs</span><span class="p">:</span> 
        <span class="n">sphereSDF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">radius</span><span class="p">,</span><span class="n">center</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">,</span><span class="n">conn</span><span class="p">,</span><span class="n">vals</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">sphereSDF</span><span class="p">,(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">,</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">),(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">,</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">),(</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">,</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">),</span><span class="n">radius</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;notrim&#39;</span><span class="p">,</span><span class="n">reinitialize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">sCoords</span><span class="p">,</span><span class="n">sConn</span> <span class="o">=</span> <span class="n">MarchingCubes</span><span class="o">.</span><span class="n">ParchingCubes</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">conn</span><span class="p">,</span><span class="n">vals</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;33&#39;</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">sCoords</span><span class="p">,</span><span class="n">sConn</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Pore_Sphere.vtu&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;------------------------------------------&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Scaffold Thickness: </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Scaffold Volume Fraction: </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rho</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Scaffold Pore Radius: </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;------------------------------------------&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_mesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">ScaffCoords</span><span class="p">,</span><span class="n">ScaffConn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">radius</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Mesh</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, toj.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>