
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mesh.mesh &#8212; Mesh 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for Mesh.mesh</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Wed Sep  1 16:20:47 2021</span>

<span class="sd">@author: toj</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">MeshUtils</span><span class="p">,</span> <span class="n">Improvement</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">Quality</span><span class="p">,</span> <span class="n">Rays</span><span class="p">,</span> <span class="n">curvature</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">getsizeof</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">meshio</span>
<span class="kn">import</span> <span class="nn">json</span>

<div class="viewcode-block" id="mesh"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh">[docs]</a><span class="k">class</span> <span class="nc">mesh</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c1"># Primary attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Properties:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SurfConn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNeighbors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ElemConn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SurfNodeNeighbors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SurfElemConn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ElemNormals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNormals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Centroids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Used for FVM/CFD meshes, not for use in 2D</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># For each element, gives the indices of connected faces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># For each face, gives the indices of connected elements (nan -&gt; surface)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Edges</span> <span class="o">=</span> <span class="p">[]</span>    
        <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNormalsMethod</span> <span class="o">=</span> <span class="s1">&#39;Angle&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NFace</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NEdge</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NNode</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NElem</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nNode</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Sets:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeSets</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ElemSets</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EdgeSets</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Data:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeData</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">nD</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="o">=</span> <span class="n">arg</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nNode</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">cleanup</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__sizeof__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Edges</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NElem</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nNode</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NNode</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nD</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SurfConn</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NodeNeighbors</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ElemConn</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SurfNodeNeighbors</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SurfElemConn</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ElemNormals</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NodeNormals</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">getsizeof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Centroids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">size</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Mesh Object</span><span class="se">\n</span><span class="si">{0:d}</span><span class="s1"> Nodes</span><span class="se">\n</span><span class="si">{1:d}</span><span class="s1"> Elements&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NNode</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NElem</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">))</span>
<div class="viewcode-block" id="mesh.initialize"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cleanup</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cleanup</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setnD</span><span class="p">()</span></div>
<div class="viewcode-block" id="mesh.reset"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">keep</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reset Reset all or specified properties</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        properties : NoneType, str, or list, optional</span>
<span class="sd">            If specified as a string or list of strings, will reset the properties specified by those names, the default is None</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># Reset calculated mesh attributes</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">properties</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;SurfConn&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SurfConn</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;NodeNeighbors&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNeighbors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;ElemConn&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ElemConn</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;SurfNodeNeighbors&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SurfNodeNeighbors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;SurfElemConn&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SurfElemConn</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;ElemNormals&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ElemNormals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;NodeNormals&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNormals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;Centroids&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Centroids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;Edges&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;Faces&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;Faces&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span> <span class="ow">or</span> <span class="s1">&#39;FaceConn&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;Faces&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span> <span class="ow">or</span> <span class="s1">&#39;FaceElemConn&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">prop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
                    <span class="n">prop</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">prop</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prop</span><span class="p">,[])</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">properties</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
                <span class="n">properties</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">properties</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">properties</span><span class="p">,[])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid input.&#39;</span><span class="p">)</span></div>
<div class="viewcode-block" id="mesh.cleanup"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.cleanup">[docs]</a>    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span><span class="n">angletol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># TODO: This needs to be improved so other variables that point to nodes or elements are updated accordingly</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NElem</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Currently only valid for tris</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">DeleteDegenerateElements</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span><span class="n">angletol</span><span class="o">=</span><span class="n">angletol</span><span class="p">,</span><span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">DeleteDegenerateElements</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">angletol</span><span class="o">=</span><span class="n">angletol</span><span class="p">,</span><span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">removeNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="mesh.validate"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.validate">[docs]</a>    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;Invalid type for model.mesh.NodeCoords&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Undefined Node Coordinates&#39;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;Invalid type for model.mesh.NodeConn&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">),</span> <span class="s1">&#39;Undefined Nodal Connectivity&#39;</span>
        <span class="k">assert</span> <span class="nb">max</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">),</span> <span class="s1">&#39;NodeConn references undefined nodes&#39;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">Volume</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;VALIDATION WARNING: Mesh has inverted elements&#39;</span><span class="p">)</span></div>
<div class="viewcode-block" id="mesh.setnD"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.setnD">[docs]</a>    <span class="k">def</span> <span class="nf">setnD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nD</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nD</span> <span class="o">=</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="mesh.defineMesh"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.defineMesh">[docs]</a>    <span class="k">def</span> <span class="nf">defineMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addElems</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nNode</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setnD</span><span class="p">()</span></div>
<div class="viewcode-block" id="mesh.addNodes"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.addNodes">[docs]</a>    <span class="k">def</span> <span class="nf">addNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">NewNodeCoords</span><span class="p">,</span><span class="n">NodeSet</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">NewNodeCoords</span> <span class="o">=</span> <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;Supplied NodeCoords must be list or np.ndarray&#39;</span>
        
        <span class="n">nnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NNode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span> <span class="o">+=</span> <span class="n">NewNodeCoords</span>
        <span class="k">if</span> <span class="n">NodeSet</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeSets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NodeSets</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeSets</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nnode</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NNode</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">NodeSet</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NodeSets</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nnode</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NNode</span><span class="p">)</span>            </div>
<div class="viewcode-block" id="mesh.addFaces"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.addFaces">[docs]</a>    <span class="k">def</span> <span class="nf">addFaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">NewFaces</span><span class="p">,</span><span class="n">FaceSet</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewFaces</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">NewFaces</span> <span class="o">=</span> <span class="n">NewFaces</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewFaces</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;Supplied Faces must be list or np.ndarray&#39;</span>
        <span class="n">nface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NFace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span> <span class="o">+=</span> <span class="n">NewFaces</span>
        <span class="k">if</span> <span class="n">FaceSet</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="p">[</span><span class="n">FaceSet</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="p">[</span><span class="n">FaceSet</span><span class="p">])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nface</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NFace</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">FaceSet</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="p">[</span><span class="n">FaceSet</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nface</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NFace</span><span class="p">)</span>            </div>
<div class="viewcode-block" id="mesh.addEdges"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.addEdges">[docs]</a>    <span class="k">def</span> <span class="nf">addEdges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">NewEdges</span><span class="p">,</span><span class="n">EdgeSet</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewEdges</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">NewEdges</span> <span class="o">=</span> <span class="n">NewEdges</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewEdges</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;Supplied Edges must be list or np.ndarray&#39;</span>
        <span class="n">nedge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NEdge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Edges</span> <span class="o">+=</span> <span class="n">NewEdges</span>
        <span class="k">if</span> <span class="n">EdgeSet</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EdgeSets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">EdgeSets</span><span class="p">[</span><span class="n">EdgeSet</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EdgeSets</span><span class="p">[</span><span class="n">EdgeSet</span><span class="p">])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nedge</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NEdge</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">EdgeSet</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">EdgeSets</span><span class="p">[</span><span class="n">EdgeSet</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nedge</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NEdge</span><span class="p">)</span> </div>
<div class="viewcode-block" id="mesh.addElems"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.addElems">[docs]</a>    <span class="k">def</span> <span class="nf">addElems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">NewNodeConn</span><span class="p">,</span><span class="n">ElemSet</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewNodeConn</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">NewNodeConn</span> <span class="o">=</span> <span class="n">NewNodeConn</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewNodeConn</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;Supplied NodeConn must be list or np.ndarray&#39;</span>
        <span class="n">nelem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NElem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="o">+=</span> <span class="n">NewNodeConn</span>
        <span class="k">if</span> <span class="n">ElemSet</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ElemSets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ElemSets</span><span class="p">[</span><span class="n">ElemSet</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemSets</span><span class="p">[</span><span class="n">ElemSet</span><span class="p">])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nelem</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NElem</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">ElemSet</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ElemSets</span><span class="p">[</span><span class="n">ElemSet</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelem</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NElem</span><span class="p">)</span> </div>
        
<div class="viewcode-block" id="mesh.copy"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="n">M</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">()</span>
        <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">NodeConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span>
        
        <span class="n">M</span><span class="o">.</span><span class="n">nNode</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nNode</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">nD</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nD</span><span class="p">)</span>
        
        <span class="n">M</span><span class="o">.</span><span class="n">_Faces</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">_FaceConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">_FaceElemConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">_Edges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Edges</span><span class="p">)</span>
        
        <span class="n">M</span><span class="o">.</span><span class="n">NodeSets</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeSets</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">EdgeSets</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EdgeSets</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">FaceSets</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">ElemSets</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemSets</span><span class="p">)</span>

        <span class="n">M</span><span class="o">.</span><span class="n">NodeData</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeData</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">ElemData</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">)</span>
        
        <span class="n">M</span><span class="o">.</span><span class="n">_SurfConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SurfConn</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">_NodeNeighbors</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NodeNeighbors</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">_ElemConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ElemConn</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">_SurfNodeNeighbors</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SurfNodeNeighbors</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">_SurfElemConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SurfElemConn</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">_ElemNormals</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ElemNormals</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">_NodeNormals</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NodeNormals</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">_Centroids</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Centroids</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">M</span></div>
<div class="viewcode-block" id="mesh.merge"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Mesh2</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">,</span><span class="n">cleanup</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">cleanup</span><span class="o">=</span><span class="n">cleanup</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Mesh2</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">MeshList</span> <span class="o">=</span> <span class="n">Mesh2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">MeshList</span> <span class="o">=</span> <span class="p">[</span><span class="n">Mesh2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">MeshList</span><span class="p">:</span>
            <span class="c1"># Original Stats</span>
            <span class="n">NNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NNode</span>
            <span class="n">NElem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NElem</span>
            <span class="n">NFace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NFace</span>
            <span class="n">NEdge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NEdge</span>
            
            <span class="c1"># Add Nodes</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeSets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeSets</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)):</span>
                    <span class="n">keyName</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">addNodes</span><span class="p">([</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeSets</span><span class="p">[</span><span class="n">keyName</span><span class="p">]],</span><span class="n">NodeSet</span><span class="o">=</span><span class="n">keyName</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addNodes</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>
            <span class="c1"># Add Edges </span>
            <span class="c1"># if len(M.EdgeSets) &gt; 1:</span>
            <span class="c1">#     keys = list(M.EdgeSets.keys())</span>
            <span class="c1">#     for i in range(len(keys)):</span>
            <span class="c1">#         keyName = keys[i]</span>
            <span class="c1">#         self.addEdges([[node+NNode for node in M.Edges()[edge]] for edge in M.EdgeSets[keyName]],EdgeSet=keyName)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     self.addEdges([[node+NNode for node in M.Edges()[edge]] for edge in range(len(M.Edges()))])</span>
            <span class="c1"># # Add Faces  </span>
            <span class="c1"># if len(M.FaceSets) &gt; 1:</span>
            <span class="c1">#     keys = list(M.FaceSets.keys())</span>
            <span class="c1">#     for i in range(len(keys)):</span>
            <span class="c1">#         keyName = keys[i]</span>
            <span class="c1">#         self.addFaces([[node+NNode for node in M.Faces()[face]] for face in M.FaceSets[keyName]],FaceSet=keyName)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     self.addFaces([[node+NNode for node in M.Faces()[face]] for face in range(len(M.Faces()))])</span>
            <span class="c1"># Add Elems</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">ElemSets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">ElemSets</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)):</span>
                    <span class="n">keyName</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">addElems</span><span class="p">([[</span><span class="n">node</span><span class="o">+</span><span class="n">NNode</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">elem</span><span class="p">]]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">ElemSets</span><span class="p">[</span><span class="n">keyName</span><span class="p">]],</span><span class="n">ElemSet</span><span class="o">=</span><span class="n">keyName</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addElems</span><span class="p">([[</span><span class="n">node</span><span class="o">+</span><span class="n">NNode</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">elem</span><span class="p">]]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">))])</span>
                    
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span> <span class="o">+</span> <span class="p">[[</span><span class="n">elem</span> <span class="o">+</span> <span class="n">NElem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elemconn</span><span class="p">]</span> <span class="k">for</span> <span class="n">elemconn</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">_FaceElemConn</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span> <span class="o">+</span> <span class="p">[[</span><span class="n">face</span> <span class="o">+</span> <span class="n">NFace</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faceconn</span><span class="p">]</span> <span class="k">for</span> <span class="n">faceconn</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">_FaceConn</span><span class="p">]</span>
        
        <span class="c1"># Cleanup</span>
        <span class="k">if</span> <span class="n">cleanup</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cleanup</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NNode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NNode</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NNode</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NElem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NElem</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NElem</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NEdge</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NEdge</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NFace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NFace</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Faces</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NFace</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NEdge</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NEdge</span>
    <span class="k">def</span> <span class="nf">__get_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NElem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Get all element faces</span>
            <span class="n">faces</span><span class="p">,</span><span class="n">faceconn</span><span class="p">,</span><span class="n">faceelem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2faces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">return_FaceConn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_FaceElem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Pad Ragged arrays in case of mixed-element meshes</span>
            <span class="n">Rfaces</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
            <span class="n">Rfaceconn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">faceconn</span><span class="p">)</span>
            <span class="c1"># Get all unique element faces (accounting for flipped versions of faces)</span>
            <span class="n">_</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">Rfaces</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">RFaces</span> <span class="o">=</span> <span class="n">Rfaces</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">FaceElem</span> <span class="o">=</span> <span class="n">faceelem</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">RFaces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">RFaces</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">RFaces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">RFaceConn</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">Rfaceconn</span><span class="p">]</span> <span class="c1"># Faces attached to each element</span>
            <span class="c1"># Face-Element Connectivity</span>
            <span class="n">FaceElemConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">RFaces</span><span class="p">),</span><span class="mi">2</span><span class="p">)))</span> <span class="c1"># Elements attached to each face</span>

            <span class="n">FECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">FaceElem</span><span class="p">[</span><span class="n">RFaceConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NElem</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">RFaceConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">FaceElemConn</span><span class="p">[</span><span class="n">RFaceConn</span><span class="p">,</span><span class="n">FECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NElem</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">RFaceConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">FaceElemConn</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">FaceElemConn</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>


            <span class="n">Faces</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">ExtractRagged</span><span class="p">(</span><span class="n">RFaces</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">FaceConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">ExtractRagged</span><span class="p">(</span><span class="n">RFaceConn</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Faces</span><span class="p">,</span> <span class="n">FaceConn</span><span class="p">,</span> <span class="n">FaceElemConn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Identifying element faces...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+=</span><span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_faces</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">-=</span><span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">FaceConn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Identifying element-face connectivity...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+=</span><span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_faces</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">-=</span><span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">FaceElemConn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Identifying element face-element connectivity...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+=</span><span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_faces</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">-=</span><span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Edges</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Identifying element edges...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Edges</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Edges</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">SurfConn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SurfConn</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Identifying surface...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_SurfConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2surface</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SurfConn</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NodeNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNeighbors</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Identifying volume node neighbors...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNeighbors</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ElemConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNeighbors</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ElemConn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ElemConn</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Identifying volume node neighbors...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNeighbors</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ElemConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ElemConn</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">SurfNodeNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SurfNodeNeighbors</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Identifying surface node neighbors...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+=</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_SurfNodeNeighbors</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_SurfElemConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">-=</span><span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SurfNodeNeighbors</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">SurfElemConn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SurfElemConn</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Identifying surface node neighbors...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+=</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_SurfNodeNeighbors</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_SurfElemConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">-=</span><span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SurfElemConn</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ElemNormals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ElemNormals</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Calculating surface element normals...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+=</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ElemNormals</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">-=</span><span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ElemNormals</span>        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NodeNormalsMethod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNormalsMethod</span>
    <span class="nd">@NodeNormalsMethod</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">NodeNormalsMethod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNormals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNormalsMethod</span> <span class="o">=</span> <span class="n">method</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NodeNormals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNormals</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Calculating surface node normals...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+=</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNormals</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">Face2NodeNormal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">SurfElemConn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemNormals</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeNormalsMethod</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">-=</span><span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NodeNormals</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Centroids</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="o">+</span><span class="s1">&#39;Calculating element centroids...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Centroids</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_printlevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Centroids</span>
    
<div class="viewcode-block" id="mesh.RenumberNodesBySet"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.RenumberNodesBySet">[docs]</a>    <span class="k">def</span> <span class="nf">RenumberNodesBySet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Re-organize the order of nodes based on their node sets and make required adjustments to other stored values</span>
        <span class="n">setkeys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeSets</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># newIds is a list of node ids where the new index is located at the old index</span>
        <span class="n">newIds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">))</span>
        <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Renumber nodes in node sets</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">setkeys</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">end</span>
            <span class="n">end</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeSets</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">newIds</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeSets</span><span class="p">[</span><span class="n">key</span><span class="p">])]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NodeSets</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">)</span>
            
        <span class="c1"># Renumber any nodes that aren&#39;t in node sets</span>
        <span class="n">newIds</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">newIds</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">RelabelNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">newIds</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Faces&#39;</span><span class="p">,</span><span class="s1">&#39;FaceElemConn&#39;</span><span class="p">,</span><span class="s1">&#39;FaceConn&#39;</span><span class="p">])</span></div>
<div class="viewcode-block" id="mesh.RenumberFacesBySet"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.RenumberFacesBySet">[docs]</a>    <span class="k">def</span> <span class="nf">RenumberFacesBySet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">setkeys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># newIds is a list of face ids where the new index is located at the old index</span>
        <span class="n">newIds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Faces</span><span class="p">))</span>
        <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Renumber faces in face sets</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">setkeys</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">end</span>
            <span class="n">end</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">newIds</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="p">[</span><span class="n">key</span><span class="p">])]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">)</span>
        <span class="c1"># Renumber any faces that aren&#39;t in face sets</span>
        <span class="n">newIds</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">newIds</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">newIds</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">newIds</span> <span class="o">=</span> <span class="n">newIds</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Reorder faces</span>
        <span class="n">NewFaces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Faces</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">NewFaceElemConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FaceElemConn</span><span class="p">))</span>

        <span class="n">NewFaces</span><span class="p">[</span><span class="n">newIds</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Faces</span><span class="p">)</span>
        <span class="n">NewFaceElemConn</span><span class="p">[</span><span class="n">newIds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FaceElemConn</span>


        <span class="n">NewFaceConn</span> <span class="o">=</span> <span class="n">newIds</span><span class="p">[</span><span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FaceConn</span><span class="p">)]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">ExtractRagged</span><span class="p">(</span><span class="n">NewFaces</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FaceElemConn</span> <span class="o">=</span> <span class="n">NewFaceElemConn</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FaceConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">ExtractRagged</span><span class="p">(</span><span class="n">NewFaceConn</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="mesh.CreateBoundaryLayer"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.CreateBoundaryLayer">[docs]</a>    <span class="k">def</span> <span class="nf">CreateBoundaryLayer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nLayers</span><span class="p">,</span><span class="n">FixedNodes</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span><span class="n">StiffnessFactor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">Thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">OptimizeTets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">FaceSets</span><span class="o">=</span><span class="s1">&#39;surf&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CreateBoundaryLayer Generate boundary layer elements </span>
<span class="sd">        Based partially on &#39;A Procedure for Tetrahedral Boundary Layer Mesh Generation&#39; - Bottaso and Detomi</span>
<span class="sd">        Currently surfaces must be strictly triangular.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nLayers : int</span>
<span class="sd">            Number of element layers to generate. </span>
<span class="sd">        FixedNodes : set or list, optional</span>
<span class="sd">            Set of nodes that will be held fixed, by default set().</span>
<span class="sd">            It is not necessary to specify any fixed nodes, and by default </span>
<span class="sd">            the starting nodes of the boundary layer will be held fixed.</span>
<span class="sd">        StiffnessFactor : int or float, optional</span>
<span class="sd">            Stiffness factor used for the spring network, by default 1</span>
<span class="sd">        Thickness : float or NoneType, optional</span>
<span class="sd">            Specified value for the maximum total thickness of the boundary layers. </span>
<span class="sd">            If nLayers &gt; 1, this thickness is subdivided by nLayers, by default None</span>
<span class="sd">        OptimizeTets : bool, optional</span>
<span class="sd">            If True, will perform tetrahedral mesh optimization</span>
<span class="sd">            (see Improvement.TetOpt), by default True.</span>
<span class="sd">        FaceSets : str or list, optional</span>
<span class="sd">            FaceSet or list of FaceSets to generate boundary later elements on, by default [&#39;surf&#39;].</span>
<span class="sd">            While mesh.FaceSets can generally contain any element face, boundary layer face sets</span>
<span class="sd">            must be surface faces; however, the face ids contained within the face sets should index</span>
<span class="sd">            mesh.Faces, and not mesh.SurfConn. The default value of &#39;surf&#39; can be used even if no </span>
<span class="sd">            sets exist in mesh.FaceSets and will generate boundary layer elements along the entire </span>
<span class="sd">            surface. If mesh.FaceSets is empty, or doesn&#39;t contain a key with the name &#39;surf&#39;, the</span>
<span class="sd">            surface mesh will be used, otherwise, mesh.FaceSets[&#39;surf&#39;] will be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">FixedNodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">:</span>
            <span class="n">FixedNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">FixedNodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">FaceSets</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span> 
            <span class="n">FaceSets</span> <span class="o">=</span> <span class="p">[</span><span class="n">FaceSets</span><span class="p">]</span>

        <span class="c1"># Create first layer with 0 thickness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="s1">&#39;SurfConn&#39;</span><span class="p">)</span>
        <span class="n">NOrigElem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NElem</span>
        <span class="n">OrigConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeNormalsMethod</span> <span class="o">=</span> <span class="s1">&#39;MostVisible&#39;</span>
        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeNormals</span>
        <span class="n">surfconn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SurfConn</span>
        <span class="n">surfnodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">surfconn</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">FaceSets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="s1">&#39;surf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">FaceSets</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Requested FaceSets are undefined.&#39;</span><span class="p">)</span>
            <span class="n">ForceNodes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">surfnodes</span><span class="p">)</span>            

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ForceNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">FaceSets</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Requested set &quot;</span><span class="si">{:s}</span><span class="s1">&quot; is undefined.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
                <span class="n">FaceIds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FaceSets</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">FaceNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">FaceIds</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Faces</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">ForceNodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">FaceNodes</span><span class="p">)</span>
            <span class="n">NoGrowthNodes</span> <span class="o">=</span> <span class="n">surfnodes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">ForceNodes</span><span class="p">)</span>
            <span class="n">FixedNodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">NoGrowthNodes</span><span class="p">)</span>


        <span class="n">newsurfconn</span> <span class="o">=</span> <span class="p">[[</span><span class="n">node</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">surfconn</span><span class="p">]</span>
        <span class="n">newsurfnodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">newsurfconn</span><span class="p">)</span>
        <span class="n">BLConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="o">+</span> <span class="n">newsurfconn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surfconn</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addElems</span><span class="p">(</span><span class="n">BLConn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="n">FixedNodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">newsurfnodes</span><span class="p">)</span>
        <span class="n">Forces</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ForceNodes</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NNode</span><span class="p">)]</span>
        <span class="n">allnodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span>
        <span class="n">FixedNodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allnodes</span><span class="p">))</span>
        <span class="n">Fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">FixedNodes</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NNode</span><span class="p">)])</span>

        <span class="c1"># Oriented wedge-&gt;tet conversion -  (Bottasso &amp; Detomi)</span>
        <span class="c1"># surfedges = converter.solid2edges(self.NodeCoords,surfconn)</span>
        <span class="n">surfedges</span><span class="p">,</span><span class="n">surfedgeconn</span><span class="p">,</span><span class="n">surfedgeelem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">newsurfconn</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_EdgeConn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">UEdges</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">inv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">surfedges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">UEdgeConn</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">surfedgeconn</span><span class="p">]</span>

        <span class="n">NodeEdges</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">UEdges</span><span class="p">):</span>
            <span class="n">NodeEdges</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">NodeEdges</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="n">oriented</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">))</span> <span class="c1"># 1 will indicate that the edge will be oriented as is, -1 indicates a flip</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">newsurfnodes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">NodeEdges</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">oriented</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">UEdges</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                        <span class="n">oriented</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">oriented</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">OrientedEdges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">UEdges</span><span class="p">)</span>
        <span class="n">OrientedEdges</span><span class="p">[</span><span class="n">oriented</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">UEdges</span><span class="p">[</span><span class="n">oriented</span><span class="o">==-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">surfedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">surfedges</span><span class="p">)</span>
        
        <span class="c1"># Tetrahedronization:</span>
        <span class="c1"># For each triangle, ElemEdgeOrientations will have a 3 entries, corresponding to the orientation of the edges</span>
        <span class="c1"># For a particular edge in an element, True -&gt; the oriented edge is oriented clockwise, False -&gt; counterclockwise </span>
        <span class="n">ElemEdgeOrientations</span> <span class="o">=</span> <span class="p">(</span><span class="n">OrientedEdges</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">surfedges</span><span class="p">[</span><span class="n">surfedgeconn</span><span class="p">])[:,:,</span><span class="mi">0</span><span class="p">]</span> 

        <span class="c1"># The are 6 possible combinations</span>
        <span class="n">Cases</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">surfconn</span><span class="p">))</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ElemEdgeOrientations</span><span class="o">==</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ElemEdgeOrientations</span><span class="o">==</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">,</span><span class="kc">True</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ElemEdgeOrientations</span><span class="o">==</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">,</span><span class="kc">False</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ElemEdgeOrientations</span><span class="o">==</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ElemEdgeOrientations</span><span class="o">==</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ElemEdgeOrientations</span><span class="o">==</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="kc">False</span><span class="p">,</span><span class="kc">True</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">6</span>

        
        <span class="c1"># Each triangle in surfconn lines up with the indices of wedges in BLConn</span>
        <span class="n">ArrayConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">BLConn</span><span class="p">)</span>
        <span class="n">TetConn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">BLConn</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ArrayConn</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ArrayConn</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ArrayConn</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
        <span class="c1"># Case 1:</span>
        <span class="n">t1</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">1</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
        <span class="n">t2</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">1</span><span class="p">][:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">t3</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">1</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
        <span class="c1"># Case 2:</span>
        <span class="n">t1</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">2</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
        <span class="n">t2</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">2</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
        <span class="n">t3</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">2</span><span class="p">][:,[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
        <span class="c1"># Case 3:</span>
        <span class="n">t1</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">3</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
        <span class="n">t2</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">3</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
        <span class="n">t3</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">3</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
        <span class="c1"># Case 4:</span>
        <span class="n">t1</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">4</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
        <span class="n">t2</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">4</span><span class="p">][:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
        <span class="n">t3</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">4</span><span class="p">][:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
        <span class="c1"># Case 5:</span>
        <span class="n">t1</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">5</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
        <span class="n">t2</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">5</span><span class="p">][:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
        <span class="n">t3</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">5</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
        <span class="c1"># Case 6:</span>
        <span class="n">t1</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">6</span><span class="p">][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
        <span class="n">t2</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">6</span><span class="p">][:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
        <span class="n">t3</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">Cases</span><span class="o">==</span><span class="mi">6</span><span class="p">][:,[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
        
        <span class="n">TetConn</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
        <span class="n">TetConn</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">t2</span>
        <span class="n">TetConn</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">t3</span>
        <span class="n">TetConn</span> <span class="o">=</span> <span class="n">TetConn</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># RelevantElems = [elem for elem in self.NodeConn if not all([n in FixedNodes for n in elem])]</span>
        <span class="n">RelevantElems</span> <span class="o">=</span> <span class="n">TetConn</span> <span class="o">+</span> <span class="p">[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">RelevantCoords</span><span class="p">,</span><span class="n">RelevantConn</span><span class="p">,</span><span class="n">NodeIds</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">removeNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">RelevantElems</span><span class="p">)</span> 

        <span class="c1"># TetConn = converter.solid2tets(RelevantCoords,RelevantConn)</span>
        <span class="n">RelevantNodeNeighbors</span><span class="p">,</span><span class="n">RelevantElemConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">RelevantCoords</span><span class="p">,</span><span class="n">RelevantConn</span><span class="p">)</span>
        <span class="n">RelevantForces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Forces</span><span class="p">)[</span><span class="n">NodeIds</span><span class="p">]</span>
        <span class="n">RelevantFixed</span> <span class="o">=</span> <span class="n">Fixed</span><span class="p">[</span><span class="n">NodeIds</span><span class="p">]</span>
        <span class="n">RelevantFixedNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">RelevantFixed</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Thickness</span><span class="p">:</span>
            <span class="n">L0Override</span> <span class="o">=</span> <span class="n">Thickness</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">L0Override</span> <span class="o">=</span> <span class="s1">&#39;min&#39;</span>
        
        <span class="c1"># Expand boundary layer</span>
        <span class="n">NewRelevantCoords</span><span class="p">,</span><span class="n">U</span><span class="p">,(</span><span class="n">K</span><span class="p">,</span><span class="n">F</span><span class="p">)</span> <span class="o">=</span> <span class="n">Improvement</span><span class="o">.</span><span class="n">SegmentSpringSmoothing</span><span class="p">(</span><span class="n">RelevantCoords</span><span class="p">,</span><span class="n">RelevantConn</span><span class="p">,</span>
            <span class="n">RelevantNodeNeighbors</span><span class="p">,</span><span class="n">RelevantElemConn</span><span class="p">,</span><span class="n">StiffnessFactor</span><span class="o">=</span><span class="n">StiffnessFactor</span><span class="p">,</span>
            <span class="n">FixedNodes</span><span class="o">=</span><span class="n">RelevantFixedNodes</span><span class="p">,</span><span class="n">Forces</span><span class="o">=</span><span class="n">RelevantForces</span><span class="p">,</span><span class="n">L0Override</span><span class="o">=</span><span class="n">L0Override</span><span class="p">,</span><span class="n">return_KF</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Thickness</span><span class="p">:</span>
            <span class="c1"># Find stiffness factor that gives desired thickness</span>

            <span class="c1"># Full solve:</span>
            <span class="c1"># def fun(k):</span>
            <span class="c1">#     NewRelevantCoords,_ = Improvement.SegmentSpringSmoothing(RelevantCoords,TetConn,</span>
            <span class="c1">#                                 RelevantNodeNeighbors,RelevantElemConn,StiffnessFactor=k,</span>
            <span class="c1">#                                 FixedNodes=RelevantFixedNodes,Forces=RelevantForces,L0Override=L0Override)</span>
            <span class="c1">#     t = max(np.linalg.norm(U,axis=1))</span>
            <span class="c1">#     # print(k,t)</span>
            <span class="c1">#     return abs(Thickness - t)</span>
            <span class="c1"># res = scipy.optimize.minimize_scalar(fun,(StiffnessFactor,StiffnessFactor/10),tol=ThicknessTol,options={&#39;maxiter&#39;:ThicknessMaxIter})</span>

            <span class="c1"># Scaled K matrix:</span>
            <span class="c1"># def fun(k):</span>
            <span class="c1">#     U = scipy.sparse.linalg.spsolve((k/StiffnessFactor)*K.tocsc(), F).toarray()</span>
            <span class="c1">#     t = max(np.linalg.norm(U,axis=1))</span>
            <span class="c1">#     print(k,t)</span>
            <span class="c1">#     return abs(Thickness - t)s</span>
            <span class="c1"># res = scipy.optimize.minimize_scalar(fun,(StiffnessFactor,StiffnessFactor/10),tol=ThicknessTol,options={&#39;maxiter&#39;:ThicknessMaxIter})</span>
            <span class="c1"># k = res.x</span>
            
            <span class="c1"># Power Law:</span>
            <span class="c1"># t = max(np.linalg.norm(NewCoords[ForceNodes] - NewCoords[SurfNodes],axis=1))</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">StiffnessFactor</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">Thickness</span><span class="o">**-</span><span class="mi">1</span>
            <span class="n">U2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">K</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span><span class="o">/</span><span class="n">StiffnessFactor</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
            <span class="c1"># t2 = max(np.linalg.norm(U2,axis=1))</span>
            <span class="n">NewRelevantCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">RelevantCoords</span><span class="p">,</span> <span class="n">U2</span><span class="p">)</span>

        <span class="n">NewCoords</span><span class="p">[</span><span class="n">NodeIds</span><span class="p">]</span> <span class="o">=</span> <span class="n">NewRelevantCoords</span>

        <span class="c1"># Collapse transition elements</span>



        <span class="k">if</span> <span class="n">OptimizeTets</span><span class="p">:</span>
            <span class="n">Tets</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">skew</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">Skewness</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">Tets</span><span class="p">)</span>
            <span class="n">BadElems</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">skew</span><span class="o">&gt;</span><span class="mf">0.9</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getElemNeighbors</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">Tets</span><span class="p">)</span>
            <span class="n">BadElems</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">BadElems</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">BadNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">BadElems</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Tets</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2surface</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">Tets</span><span class="p">)</span>
            <span class="n">SurfNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">SurfConn</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span>

            <span class="n">FreeNodes</span> <span class="o">=</span> <span class="n">BadNodes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">SurfNodes</span><span class="p">)</span>

            <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">Improvement</span><span class="o">.</span><span class="n">TetOpt</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">Tets</span><span class="p">,</span><span class="n">FreeNodes</span><span class="o">=</span><span class="n">FreeNodes</span><span class="p">,</span><span class="n">objective</span><span class="o">=</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;BFGS&#39;</span><span class="p">,</span><span class="n">iterate</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        
        <span class="c1"># Divide the boundary layer to create the specified number of layers</span>
        <span class="k">if</span> <span class="n">nLayers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
            <span class="n">nNum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">)</span>
            <span class="n">NewCoords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">)</span>        
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NOrigElem</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NElem</span><span class="p">):</span>
                <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">NewNodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">NewElems</span> <span class="o">=</span> <span class="p">[[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span> <span class="o">+</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nLayers</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nLayers</span><span class="p">):</span>
                    <span class="n">NewNodes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">NewCoords2</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">NewCoords2</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span><span class="o">-</span><span class="n">NewCoords2</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">*</span><span class="n">j</span><span class="o">/</span><span class="n">nLayers</span><span class="p">,</span> 
                                     <span class="n">NewCoords2</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">NewCoords2</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span><span class="o">-</span><span class="n">NewCoords2</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">*</span><span class="n">j</span><span class="o">/</span><span class="n">nLayers</span><span class="p">,</span> 
                                     <span class="n">NewCoords2</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">NewCoords2</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span><span class="o">-</span><span class="n">NewCoords2</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span><span class="o">*</span><span class="n">j</span><span class="o">/</span><span class="n">nLayers</span><span class="p">]</span>
                    <span class="n">NewElems</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">NewElems</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">NewElems</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span><span class="n">NewElems</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">5</span><span class="p">],</span><span class="n">nNum</span><span class="p">,</span><span class="n">nNum</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nNum</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">NewElems</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nNum</span><span class="p">,</span><span class="n">nNum</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nNum</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">nNum</span><span class="p">,</span><span class="n">nNum</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nNum</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">nNum</span> <span class="o">+=</span> <span class="mi">3</span>
                <span class="n">NewElems</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">NewElems</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">NewElems</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span><span class="n">NewElems</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>
                <span class="n">NewCoords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NewCoords2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NewNodes</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">OrigConn</span> <span class="o">+=</span> <span class="n">NewElems</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">NewCoords2</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="o">=</span> <span class="n">OrigConn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">NewCoords</span>
        

        <span class="c1"># Reduce or remove degenerate wedges -- TODO: This can probably be made more efficient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
        <span class="n">Unq</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span><span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">]</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">([</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Unq</span><span class="p">],</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">Cases</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NElem</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Fully degenerate wedges (triangles):</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Double-edge degenerate wedges (tetrahedrons):</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="c1"># Single-edge degenerate wedges (pyramids):</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">7</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">9</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">11</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">12</span>
        <span class="c1"># Non-wedges</span>
        <span class="n">nNodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">])</span>
        <span class="n">Cases</span><span class="p">[</span><span class="n">nNodes</span><span class="o">!=</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">ProperKeys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[],</span>             <span class="c1"># 0</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>      <span class="c1"># 1</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>      <span class="c1"># 2</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>      <span class="c1"># 3</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>      <span class="c1"># 4</span>
            <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>      <span class="c1"># 5</span>
            <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>      <span class="c1"># 6</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>    <span class="c1"># 7</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>    <span class="c1"># 8</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>    <span class="c1"># 9</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>    <span class="c1"># 10</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>    <span class="c1"># 11</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>     <span class="c1"># 12</span>
        <span class="p">]</span>
        <span class="n">RNodeConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">case</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Cases</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">case</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">RNodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ProperKeys</span><span class="p">[</span><span class="n">case</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Attempt to fix any element inversions</span>
        <span class="c1"># NewCoords = np.asarray(NewCoords)</span>
        <span class="c1"># NewRelevantCoords = NewCoords[NodeIds]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">Volume</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">V</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">))</span>
            <span class="c1"># BLConn = [elem for elem in self.NodeConn if len(elem) == 6]</span>
            <span class="c1"># self.NodeCoords = Improvement.FixInversions(self.NodeCoords,BLConn,FixedNodes=np.unique(converter.solid2surface(self.NodeCoords,self.NodeConn)))</span>
            <span class="n">BadElems</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">V</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getElemNeighbors</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">BadElems</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">BadElems</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">BadNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">BadElems</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="c1"># self.reset(&#39;SurfConn&#39;)</span>
            <span class="n">SurfNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SurfConn</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span>

            <span class="n">FreeNodes</span> <span class="o">=</span> <span class="n">BadNodes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">SurfNodes</span><span class="p">)</span>
            <span class="n">FixedNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NNode</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">FreeNodes</span><span class="p">)</span>
            <span class="c1"># NewRelevantCoords = Improvement.TetOpt(NewRelevantCoords,RelevantConn,FreeNodes=FreeNodes,objective=&#39;eta&#39;,method=&#39;BFGS&#39;,iterate=4)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">Improvement</span><span class="o">.</span><span class="n">FixInversions</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">FixedNodes</span><span class="o">=</span><span class="n">FixedNodes</span><span class="p">)</span>
            <span class="c1"># NewCoords[NodeIds] = NewRelevantCoords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="mesh.getQuality"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.getQuality">[docs]</a>    <span class="k">def</span> <span class="nf">getQuality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Skewness&#39;</span><span class="p">,</span><span class="s1">&#39;Aspect Ratio&#39;</span><span class="p">,</span><span class="s1">&#39;Inverse Orthogonal Quality&#39;</span><span class="p">,</span><span class="s1">&#39;Inverse Orthogonality&#39;</span><span class="p">,</span><span class="s1">&#39;Min Dihedral(deg)&#39;</span><span class="p">,</span><span class="s1">&#39;Max Dihedral(deg)&#39;</span><span class="p">,</span><span class="s1">&#39;Volume&#39;</span><span class="p">]):</span>
        
        <span class="n">quality</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span> <span class="n">metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">metrics</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Skewness&#39;</span><span class="p">:</span>
                <span class="n">quality</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">Skewness</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Aspect Ratio&#39;</span><span class="p">:</span>
                <span class="n">quality</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">AspectRatio</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>    
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Inverse Orthogonal Quality&#39;</span><span class="p">:</span>
                <span class="n">quality</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">InverseOrthogonalQuality</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Orthogonal Quality&#39;</span><span class="p">:</span>
                <span class="n">quality</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">OrthogonalQuality</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Inverse Orthogonality&#39;</span><span class="p">:</span>
                <span class="n">quality</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">InverseOrthogonality</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Orthogonality&#39;</span><span class="p">:</span>
                <span class="n">quality</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">Orthogonality</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Min Dihedral&#39;</span><span class="p">:</span>
                <span class="n">quality</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">MinDihedral</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Min Dihedral(deg)&#39;</span><span class="p">:</span>
                <span class="n">quality</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">MinDihedral</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Max Dihedral&#39;</span><span class="p">:</span>
                <span class="n">quality</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">MaxDihedral</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Max Dihedral(deg)&#39;</span><span class="p">:</span>
                <span class="n">quality</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">MaxDihedral</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            
            <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;Volume&#39;</span><span class="p">:</span>
                <span class="n">quality</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quality</span><span class="o">.</span><span class="n">Volume</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid quality metric.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">quality</span></div>

<div class="viewcode-block" id="mesh.getCurvature"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.getCurvature">[docs]</a>    <span class="k">def</span> <span class="nf">getCurvature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Max Principal&#39;</span><span class="p">,</span><span class="s1">&#39;Min Principal&#39;</span><span class="p">,</span> <span class="s1">&#39;Curvedness&#39;</span><span class="p">,</span> <span class="s1">&#39;Shape Index&#39;</span><span class="p">],</span> <span class="n">nRings</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">SplitFeatures</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span> <span class="n">metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">metrics</span><span class="p">]</span>
        <span class="n">Curvature</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">SplitFeatures</span><span class="p">:</span>
            <span class="n">edges</span><span class="p">,</span><span class="n">corners</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">DetectFeatures</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">)</span>
            <span class="n">FeatureNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
            <span class="n">NodeRegions</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getConnectedNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">,</span><span class="n">BarrierNodes</span><span class="o">=</span><span class="n">FeatureNodes</span><span class="p">)</span>
            <span class="n">MaxPs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">NNode</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeRegions</span><span class="p">)))</span> 
            <span class="n">MinPs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">NNode</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeRegions</span><span class="p">)))</span> 
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeRegions</span><span class="p">):</span>
                <span class="n">Elems</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SurfConn</span> <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">n</span> <span class="ow">in</span> <span class="n">region</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])]</span>
                <span class="c1"># ElemNormals = [self.ElemNormals[i] for i,elem in enumerate(self.SurfConn) if all([n in region for n in elem])]</span>
                <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">Elems</span><span class="p">)</span>
                <span class="n">Neighbors</span><span class="p">,</span><span class="n">ElemConn</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">Elems</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nRings</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">Neighbors</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighborhood</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">Elems</span><span class="p">,</span><span class="n">nRings</span><span class="p">)</span>
                <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">Face2NodeNormal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">Elems</span><span class="p">,</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">ElemNormals</span><span class="p">)</span>
                <span class="n">MaxPs</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="n">MinPs</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curvature</span><span class="o">.</span><span class="n">CubicFit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">Elems</span><span class="p">,</span><span class="n">Neighbors</span><span class="p">,</span><span class="n">NodeNormals</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="n">MaxPrincipal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">MaxPs</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">MinPrincipal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">MinPs</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nRings</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">Neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SurfNodeNeighbors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Neighbors</span> <span class="o">=</span> <span class="n">MeshUtils</span><span class="o">.</span><span class="n">getNodeNeighborhood</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">,</span><span class="n">nRings</span><span class="o">=</span><span class="n">nRings</span><span class="p">)</span>
            <span class="n">MaxPrincipal</span><span class="p">,</span><span class="n">MinPrincipal</span> <span class="o">=</span> <span class="n">curvature</span><span class="o">.</span><span class="n">CubicFit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">,</span><span class="n">Neighbors</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeNormals</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;Max Principal&#39;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="n">Curvature</span><span class="p">[</span><span class="s1">&#39;Max Principal Curvature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MaxPrincipal</span>
        <span class="k">if</span> <span class="s1">&#39;Max Principal&#39;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="n">Curvature</span><span class="p">[</span><span class="s1">&#39;Min Principal Curvature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MinPrincipal</span>
        <span class="k">if</span> <span class="s1">&#39;Shape Index&#39;</span> <span class="ow">in</span> <span class="n">metrics</span> <span class="ow">or</span> <span class="s1">&#39;Shape Category&#39;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="n">SI</span> <span class="o">=</span> <span class="n">curvature</span><span class="o">.</span><span class="n">ShapeIndex</span><span class="p">(</span><span class="n">MaxPrincipal</span><span class="p">,</span><span class="n">MinPrincipal</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;Shape Index&#39;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
                <span class="n">Curvature</span><span class="p">[</span><span class="s1">&#39;Shape Index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SI</span>
        <span class="k">if</span> <span class="s1">&#39;Shape Category&#39;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="n">SC</span> <span class="o">=</span> <span class="n">curvature</span><span class="o">.</span><span class="n">ShapeCategory</span><span class="p">(</span><span class="n">SI</span><span class="p">)</span>
            <span class="n">Curvature</span><span class="p">[</span><span class="s1">&#39;Shape Category&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SC</span>
        <span class="k">if</span> <span class="s1">&#39;Curvedness&#39;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">curvature</span><span class="o">.</span><span class="n">Curvedness</span><span class="p">(</span><span class="n">MaxPrincipal</span><span class="p">,</span><span class="n">MinPrincipal</span><span class="p">)</span>
            <span class="n">Curvature</span><span class="p">[</span><span class="s1">&#39;Curvedness&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span>
        <span class="k">if</span> <span class="s1">&#39;Gaussian&#39;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">curvature</span><span class="o">.</span><span class="n">GaussianCurvature</span><span class="p">(</span><span class="n">MaxPrincipal</span><span class="p">,</span><span class="n">MinPrincipal</span><span class="p">)</span>
            <span class="n">Curvature</span><span class="p">[</span><span class="s1">&#39;Gaussian Curvature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span>
        <span class="k">if</span> <span class="s1">&#39;Mean&#39;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">curvature</span><span class="o">.</span><span class="n">MeanCurvature</span><span class="p">(</span><span class="n">MaxPrincipal</span><span class="p">,</span><span class="n">MinPrincipal</span><span class="p">)</span>
            <span class="n">Curvature</span><span class="p">[</span><span class="s1">&#39;Mean Curvature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span>
        
        <span class="k">return</span> <span class="n">Curvature</span></div>

<div class="viewcode-block" id="mesh.save"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;pickle&#39;</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">face</span><span class="p">]</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Faces</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SurfConn</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">face</span><span class="p">]</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SurfConn</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;pickle&#39;</span> <span class="ow">or</span> <span class="s1">&#39;.pickle&#39;</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;.pickle&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span> <span class="n">filename</span> <span class="o">+=</span> <span class="s1">&#39;.pickle&#39;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;json&#39;</span> <span class="ow">or</span> <span class="s1">&#39;.json&#39;</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;.json&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span> <span class="n">filename</span> <span class="o">+=</span> <span class="s1">&#39;.json&#39;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
                
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown method&#39;</span><span class="p">)</span></div>
<div class="viewcode-block" id="mesh.load"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;json&#39;</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;pickle&#39;</span> <span class="ow">or</span> <span class="s1">&#39;.pickle&#39;</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;.pickle&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span> <span class="n">filename</span> <span class="o">+=</span> <span class="s1">&#39;.pickle&#39;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;json&#39;</span> <span class="ow">or</span> <span class="s1">&#39;.json&#39;</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;.json&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span> <span class="n">filename</span> <span class="o">+=</span> <span class="s1">&#39;.json&#39;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unrecognized file&#39;</span><span class="p">)</span>   </div>
<div class="viewcode-block" id="mesh.Mesh2Meshio"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.Mesh2Meshio">[docs]</a>    <span class="k">def</span> <span class="nf">Mesh2Meshio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">PointData</span><span class="o">=</span><span class="p">{},</span><span class="n">CellData</span><span class="o">=</span><span class="p">{}):</span>
        
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NodeCoords</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">PointData</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">PointData</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;_NodeVals_&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PointData</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">PointData</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NodeData</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeData</span><span class="p">,</span><span class="o">**</span><span class="n">PointData</span><span class="p">}</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">CellData</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">CellData</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">[</span><span class="s1">&#39;_ElemVals_&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">CellData</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">CellData</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">,</span><span class="o">**</span><span class="n">CellData</span><span class="p">}</span>

        <span class="n">celldict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">celldata</span> <span class="o">=</span> <span class="p">[[],[],[],[],[]]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nD</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">):</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">celldata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">celldata</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">celldata</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">celldata</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">celldata</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ElemData</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="n">celldata</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">celldata</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">celldict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">celldata</span>
        <span class="n">tris</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># n = 3            </span>
        <span class="n">tets</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># n = 4</span>
        <span class="n">pyrs</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># n = 5</span>
        <span class="n">wdgs</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># n = 6</span>
        <span class="n">hexs</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># n = 8</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">tris</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">tets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">pyrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="n">wdgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">hexs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        
        <span class="n">elems</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">&#39;triangle&#39;</span><span class="p">,</span><span class="n">tris</span><span class="p">),(</span><span class="s1">&#39;tetra&#39;</span><span class="p">,</span><span class="n">tets</span><span class="p">),(</span><span class="s1">&#39;pyramid&#39;</span><span class="p">,</span><span class="n">pyrs</span><span class="p">),(</span><span class="s1">&#39;wedge&#39;</span><span class="p">,</span><span class="n">wdgs</span><span class="p">),(</span><span class="s1">&#39;hexahedron&#39;</span><span class="p">,</span><span class="n">hexs</span><span class="p">)]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">meshio</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">elems</span><span class="p">,</span> <span class="n">point_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">NodeData</span><span class="p">,</span> <span class="n">cell_data</span><span class="o">=</span><span class="n">celldict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="mesh.write"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.mesh.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NNode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Mesh empty - file not written.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Mesh2Meshio</span><span class="p">()</span>
        <span class="n">m</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div></div>

        
                
<div class="viewcode-block" id="Meshio2Mesh"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.Meshio2Mesh">[docs]</a><span class="k">def</span> <span class="nf">Meshio2Mesh</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>

    <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">NodeConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">cells</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">cells</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">point_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">M</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">cell_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">cell_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">M</span><span class="o">.</span><span class="n">ElemData</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span> <span class="k">for</span> <span class="n">celldata</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">celldata</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">M</span></div>

<div class="viewcode-block" id="read"><a class="viewcode-back" href="../../Mesh.html#Mesh.mesh.read">[docs]</a><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">meshio</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">Meshio2Mesh</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">M</span>  </div>
            
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Mesh</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, toj.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>