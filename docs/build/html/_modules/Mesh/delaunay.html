<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mesh.delaunay &mdash; Mesh 0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=10f1778b"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Mesh
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Mesh</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">Mesh.delaunay</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for Mesh.delaunay</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Sat Jan 15 12:02:26 2022</span>

<span class="sd">@author: toj</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#%%</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">itertools</span><span class="o">,</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span><span class="p">,</span> <span class="n">rays</span><span class="p">,</span> <span class="n">converter</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">spatial</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">plotly.offline</span> <span class="kn">import</span> <span class="n">plot</span>
    <span class="kn">import</span> <span class="nn">plotly.graph_objects</span> <span class="k">as</span> <span class="nn">go</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Optional dependencies not found - some functions may not work properly&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Triangulate">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.Triangulate">[docs]</a>
<span class="k">def</span> <span class="nf">Triangulate</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">Constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;Flips&#39;</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Triangulate _summary_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    Constraints : _type_, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        _description_, by default &#39;Flips&#39;</span>
<span class="sd">        &#39;Flips&#39; - Generate a Delaunay triangulation by a flipping algorithm</span>
<span class="sd">        &#39;IncrementalFlips&#39; - Generate a Delaunay triangulation by an incremental insertion flipping algorithm</span>
<span class="sd">        &#39;NonDelaunay&#39; - Generate a non-Delaunay triangulation by triangle splitting</span>
<span class="sd">        &#39;scipy&#39; - Use scipy.spatial.delaunay</span>
<span class="sd">        &#39;Triangle&#39; - Use Jonathon Shewchuk&#39;s Delaunay triangulator</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    
    <span class="n">Points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Constraints</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">Constraints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">Points</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">newId</span><span class="p">,</span><span class="n">idx</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">Points</span><span class="p">,[],</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;NonDelauanay&#39;</span><span class="p">:</span>
            <span class="n">Hull</span> <span class="o">=</span> <span class="n">ConvexHull_GiftWrapping</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">IncludeCollinear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">TriangleSplittingTriangulation</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">Hull</span><span class="o">=</span><span class="n">Hull</span><span class="p">)]</span>
        
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Flips&#39;</span><span class="p">:</span>
            <span class="n">Hull</span> <span class="o">=</span> <span class="n">ConvexHull_GiftWrapping</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">IncludeCollinear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">InitialConn</span> <span class="o">=</span> <span class="n">TriangleSplittingTriangulation</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">Hull</span><span class="o">=</span><span class="n">Hull</span><span class="p">)</span>
            <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">DelaunayFlips</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">InitialConn</span><span class="p">)]</span>
        
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;IncrementalFlips&#39;</span><span class="p">:</span>
            <span class="n">Hull</span> <span class="o">=</span> <span class="n">ConvexHull_GiftWrapping</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">IncludeCollinear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">ConvexHullFanTriangulation</span><span class="p">(</span><span class="n">Hull</span><span class="p">)</span>
            <span class="n">interior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">)),</span><span class="n">Hull</span><span class="p">,</span><span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">interior</span><span class="p">:</span>
                <span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">BaryTris</span><span class="p">(</span><span class="n">Points</span><span class="p">[</span><span class="n">NodeConn</span><span class="p">],</span><span class="n">Points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            
                <span class="c1"># currently not using special treatment for nodes on boundaries</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">-</span><span class="n">tol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">-</span><span class="n">tol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">-</span><span class="n">tol</span><span class="p">)</span>
                <span class="n">TriId</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inside</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Elem</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">TriId</span><span class="p">])</span>
                <span class="n">NodeConn</span><span class="p">[</span><span class="n">TriId</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">]</span>
                <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,[[</span><span class="n">Elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Elem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">i</span><span class="p">],[</span><span class="n">Elem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">Elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">DelaunayFlips</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
            <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">NodeConn</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;scipy&#39;</span><span class="p">:</span>
            <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">SciPy</span><span class="p">(</span><span class="n">Points</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Triangle&#39;</span><span class="p">:</span>
            <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">Triangle</span><span class="p">(</span><span class="n">Points</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid method.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">Points</span><span class="p">,</span><span class="n">Constraints</span> <span class="o">=</span> <span class="n">SplitConstraints_2d</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">Constraints</span><span class="p">)</span><span class="c1">#,tol=tol)</span>
        <span class="c1"># Constrained Deluanay Traingulation - Sloan (1993)</span>
        <span class="c1"># Generate initial triangulation</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Triangle&#39;</span><span class="p">:</span>
            <span class="n">Points</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">Triangle</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">Constraints</span><span class="o">=</span><span class="n">Constraints</span><span class="p">)</span>
        <span class="c1">###</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bk</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Constraints</span><span class="p">)</span>
            <span class="n">pbk</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
            <span class="c1">###</span>
            <span class="c1"># Check constraints for intersections (Shouldn&#39;t be necessary here):</span>
            <span class="c1"># if len(Constraints) &gt; 1:</span>
            <span class="c1">#     combinations = np.array(list(itertools.combinations(range(len(Constraints)),2)))</span>
            <span class="c1">#     e1 = NodeCoords[Constraints[combinations[:,0]]]</span>
            <span class="c1">#     e2 = NodeCoords[Constraints[combinations[:,1]]]</span>
            <span class="c1">#     eIntersections,eIntersectionPts = rays.SegmentsSegmentsIntersection(np.append(e1,np.zeros((e1.shape[0],e1.shape[1],1)),axis=2),np.append(e2,np.zeros((e2.shape[0],e2.shape[1],1)),axis=2),return_intersection=True, endpt_inclusive=False,eps=1e-14)</span>
            <span class="c1">#     if np.any(eIntersections):</span>
            <span class="c1">#         print(&#39;aaaa&#39;)</span>
                    <span class="c1"># raise Exception(&#39;Invalid constraints - the following constraint pairs intersect each other: {}&#39;.format(combinations[eIntersections]))</span>

            <span class="c1">###</span>
            <span class="n">NodeCoords3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">))[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">Triangulate</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">Constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;Triangle&#39;</span><span class="p">)</span>
            <span class="c1"># NodeConn = Triangle(Points,Constraints=NewConstraints)</span>
            <span class="c1">### This is to handle cases where scipy only returns a single triangle, possibly due to the way it handles &#39;collinear&#39; triangles</span>
            <span class="c1"># Not an ideal work around</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">NodeConn</span>
            <span class="c1">###</span>
            <span class="c1"># Get Edges</span>
            <span class="c1"># Edges = converter.solid2edges(Points,NodeConn)</span>
            <span class="c1"># Edges = np.asarray(Edges)</span>

            <span class="c1"># Filter out degenerate triangles</span>
            <span class="c1"># EdgePoints = NodeCoords3d[Edges]</span>
            <span class="c1"># ElemPoints = NodeCoords3d[NodeConn]</span>
            <span class="c1"># A2 = np.linalg.norm(np.cross(ElemPoints[:,1]-ElemPoints[:,0],ElemPoints[:,2]-ElemPoints[:,0]),axis=1)</span>
            <span class="c1"># EdgeLen = np.max(np.linalg.norm(EdgePoints[:,0]-EdgePoints[:,1],axis=1).reshape((int(len(Edges)/3),3)),axis=1)</span>
            <span class="c1"># deviation = A2/EdgeLen</span>
            <span class="c1"># if sum(deviation&gt;tol*10) &gt; 1:</span>
            <span class="c1">#     NodeConn = NodeConn[deviation&gt;tol]</span>

            <span class="n">Edges</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
            <span class="n">UEdges</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">)</span>
            <span class="n">ElemConn</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getElemConnectivity</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">Constraint</span><span class="o">==</span><span class="n">UEdges</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">Constraint</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">UEdges</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="k">for</span> <span class="n">Constraint</span> <span class="ow">in</span> <span class="n">NewConstraints</span><span class="p">]):</span>
                <span class="c1"># All constraints are present</span>
                <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">NodeConn</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">NodeConn</span>
            <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">NewConstraints</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">constraint</span> <span class="o">==</span> <span class="n">UEdges</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">constraint</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">UEdges</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                    <span class="c1"># Constrained edge already exists, no need to do anything</span>
                    <span class="k">continue</span>
                <span class="c1"># For each constraint edge, find intersecting edges</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">NodeCoords3d</span><span class="p">[</span><span class="n">constraint</span><span class="p">],(</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="n">NodeCoords3d</span><span class="p">[</span><span class="n">UEdges</span><span class="p">]</span>

                <span class="n">intersections</span> <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">SegmentsSegmentsIntersection</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">endpt_inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Having endpt_inclusive=True is important here</span>

                <span class="n">Iedges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">intersections</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ww</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Not working sometimes for some reason;fuck</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Iedges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ww</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="n">ww</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">ww</span> <span class="o">==</span> <span class="mi">99</span><span class="p">:</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">Iedges</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">UEdges</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">constraint</span> <span class="ow">or</span> <span class="n">UEdges</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">constraint</span><span class="p">:</span>
                        <span class="c1"># Intersection is at an endpoint, no need to do anything</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">UEdges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">NewConstraints</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">UEdges</span><span class="p">[</span><span class="n">k</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">NewConstraints</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                        <span class="c1"># Edge is a constraint, cant be flipped</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
                        <span class="k">continue</span>
                    <span class="n">intersect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">UEdges</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">UEdges</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersect</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># Boundary edge, skip</span>
                        <span class="k">continue</span>

                    <span class="c1"># [i,j] = EdgeElemConn[k]</span>
                    <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">intersect</span>

                    
                    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ConvexHull_GiftWrapping</span><span class="p">(</span><span class="n">Points</span><span class="p">[</span><span class="n">nodes</span><span class="p">],</span><span class="n">IncludeCollinear</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="c1"># If the 4 nodes of the two triangles connected at the edge are non-convex, put the edge back in the queue</span>
                        <span class="c1"># if len(Iedges) != 1:</span>
                        <span class="n">Iedges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Flip edge</span>
                        <span class="n">Newi</span><span class="p">,</span><span class="n">Newj</span> <span class="o">=</span> <span class="n">FlipEdge</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                        <span class="n">NodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Newi</span><span class="p">;</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Newj</span>
                        <span class="n">NewEdge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">UEdges</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">NewEdge</span><span class="o">==</span><span class="n">UEdges</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">NewEdge</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">UEdges</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                            <span class="c1"># If the new edge is already an edge, it needs to be flipped again</span>
                            <span class="n">Iedges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">UEdges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">NewEdge</span>
                        <span class="n">ElemConn</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getElemConnectivity</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">rays</span><span class="o">.</span><span class="n">SegmentSegmentIntersection</span><span class="p">(</span><span class="n">NodeCoords3d</span><span class="p">[</span><span class="n">constraint</span><span class="p">],</span><span class="n">NodeCoords3d</span><span class="p">[</span><span class="n">NewEdge</span><span class="p">],</span><span class="n">endpt_inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                            <span class="n">Iedges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Iedges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="c1">## This shouldn&#39;t be needed,</span>
                    <span class="n">brk</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="n">NewConstraints</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">C</span> <span class="o">==</span> <span class="n">UEdges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">C</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">UEdges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))):</span>
                            <span class="n">brk</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="n">brk</span><span class="p">:</span> 
                            <span class="k">break</span>
                    

            
            <span class="c1">### Double Checking</span>
            <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">NewConstraints</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">constraint</span> <span class="o">==</span> <span class="n">UEdges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">constraint</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">UEdges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;merp&#39;</span><span class="p">)</span>

            <span class="c1">###</span>
            <span class="c1"># Reinforce delaunay</span>
            <span class="c1"># try:</span>
            <span class="c1">#     NodeConn = DelaunayFlips(Points,NodeConn,Constraints=NewConstraints)</span>
            <span class="c1"># except:</span>
            <span class="c1">#     a = 2</span>
        

        <span class="c1"># #</span>
        <span class="c1"># import plotly.graph_objects as go</span>
        <span class="c1"># fig = go.Figure()</span>
        <span class="c1"># for i in range(len(UEdges)):</span>
        <span class="c1">#     fig.add_trace(go.Scatter(x=NodeCoords[idx[UEdges[i]]][:,0], y=NodeCoords[idx[UEdges[i]]][:,1],text=UEdges[i],line=dict(dash=&#39;dash&#39;)))</span>
        <span class="c1"># for i in range(len(NewConstraints)):</span>
        <span class="c1">#     fig.add_trace(go.Scatter(x=NodeCoords[idx[NewConstraints[i]]][:,0], y=NodeCoords[idx[NewConstraints[i]]][:,1],text=NewConstraints[i]))</span>
        <span class="c1"># fig.show()</span>

    <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">Points</span>
    <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span></div>


<div class="viewcode-block" id="SplitConstraints_2d">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.SplitConstraints_2d">[docs]</a>
<span class="k">def</span> <span class="nf">SplitConstraints_2d</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">Constraints</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
    
    <span class="c1"># import plotly.graph_objects as go</span>
    <span class="c1"># fig = go.Figure()</span>
    <span class="c1"># for i in range(len(Constraints)):</span>
    <span class="c1">#     fig.add_trace(go.Scatter(x=NodeCoords[Constraints[i]][:,0], y=NodeCoords[Constraints[i]][:,1],text=Constraints[i]))</span>
    <span class="c1"># fig.show()</span>

    <span class="c1"># Check for intersections within the constraints</span>
    <span class="n">pbk</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">cbk</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Constraints</span><span class="p">)</span>
    <span class="n">combinations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Constraints</span><span class="p">)),</span><span class="mi">2</span><span class="p">)))</span>
    <span class="n">NodeCoords3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">),</span><span class="mi">1</span><span class="p">)),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">NodeCoords3</span><span class="p">[</span><span class="n">Constraints</span><span class="p">[</span><span class="n">combinations</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]]</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">NodeCoords3</span><span class="p">[</span><span class="n">Constraints</span><span class="p">[</span><span class="n">combinations</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]]</span>
    <span class="n">eIntersections</span><span class="p">,</span><span class="n">eIntersectionPts</span> <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">SegmentsSegmentsIntersection</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">return_intersection</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">endpt_inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
    <span class="n">eIntersectionPts</span> <span class="o">=</span> <span class="n">eIntersectionPts</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">NewConstraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ic</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Constraints</span><span class="p">):</span>
        <span class="c1"># ids of other constraints that intersect with this constraint</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">combo</span> <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">[</span><span class="n">eIntersections</span><span class="p">]</span> <span class="k">if</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">combo</span><span class="p">]))</span>
        <span class="c1"># Check collinear lines - currently rays.SegmentsSegmentsIntersection doesn&#39;t do this properly</span>
        <span class="n">coix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">[</span><span class="o">~</span><span class="n">eIntersections</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">ic</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">combo</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Constraints</span><span class="p">[</span><span class="n">combo</span><span class="p">]])</span>

            <span class="c1"># Check area of triangles formed by 3 of the 4 nodes of the segment to assess collinearity</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Constraints</span><span class="p">[</span><span class="n">combo</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> 
                                    <span class="n">NodeCoords</span><span class="p">[</span><span class="n">Constraints</span><span class="p">[</span><span class="n">combo</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">check1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">segments</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">segments</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">tol</span>
                <span class="n">check2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">segments</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">segments</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">tol</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Constraints</span><span class="p">[</span><span class="n">combo</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> 
                                    <span class="n">NodeCoords</span><span class="p">[</span><span class="n">Constraints</span><span class="p">[</span><span class="n">combo</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">check1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">segments</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">segments</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">segments</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">tol</span>
                <span class="n">check2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">segments</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">segments</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">segments</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">segments</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">tol</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">segments</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span><span class="n">v2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v2</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
                    <span class="c1"># vectors aren&#39;t parallel (cross product of parallel vectors is [0,0,0])</span>
                    <span class="c1"># This is needed in addition to the previous area checks because a perpindicular segment</span>
                    <span class="c1"># in line with the end point of the other segment could also give area ~ 0</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">check1</span> <span class="ow">and</span> <span class="n">check2</span><span class="p">:</span>
                <span class="c1"># For segments AB and CD if the (double) area of the triangles ABC and ABD are both (near) zero, the segments are collinear</span>
                <span class="c1"># segsort = np.lexsort(segments.T) # Lexographic sort of the segments</span>
                <span class="n">segsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">segments</span><span class="o">/</span><span class="n">tol</span><span class="p">)</span><span class="o">*</span><span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> 
                <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">segsort</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">segsort</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="mi">2</span> <span class="ow">in</span> <span class="n">segsort</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">segsort</span><span class="p">[:</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="c1"># if both points if a segment are on the same side of the other, they at most intersect at an endpt</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">segments</span><span class="p">[</span><span class="n">segsort</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span> <span class="c1"># Norm of the difference between interior points</span>
                        <span class="c1"># end point intersection</span>
                        <span class="n">coix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coix</span><span class="p">,[</span><span class="n">segments</span><span class="p">[</span><span class="n">segsort</span><span class="p">[</span><span class="mi">1</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># overlapping segments, get the two interior points</span>
                    <span class="n">coix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coix</span><span class="p">,</span><span class="n">segments</span><span class="p">[</span><span class="n">segsort</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">check1</span><span class="p">:</span>
                <span class="n">segsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">segments</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">segsort</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">coix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coix</span><span class="p">,[</span><span class="n">segments</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">check2</span><span class="p">:</span>
                <span class="n">segsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">segments</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">segsort</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">coix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coix</span><span class="p">,[</span><span class="n">segments</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    
        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span><span class="n">ids</span><span class="o">==</span><span class="n">ic</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">NewConstraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NewConstraints</span><span class="p">,[</span><span class="n">c</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># corresponding intersection points</span>
            <span class="n">ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">eIntersectionPts</span><span class="p">[</span><span class="n">eIntersections</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">combo</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">combinations</span><span class="p">[</span><span class="n">eIntersections</span><span class="p">])</span> <span class="k">if</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">combo</span><span class="p">])</span>
            <span class="n">ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ixs</span><span class="p">,</span><span class="n">coix</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ixsort</span> <span class="o">=</span> <span class="n">ixs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ixs</span><span class="o">/</span><span class="n">tol</span><span class="p">)</span><span class="o">*</span><span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span>

            <span class="n">NewConstraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NewConstraints</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ixsort</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ixsort</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">ixsort</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">Constraints</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NewConstraints</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mi">10</span><span class="o">*</span><span class="n">tol</span><span class="p">)</span>
    <span class="n">Constraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">Constraints</span> <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>

    <span class="c1"># import plotly.graph_objects as go</span>
    <span class="c1"># fig = go.Figure()</span>
    <span class="c1"># for i in range(len(Constraints)):</span>
    <span class="c1">#     fig.add_trace(go.Scatter(x=NodeCoords[Constraints[i]][:,0], y=NodeCoords[Constraints[i]][:,1],text=Constraints[i]))</span>
    <span class="c1"># fig.show()</span>

    <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">Constraints</span></div>


<div class="viewcode-block" id="ConvexHull">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.ConvexHull">[docs]</a>
<span class="k">def</span> <span class="nf">ConvexHull</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">IncludeCollinear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;GiftWrapping&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;GiftWrapping&#39;</span><span class="p">:</span>
        <span class="n">Hull</span> <span class="o">=</span> <span class="n">ConvexHull_GiftWrapping</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">IncludeCollinear</span><span class="o">=</span><span class="n">IncludeCollinear</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid method&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Hull</span></div>


<div class="viewcode-block" id="SciPy">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.SciPy">[docs]</a>
<span class="k">def</span> <span class="nf">SciPy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SciPy _summary_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : _type_</span>
<span class="sd">        _description_</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">out</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">Delaunay</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">qhull_options</span><span class="o">=</span><span class="s1">&#39;Qbb Qc Qz Q12 Qt&#39;</span><span class="p">)</span>
    <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">simplices</span>
    <span class="k">return</span> <span class="n">NodeConn</span></div>


<div class="viewcode-block" id="Triangle">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.Triangle">[docs]</a>
<span class="k">def</span> <span class="nf">Triangle</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">Constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">opts</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Delaunay triangulation using &quot;triangle&quot; is not supported in the current release. SciPy is used instead.&#39;</span><span class="p">)</span>
    <span class="c1"># Uses Triangle by Jonathan Shewchuk</span>
    <span class="k">if</span> <span class="n">Constraints</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">Constraints</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">In</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">In</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">segments</span><span class="o">=</span><span class="n">Constraints</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">SciPy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="c1"># Out = triangle.triangulate(In,&#39;pc&#39;)</span>
        <span class="c1"># NodeConn = Out[&#39;triangles&#39;]</span>
        <span class="c1"># # NodeCoords = Out[&#39;vertices&#39;]</span>
        <span class="c1"># if len(Out[&#39;vertices&#39;]) != len(NodeCoords):</span>
        <span class="c1">#     # If constraints are improperly defined, extra points may be added, but these points most likely already exist</span>
        <span class="c1">#     for v in range(len(NodeCoords),len(Out[&#39;vertices&#39;])):</span>
        <span class="c1">#         # print(v)</span>
        <span class="c1">#         All = np.all(np.abs(Out[&#39;vertices&#39;][v]-NodeCoords)&lt;1e-12,axis=1)</span>
        <span class="c1">#         if np.any(All):</span>
        <span class="c1">#             NodeConn[NodeConn==v] = np.where(All)[0][0]</span>
        <span class="c1">#     if np.any(NodeConn &gt;= len(NodeCoords)):</span>
        <span class="c1">#         a = 2</span>
        <span class="c1">#         NodeCoords = Out[&#39;vertices&#39;]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">SciPy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span></div>


<div class="viewcode-block" id="BowyerWatson3d">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.BowyerWatson3d">[docs]</a>
<span class="k">def</span> <span class="nf">BowyerWatson3d</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">):</span>
    <span class="c1"># Someting isn&#39;t working right</span>
    <span class="n">NodeConn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">TempConn</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Bounding Box</span>
    <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))])</span>
    <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))])</span>
    <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))])</span>
    <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))])</span>
    <span class="n">minz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))])</span>
    <span class="n">maxz</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))])</span>
    
    <span class="c1"># Bounding Tetrahedron (with slight buffer)</span>
    <span class="n">minX</span> <span class="o">=</span> <span class="n">minx</span><span class="o">+</span><span class="n">minx</span><span class="o">/</span><span class="mi">10</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">maxX</span> <span class="o">=</span> <span class="n">maxx</span><span class="o">+</span><span class="n">maxx</span><span class="o">/</span><span class="mi">10</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">minY</span> <span class="o">=</span> <span class="n">miny</span><span class="o">+</span><span class="n">miny</span><span class="o">/</span><span class="mi">10</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">maxY</span> <span class="o">=</span> <span class="n">maxy</span><span class="o">+</span><span class="n">maxy</span><span class="o">/</span><span class="mi">10</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">minZ</span> <span class="o">=</span> <span class="n">minz</span><span class="o">+</span><span class="n">minz</span><span class="o">/</span><span class="mi">10</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">maxZ</span> <span class="o">=</span> <span class="n">maxz</span><span class="o">+</span><span class="n">maxz</span><span class="o">/</span><span class="mi">10</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">tetPts</span> <span class="o">=</span> <span class="p">[[</span><span class="n">minX</span><span class="p">,</span><span class="n">maxY</span><span class="p">,</span><span class="n">minZ</span><span class="p">],</span>
              <span class="p">[</span><span class="n">minX</span><span class="p">,</span><span class="n">minY</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">maxX</span><span class="o">-</span><span class="n">minX</span><span class="p">,</span><span class="n">maxZ</span><span class="o">-</span><span class="n">minZ</span><span class="p">),</span><span class="n">minZ</span><span class="p">],</span>
              <span class="p">[</span><span class="n">maxX</span><span class="o">+</span><span class="nb">max</span><span class="p">(</span><span class="n">maxY</span><span class="o">-</span><span class="n">minY</span><span class="p">,</span><span class="n">maxZ</span><span class="o">-</span><span class="n">minz</span><span class="p">),</span><span class="n">maxY</span><span class="p">,</span><span class="n">minZ</span><span class="p">],</span>
              <span class="p">[</span><span class="n">minX</span><span class="p">,</span><span class="n">maxY</span><span class="p">,</span><span class="n">maxZ</span><span class="o">+</span><span class="nb">max</span><span class="p">(</span><span class="n">maxX</span><span class="o">-</span><span class="n">minX</span><span class="p">,</span><span class="n">maxY</span><span class="o">-</span><span class="n">minY</span><span class="p">)]]</span>
    <span class="n">tetPts</span> <span class="o">=</span> <span class="p">[[</span><span class="n">tetPts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tetPts</span><span class="p">[</span><span class="n">i</span><span class="p">]))]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tetPts</span><span class="p">))]</span>
    <span class="n">tempCoords</span> <span class="o">=</span> <span class="n">NodeCoords</span> <span class="o">+</span> <span class="n">tetPts</span>
    <span class="n">tempIdx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">TempConn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tempIdx</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)):</span>
        <span class="c1"># For Each Node</span>
        <span class="n">badElems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Pt</span> <span class="o">=</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TempConn</span><span class="p">)):</span>
            <span class="c1"># Check all elements</span>
            <span class="n">Nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tempCoords</span><span class="p">)[</span><span class="n">TempConn</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">C</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">TetCircumsphere</span><span class="p">(</span><span class="n">Nodes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dist</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Pt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">:</span>
                <span class="c1"># If new point is inside the circumsphere of an existing element</span>
                <span class="n">badElems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            
        <span class="c1"># Identify the polyhedral hole</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="p">[]</span>        
        <span class="n">badFaces</span> <span class="o">=</span> <span class="n">Converter</span><span class="o">.</span><span class="n">tetGetFaces</span><span class="p">(</span><span class="n">tempCoords</span><span class="p">,[</span><span class="n">TempConn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">badElems</span><span class="p">])</span>
        <span class="n">sortedBadFaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">badFaces</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">badFaces</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">badElems</span><span class="p">)):</span>
            <span class="n">theseFaces</span> <span class="o">=</span> <span class="n">Converter</span><span class="o">.</span><span class="n">tetGetFaces</span><span class="p">(</span><span class="n">tempCoords</span><span class="p">,[</span><span class="n">TempConn</span><span class="p">[</span><span class="n">badElems</span><span class="p">[</span><span class="n">j</span><span class="p">]]])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">theseFaces</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">theseFaces</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">==</span> <span class="n">sortedBadFaces</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">poly</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theseFaces</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    
        <span class="c1"># Remove old elements  </span>
        <span class="n">sortBad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">badElems</span><span class="p">)</span>         
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sortBad</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">TempConn</span><span class="p">[</span><span class="n">sortBad</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
        
        <span class="c1"># Retriangulate the polyhedral hole          </span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">:</span>            
            <span class="n">newTet</span> <span class="o">=</span> <span class="n">face</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># create a new tet between the face and the new node</span>
            <span class="n">TempConn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newTet</span><span class="p">)</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TempConn</span><span class="p">))</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">TempConn</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plotTet</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">tempCoords</span><span class="p">,</span><span class="n">elem</span><span class="p">)</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>        
        <span class="n">sciCoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">tempCoords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tempCoords</span><span class="p">))</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">TempConn</span><span class="p">)]</span>
        <span class="n">sciConn</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">Delaunay</span><span class="p">(</span><span class="n">sciCoords</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sciConn</span><span class="o">.</span><span class="n">simplices</span><span class="p">))</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">sciConn</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plotTet</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">sciCoords</span><span class="p">,</span><span class="n">elem</span><span class="p">)</span>       
        <span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

    <span class="n">NodeConn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TempConn</span><span class="p">)):</span>
        <span class="n">add</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tempIdx</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">TempConn</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">add</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">add</span><span class="p">:</span>
            <span class="n">NodeConn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TempConn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">NodeConn</span></div>

    
<div class="viewcode-block" id="ConvexHull_GiftWrapping">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.ConvexHull_GiftWrapping">[docs]</a>
<span class="k">def</span> <span class="nf">ConvexHull_GiftWrapping</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">IncludeCollinear</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ConvexHull_GiftWrapping Gift wrapping algorithm for computing the convex hull of a set of 2D points.</span>

<span class="sd">    Jarvis, R. A. (1973). On the identification of the convex hull of a finite set of points in the plane. Information Processing Letters, 2(1), 1821. https://doi.org/10.1016/0020-0190(73)90020-3</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list or np.ndarray</span>
<span class="sd">        List of 2D point coordinates</span>
<span class="sd">     Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Hull : list</span>
<span class="sd">        List of point indices that form the convex hull, in counterclockwise order</span>
<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;At least three points are required.&#39;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;The gift wrapping algorithm is only valid for points on a plane, coordinates must be two dimensional.&#39;</span>
    <span class="n">Points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">sortidx</span> <span class="o">=</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Points</span> <span class="o">=</span> <span class="n">Points</span><span class="p">[</span><span class="n">sortidx</span><span class="p">,:]</span> <span class="c1"># sorting from max y to min y (TODO:for some reason if the first point comes before the second point, there are problems)</span>
    
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">))</span>
    <span class="n">firstP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Minimum y coordinate point</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">firstP</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># if there are multiple points at the same min y coordinate, choose the one with the max x coordinate</span>
        <span class="n">firstP</span> <span class="o">=</span> <span class="n">firstP</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Points</span><span class="p">[</span><span class="n">firstP</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Points</span><span class="p">[</span><span class="n">firstP</span><span class="p">,</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">nextP</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">Hull</span> <span class="o">=</span> <span class="p">[</span><span class="n">firstP</span><span class="p">]</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">))</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">firstP</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">thetaTotal</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">Points</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[</span><span class="n">Hull</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">],</span><span class="n">Points</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[</span><span class="n">Hull</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">])</span> 
    <span class="n">mask</span><span class="p">[</span><span class="n">firstP</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">while</span> <span class="n">nextP</span> <span class="o">!=</span> <span class="n">firstP</span><span class="p">:</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">theta</span> <span class="o">==</span> <span class="n">theta</span><span class="o">.</span><span class="n">min</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="c1"># Check for collinear vertices on the boundary</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Points</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">mask</span><span class="p">][</span><span class="n">idxs</span><span class="p">]]</span> <span class="o">-</span> <span class="n">Points</span><span class="p">[</span><span class="n">Hull</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">IncludeCollinear</span><span class="p">:</span>
                <span class="c1"># includes closest point first</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[</span><span class="n">dists</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Skip to furthest point</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[</span><span class="n">dists</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">thetaTotal</span> <span class="o">+=</span> <span class="n">theta</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">nextP</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">mask</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">nextP</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">Hull</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextP</span><span class="p">)</span>
        <span class="c1"># Polar coordinate angles of all (non-hull) points, centered at the most recently added hull point</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">Points</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[</span><span class="n">Hull</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">],</span><span class="n">Points</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[</span><span class="n">Hull</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">thetaTotal</span>
        <span class="n">theta</span><span class="p">[</span><span class="n">theta</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="n">Hull</span> <span class="o">=</span> <span class="n">sortidx</span><span class="p">[</span><span class="n">Hull</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">Hull</span></div>


<div class="viewcode-block" id="ConvexHullFanTriangulation">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.ConvexHullFanTriangulation">[docs]</a>
<span class="k">def</span> <span class="nf">ConvexHullFanTriangulation</span><span class="p">(</span><span class="n">Hull</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ConvexHullFanTriangulation Generate a fan triangulation of a convex hull</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Hull : list or np.ndarray</span>
<span class="sd">        List of point indices that form the convex hull. Points should be ordered in </span>
<span class="sd">        either clockwise or counterclockwise order. The ordering of the triangles will</span>
<span class="sd">        follow the ordering of the hull.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeConn np.ndarray</span>
<span class="sd">        Nodal connectivity of the triangulated hull.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">Hull</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span>
    <span class="n">Hull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Hull</span><span class="p">)</span>
    <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Hull</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">Hull</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                    <span class="n">Hull</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Hull</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)],</span>
                    <span class="n">Hull</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Hull</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span>
                <span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">NodeConn</span></div>

    
<div class="viewcode-block" id="TriangleSplittingTriangulation">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.TriangleSplittingTriangulation">[docs]</a>
<span class="k">def</span> <span class="nf">TriangleSplittingTriangulation</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">Hull</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_Hull</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;At least three points are required.&#39;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Only supported for points on a plane, coordinates must be two dimensional.&#39;</span>

    <span class="n">Points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Hull</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">Hull</span> <span class="o">=</span> <span class="n">ConvexHull_GiftWrapping</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">ConvexHullFanTriangulation</span><span class="p">(</span><span class="n">Hull</span><span class="p">)</span>

    <span class="n">interior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)),</span><span class="n">Hull</span><span class="p">,</span><span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">interior</span><span class="p">:</span>
        <span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">BaryTris</span><span class="p">(</span><span class="n">Points</span><span class="p">[</span><span class="n">NodeConn</span><span class="p">],</span><span class="n">Points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="c1"># currently not using special treatment for nodes on boundaries</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">TriId</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inside</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">TriId</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">TriId</span> <span class="o">=</span> <span class="n">TriId</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Elem</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">TriId</span><span class="p">])</span>
        <span class="n">NodeConn</span><span class="p">[</span><span class="n">TriId</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">]</span>
        <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,[[</span><span class="n">Elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Elem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">i</span><span class="p">],[</span><span class="n">Elem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">Elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_Hull</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">Hull</span>
    <span class="k">return</span> <span class="n">NodeConn</span></div>

        
<div class="viewcode-block" id="DelaunayFlips_">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.DelaunayFlips_">[docs]</a>
<span class="k">def</span> <span class="nf">DelaunayFlips_</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">Constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DelaunayFlips _summary_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    NodeConn : _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    Constrained : list, optional</span>
<span class="sd">        list of , by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">NewConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>

    <span class="c1"># Get Edges</span>
    <span class="n">Edges</span><span class="p">,</span> <span class="n">EdgeConn</span><span class="p">,</span> <span class="n">EdgeElem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">return_EdgeConn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">Edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Edges</span><span class="p">);</span> <span class="n">EdgeConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">)</span>
    <span class="n">UEdges</span><span class="p">,</span> <span class="n">UIdx</span><span class="p">,</span> <span class="n">UInv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">)</span>
    <span class="n">UEdgeElem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeElem</span><span class="p">)[</span><span class="n">UIdx</span><span class="p">]</span>
    <span class="n">UEdgeConn</span> <span class="o">=</span> <span class="n">UInv</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>
    <span class="n">EECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">UEdgeElem</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">EdgeElemConn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
    <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Get Constraints</span>
    <span class="k">if</span> <span class="n">Constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Constrained</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">Constraints</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">UEdges</span><span class="o">==</span><span class="n">constraint</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">UEdges</span><span class="o">==</span><span class="n">constraint</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">where</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Constrained</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">where</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: Not sure why this happens</span>
                <span class="k">continue</span>

    <span class="c1"># Get Opposite Angles</span>
    <span class="n">EdgeVectors</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">Edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">Edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">EdgeLengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">EdgeVectors</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ElemVectors</span> <span class="o">=</span> <span class="n">EdgeVectors</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>
    <span class="n">ElemLengths</span> <span class="o">=</span> <span class="n">EdgeLengths</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">OppositeAngles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ElemLengths</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">EdgeOppositeAngles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">OppositeAngles</span>
    <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">EdgeElemConn</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">Constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">Constrained</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Set of non-Delaunay triangles (i.e. ones that have at least one edge where the sum of the opposite angles is greater than pi)</span>
    <span class="n">NonDelaunay</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">EdgeOppositeAngles</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">NonDelaunay</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        
        <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">NonDelaunay</span><span class="p">:</span>
            <span class="n">NonDelaunay</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">NonDelaunay</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># elem = random.choice(NonDelaunay)#.pop()</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">NonDelaunay</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">flippable</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">angles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">UEdgeConn</span><span class="p">[</span><span class="n">elem</span><span class="p">]:</span>
            <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ConvexHull_GiftWrapping</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">[</span><span class="n">nodes</span><span class="p">],</span><span class="n">IncludeCollinear</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                <span class="n">flippable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flippable</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flippable</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">angles</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># k = random.choice(flippable)</span>
            <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">Newi</span><span class="p">,</span><span class="n">Newj</span> <span class="o">=</span> <span class="n">FlipEdge</span><span class="p">(</span><span class="n">NewConn</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        <span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Newi</span><span class="p">;</span> <span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Newj</span><span class="p">;</span> 

        <span class="c1"># Update EdgeConn</span>
        <span class="n">OldEdges</span> <span class="o">=</span> <span class="n">Edges</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">Edges</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="n">Edges</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]]]</span>

        <span class="c1">###</span>
        <span class="n">UEdges</span><span class="p">,</span> <span class="n">UIdx</span><span class="p">,</span> <span class="n">UInv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">)</span> <span class="o">!=</span> <span class="n">L</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;merp&#39;</span><span class="p">)</span>
            <span class="n">Edges</span> <span class="o">=</span> <span class="n">OldEdges</span>
            <span class="k">continue</span>
        <span class="n">UEdgeElem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeElem</span><span class="p">)[</span><span class="n">UIdx</span><span class="p">]</span>
        <span class="n">UEdgeConn</span> <span class="o">=</span> <span class="n">UInv</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>
        <span class="n">EECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">UEdgeElem</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">EdgeElemConn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">###</span>

        <span class="n">v11</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">v12</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">v13</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">v21</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">v22</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">v23</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
        
        <span class="n">OppositeAngles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v12</span><span class="o">*-</span><span class="n">v13</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v12</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v13</span><span class="p">))),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v13</span><span class="o">*-</span><span class="n">v11</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v13</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v11</span><span class="p">))),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v11</span><span class="o">*-</span><span class="n">v12</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v11</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v12</span><span class="p">)))</span>
            <span class="p">]</span>
        <span class="n">OppositeAngles</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v22</span><span class="o">*-</span><span class="n">v23</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v22</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v23</span><span class="p">))),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v23</span><span class="o">*-</span><span class="n">v21</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v23</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v21</span><span class="p">))),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v21</span><span class="o">*-</span><span class="n">v22</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v21</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v22</span><span class="p">)))</span>
            <span class="p">]</span>
        <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">OppositeAngles</span>
        <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">EdgeElemConn</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">Constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">Constrained</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Prevents flipping of constrained edges</span>
        <span class="n">NonDelaunay</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">EdgeOppositeAngles</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">NewConn</span></div>


<div class="viewcode-block" id="DelaunayFlips">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.DelaunayFlips">[docs]</a>
<span class="k">def</span> <span class="nf">DelaunayFlips</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">Constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DelaunayFlips _summary_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    NodeConn : _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    Constrained : list, optional</span>
<span class="sd">        list of , by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">NewConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>

    <span class="c1"># Get Edges</span>
    <span class="n">Edges</span><span class="p">,</span> <span class="n">EdgeConn</span><span class="p">,</span> <span class="n">EdgeElem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">return_EdgeConn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">Edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Edges</span><span class="p">);</span> <span class="n">EdgeConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">)</span>
    <span class="n">UEdges</span><span class="p">,</span> <span class="n">UIdx</span><span class="p">,</span> <span class="n">UInv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">)</span>
    <span class="n">UEdgeElem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeElem</span><span class="p">)[</span><span class="n">UIdx</span><span class="p">]</span>
    <span class="n">UEdgeConn</span> <span class="o">=</span> <span class="n">UInv</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>
    <span class="n">EECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">UEdgeElem</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">EdgeElemConn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
    <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Get Constraints</span>
    <span class="k">if</span> <span class="n">Constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Constrained</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">Constraints</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">UEdges</span><span class="o">==</span><span class="n">constraint</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">UEdges</span><span class="o">==</span><span class="n">constraint</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">where</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Constrained</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">where</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: Not sure why this happens</span>
                <span class="k">continue</span>

    <span class="c1"># Get Opposite Angles</span>
    <span class="n">EdgeVectors</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">Edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">Edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">EdgeLengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">EdgeVectors</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ElemVectors</span> <span class="o">=</span> <span class="n">EdgeVectors</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>
    <span class="n">ElemLengths</span> <span class="o">=</span> <span class="n">EdgeLengths</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">OppositeAngles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ElemLengths</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">EdgeOppositeAngles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">OppositeAngles</span>
    <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">EdgeElemConn</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">Constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">Constrained</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Set of non-Delaunay triangles (i.e. ones that have at least one edge where the sum of the opposite angles is greater than pi)</span>
    <span class="n">NonDelaunay</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">EdgeOppositeAngles</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">NonDelaunay</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        
        <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">iter</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;morp&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">NonDelaunay</span><span class="p">:</span>
            <span class="n">NonDelaunay</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">NonDelaunay</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># elem = random.choice(NonDelaunay)#.pop()</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">NonDelaunay</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">flippable</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">angles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">UEdgeConn</span><span class="p">[</span><span class="n">elem</span><span class="p">]:</span>
            <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ConvexHull_GiftWrapping</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">[</span><span class="n">nodes</span><span class="p">],</span><span class="n">IncludeCollinear</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                <span class="n">flippable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flippable</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flippable</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">angles</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">Newi</span><span class="p">,</span><span class="n">Newj</span> <span class="o">=</span> <span class="n">FlipEdge</span><span class="p">(</span><span class="n">NewConn</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        <span class="n">NewEdge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">Newi</span><span class="p">,</span><span class="n">Newj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">NewEdge</span><span class="o">==</span><span class="n">UEdges</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">NewEdge</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">UEdges</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
            <span class="c1"># Invalid flip - edge already exists</span>
            <span class="k">continue</span>
        <span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Newi</span><span class="p">;</span> <span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Newj</span><span class="p">;</span> 

        <span class="c1"># Update EdgeConn</span>
        <span class="n">Edges</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="n">Edges</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]]]</span>

        <span class="c1">###</span>
        <span class="n">UEdges</span><span class="p">,</span> <span class="n">UIdx</span><span class="p">,</span> <span class="n">UInv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">)</span> <span class="o">!=</span> <span class="n">L</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;merp&#39;</span><span class="p">)</span>
        <span class="n">UEdgeElem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeElem</span><span class="p">)[</span><span class="n">UIdx</span><span class="p">]</span>
        <span class="n">UEdgeConn</span> <span class="o">=</span> <span class="n">UInv</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>
        <span class="n">EECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">UEdgeElem</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">EdgeElemConn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">###</span>

        <span class="n">v11</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">v12</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">v13</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">v21</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">v22</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">v23</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
        
        <span class="n">OppositeAngles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v12</span><span class="o">*-</span><span class="n">v13</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v12</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v13</span><span class="p">))),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v13</span><span class="o">*-</span><span class="n">v11</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v13</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v11</span><span class="p">))),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v11</span><span class="o">*-</span><span class="n">v12</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v11</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v12</span><span class="p">)))</span>
            <span class="p">]</span>
        <span class="n">OppositeAngles</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v22</span><span class="o">*-</span><span class="n">v23</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v22</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v23</span><span class="p">))),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v23</span><span class="o">*-</span><span class="n">v21</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v23</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v21</span><span class="p">))),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v21</span><span class="o">*-</span><span class="n">v22</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v21</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v22</span><span class="p">)))</span>
            <span class="p">]</span>
        <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">OppositeAngles</span>
        <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">EdgeElemConn</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">Constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">Constrained</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Prevents flipping of constrained edges</span>
        <span class="n">NonDelaunay</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">EdgeOppositeAngles</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">NewConn</span></div>

    
<div class="viewcode-block" id="plotTet">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.plotTet">[docs]</a>
<span class="k">def</span> <span class="nf">plotTet</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">elem</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span>
         <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span>
         <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span>
         <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span>
         <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">2</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">2</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">2</span><span class="p">],</span>
         <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="mi">2</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">2</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">2</span><span class="p">],</span>
         <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">2</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="mi">2</span><span class="p">]]</span>
         
    <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fig</span></div>

   
<span class="c1">## Utils ##</span>
<div class="viewcode-block" id="dist">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.dist">[docs]</a>
<span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span><span class="n">pt2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">pt2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="TetCircumsphere">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.TetCircumsphere">[docs]</a>
<span class="k">def</span> <span class="nf">TetCircumsphere</span><span class="p">(</span><span class="n">Nodes</span><span class="p">):</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
         <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
         <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">Nodes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]))]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Nodes</span><span class="p">))]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
             <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
             <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="n">B</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span>
                        <span class="p">])</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    
    
    <span class="n">a1</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>    
    
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                              <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">Nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
                                  <span class="p">)))</span><span class="o">/</span><span class="mi">6</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">a1</span><span class="o">*</span><span class="n">a2</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">b2</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">c2</span><span class="p">)</span> <span class="o">*</span>
                <span class="p">(</span><span class="n">a1</span><span class="o">*</span><span class="n">a2</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">b2</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">c2</span><span class="p">)</span> <span class="o">*</span>
                <span class="p">(</span><span class="n">a1</span><span class="o">*</span><span class="n">a2</span> <span class="o">-</span> <span class="n">b1</span><span class="o">*</span><span class="n">b2</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">c2</span><span class="p">)</span> <span class="o">*</span>
                <span class="p">(</span><span class="o">-</span><span class="n">a1</span><span class="o">*</span><span class="n">a2</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">b2</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">c2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">24</span><span class="o">*</span><span class="n">V</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span></div>


<div class="viewcode-block" id="FlipEdge">
<a class="viewcode-back" href="../../Mesh.html#Mesh.delaunay.FlipEdge">[docs]</a>
<span class="k">def</span> <span class="nf">FlipEdge</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
    <span class="n">Si</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">Sj</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">shared</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Si</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">Sj</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Elements </span><span class="si">{:d}</span><span class="s1"> &amp; </span><span class="si">{:d}</span><span class="s1"> are not properly connected for an edge flip.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
    <span class="n">Losti</span> <span class="o">=</span> <span class="n">Sj</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">Si</span><span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">Lostj</span> <span class="o">=</span> <span class="n">Si</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">Sj</span><span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">NewEdge</span> <span class="o">=</span> <span class="p">[</span><span class="n">Losti</span><span class="p">,</span><span class="n">Lostj</span><span class="p">]</span>
    <span class="n">Newi</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">shared</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="n">Losti</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">Newj</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">shared</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">Lostj</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">Newi</span><span class="p">,</span><span class="n">Newj</span></div>

    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Timothy O. Josephson.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>