<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mesh.utils &mdash; Mesh 0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=10f1778b"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Mesh
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Mesh</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">Mesh.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for Mesh.utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Wed Sep 29 18:31:03 2021</span>

<span class="sd">@author: toj</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">converter</span><span class="p">,</span> <span class="n">rays</span><span class="p">,</span> <span class="n">octree</span><span class="p">,</span> <span class="n">improvement</span><span class="p">,</span> <span class="n">quality</span>

<div class="viewcode-block" id="getNodeNeighbors">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.getNodeNeighbors">[docs]</a>
<span class="k">def</span> <span class="nf">getNodeNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">ElemType</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    getNodeNeighbors Gives the connected nodes for each node in the mesh</span>
<span class="sd">    TODO: This should probably split into getNodeNeighbors and getElemConn -  the only shared</span>
<span class="sd">    operation is solid2edges (edges could be an optional input argument to each)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal connectivity list.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeNeighbors : list</span>
<span class="sd">        List of neighboring nodes for each node in NodeCoords.</span>
<span class="sd">    ElemConn : list</span>
<span class="sd">        List of elements connected to each node for each node in NodeCoords.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># NodeNeighbors = [set() for i in range(len(NodeCoords))]    # Neighboring nodes for each vertex</span>
    <span class="c1"># ElemConn = [set() for i in range(len(NodeCoords))]         # Connected elements for each vertex </span>
    <span class="c1"># for i in range(len(NodeConn)):</span>
    <span class="c1">#     edges = converter.solid2edges(NodeCoords, [NodeConn[i]], ElemType=ElemType)</span>
    <span class="c1">#     for edge in edges:</span>
    <span class="c1">#         for j in edge:</span>
    <span class="c1">#             NodeNeighbors[j].add(edge[edge.index(j)-1])</span>
    <span class="c1">#             ElemConn[j].add(i)</span>
    <span class="c1">#### </span>
    <span class="n">Edges</span><span class="p">,</span><span class="n">EdgeElem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ElemType</span><span class="o">=</span><span class="n">ElemType</span><span class="p">,</span> <span class="n">ReturnType</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="c1"># NodeNeighbors = [set() for i in range(len(NodeCoords))] </span>
    <span class="c1"># ElemConn = [set() for i in range(len(NodeCoords))]         # Connected elements for each vertex </span>
    <span class="c1"># for i in range(len(Edges)):</span>
    <span class="c1">#     NodeNeighbors[Edges[i][0]].add(Edges[i][1])</span>
    <span class="c1">#     NodeNeighbors[Edges[i][1]].add(Edges[i][0])</span>
    <span class="c1">#     ElemConn[Edges[i][0]].add(EdgeElem[i])</span>
    <span class="c1">#     ElemConn[Edges[i][1]].add(EdgeElem[i])</span>
    <span class="c1"># NodeNeighbors = [list(s) for s in NodeNeighbors]  </span>
    <span class="c1"># ElemConn = [list(s) for s in ElemConn] </span>
    <span class="c1">####</span>
    
    <span class="n">UEdges</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">inv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">NotInMesh</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">UEdges</span><span class="p">))</span>
    <span class="n">Neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">UEdges</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">NotInMesh</span><span class="p">)))</span>
    <span class="n">Idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">UEdges</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span><span class="nb">list</span><span class="p">(</span><span class="n">NotInMesh</span><span class="p">))</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">Idx</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

    <span class="n">key_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">z</span> <span class="k">for</span> <span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">z</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Idx</span><span class="p">[</span><span class="n">arg</span><span class="p">],</span><span class="n">Neighbors</span><span class="p">[</span><span class="n">arg</span><span class="p">]),</span> <span class="n">key_func</span><span class="p">)]</span>
    

    <span class="k">return</span> <span class="n">NodeNeighbors</span><span class="c1">#,ElemConn               </span></div>


<div class="viewcode-block" id="getElemConnectivity">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.getElemConnectivity">[docs]</a>
<span class="k">def</span> <span class="nf">getElemConnectivity</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">ElemType</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
    <span class="n">Edges</span><span class="p">,</span><span class="n">EdgeElem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ElemType</span><span class="o">=</span><span class="n">ElemType</span><span class="p">,</span> <span class="n">ReturnType</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))]</span> 
    <span class="n">ElemConn</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))]</span>         <span class="c1"># Connected elements for each vertex </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Edges</span><span class="p">)):</span>
        <span class="n">ElemConn</span><span class="p">[</span><span class="n">Edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">EdgeElem</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ElemConn</span><span class="p">[</span><span class="n">Edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">EdgeElem</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ElemConn</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ElemConn</span><span class="p">]</span> 
    <span class="k">return</span> <span class="n">ElemConn</span></div>


<div class="viewcode-block" id="getNodeNeighborhood">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.getNodeNeighborhood">[docs]</a>
<span class="k">def</span> <span class="nf">getNodeNeighborhood</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">nRings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    getNodeNeighborhood Gives the connected nodes in an n ring neighborhood </span>
<span class="sd">    for each node in the mesh</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    nRings : int</span>
<span class="sd">        Number of rings to include.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeNeighborhoods : list</span>
<span class="sd">        List of neighboring nodes in an n ring neighborhood around each node in </span>
<span class="sd">        NodeCoords.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">NodeNeighborhoods</span> <span class="o">=</span> <span class="p">[[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">))]</span>
    <span class="k">if</span> <span class="n">nRings</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeNeighborhoods</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRings</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># For each ring, loop through and add the neighbors of the nodes in the neighborhood to the neighborhood</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighborhoods</span><span class="p">)):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">])):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">):</span>
                            <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">NodeNeighborhoods</span></div>

            
<div class="viewcode-block" id="getNodeNeighborhoodByRadius">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.getNodeNeighborhoodByRadius">[docs]</a>
<span class="k">def</span> <span class="nf">getNodeNeighborhoodByRadius</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">Radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    getNodeNeighborhoodByRadius Gives the connected nodes in a neighborhood </span>
<span class="sd">    with a specified radius for each node in the mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    nRings : int</span>
<span class="sd">        Number of rings to include.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeNeighborhoods : list</span>
<span class="sd">        List of neighboring nodes in an neighborhood around each node in </span>
<span class="sd">        NodeCoords with the neighborhoods specified by a radius.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">NodeNeighborhoods</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighborhoods</span><span class="p">)):</span>
        <span class="n">thisNode</span> <span class="o">=</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                            <span class="p">(</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                                <span class="p">(</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">Radius</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">thinking</span><span class="p">:</span>
            <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">])):</span>                    
                    <span class="k">if</span> <span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">):</span>
                        <span class="n">otherNode</span> <span class="o">=</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">otherNode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">otherNode</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">otherNode</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">Radius</span><span class="p">:</span>
                            <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">NodeNeighborhoods</span>   </div>


<div class="viewcode-block" id="getElemNeighbors">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.getElemNeighbors">[docs]</a>
<span class="k">def</span> <span class="nf">getElemNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">,</span><span class="n">ElemConn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    getElemNeighbors Get list of neighboring elements for each element in the mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        List of nodal connectivities.</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        Neighbor mode, will determine what type of connectivity constitutes an element</span>
<span class="sd">        neighbor, by default &#39;face&#39;.</span>
<span class="sd">        &#39;node&#39; : Any elements that share at least one node are considered neighbors. TODO: Not currently implemeneted.</span>
<span class="sd">        &#39;edge&#39; : Any elements that share an edge are considered neighbors.</span>
<span class="sd">        &#39;face&#39; : Any elements that share a face are considered neighbors. NOTE that in surface meshes, no elements share faces.</span>
<span class="sd">    ElemConn : list, optional</span>
<span class="sd">        Node-Element connectivity of the mesh as obtained by getNodeNeighbors.</span>
<span class="sd">        If supplied, won&#39;t require an additional call to getNodeNeighbors.</span>
<span class="sd">        Only relevant if mode = &#39;node&#39;, by default None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ElemNeighbors : list</span>
<span class="sd">        List of element neighbors. For each element, there is a list of the</span>
<span class="sd">        indices of the neighboring elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get Element neighbors </span>
    <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">))]</span>
    <span class="c1"># if mode == &#39;node&#39;:</span>
        <span class="c1"># SetConn = [set(elem) for elem in NodeConn]</span>
        <span class="c1"># for i,elem in enumerate(SetConn):</span>
        <span class="c1">#     ElemNeighbors[i] = [j for j,s in enumerate(SetConn) if len(elem.intersection(s)) == 2]</span>
        
        <span class="c1"># if not ElemConn: _,ElemConn = getNodeNeighbors(NodeCoords,NodeConn)</span>
        <span class="c1"># SetElemConn = [set(E) for E in ElemConn]</span>

        <span class="c1"># for i,e in enumerate(NodeConn):</span>
        <span class="c1">#     ElemNeighbors[i] = </span>
    <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;node&#39;</span><span class="p">:</span>
        <span class="n">ElemConn</span> <span class="o">=</span> <span class="n">getElemConnectivity</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">]</span> 
    <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;edge&#39;</span><span class="p">:</span>
        
        <span class="n">Edges</span><span class="p">,</span><span class="n">EdgeConn</span><span class="p">,</span><span class="n">EdgeElem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_EdgeConn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ReturnType</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="n">UEdges</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">inv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">UEdgeConn</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">)]</span>
        <span class="n">UEdgeElem</span> <span class="o">=</span> <span class="n">EdgeElem</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">EdgeElemConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">)))</span> <span class="c1"># Elements attached to each edge</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">EECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">UEdgeElem</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="c1"># EdgeElemConn = EdgeElemConn.astype(int)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="n">ElemNeighbors</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">ElemNeighbors</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">]</span> 

    <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;face&#39;</span><span class="p">:</span>
        <span class="n">faces</span><span class="p">,</span><span class="n">faceconn</span><span class="p">,</span><span class="n">faceelem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2faces</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">return_FaceConn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_FaceElem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Pad Ragged arrays in case of mixed-element meshes</span>
        <span class="n">Rfaces</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
        <span class="n">Rfaceconn</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">faceconn</span><span class="p">)</span>
        <span class="c1"># Get all unique element faces (accounting for flipped versions of faces)</span>
        <span class="n">_</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">Rfaces</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">RFaces</span> <span class="o">=</span> <span class="n">Rfaces</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">FaceElem</span> <span class="o">=</span> <span class="n">faceelem</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">RFaces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">RFaces</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">RFaces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">RFaceConn</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">Rfaceconn</span><span class="p">]</span> <span class="c1"># Faces attached to each element</span>
        <span class="c1"># Face-Element Connectivity</span>
        <span class="n">FaceElemConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">RFaces</span><span class="p">),</span><span class="mi">2</span><span class="p">)))</span>


        <span class="n">FECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">FaceElem</span><span class="p">[</span><span class="n">RFaceConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">RFaceConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">FaceElemConn</span><span class="p">[</span><span class="n">RFaceConn</span><span class="p">,</span><span class="n">FECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">RFaceConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">FaceElemConn</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">FaceElemConn</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">FaceElemConn</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FaceElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span> <span class="k">continue</span>
            <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">FaceElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">FaceElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">FaceElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">FaceElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">]</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid mode. Must be &quot;edge&quot; or &quot;face&quot;.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ElemNeighbors</span></div>


<div class="viewcode-block" id="getConnectedNodes">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.getConnectedNodes">[docs]</a>
<span class="k">def</span> <span class="nf">getConnectedNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">NodeNeighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">BarrierNodes</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    getConnectedNodes Identifies groups of connected nodes. For a fully </span>
<span class="sd">    connected mesh, a single region will be identified</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list of lists</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list of lists</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    NodeNeighbors : list, optional</span>
<span class="sd">        List of neighboring nodes for each node in NodeCoords. The defau lt is </span>
<span class="sd">        None. If no value is provided, it will be computed with getNodeNeighbors</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeRegions : list of sets</span>
<span class="sd">        Each set in the list contains a region of connected nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">NodeRegions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">NodeNeighbors</span><span class="p">:</span> <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">BarrierNodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">BarrierNodes</span> <span class="k">else</span> <span class="n">n</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">)]</span>
    <span class="n">NeighborSets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">]</span>
    <span class="n">AllNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)))</span>
    <span class="n">DetachedNodes</span> <span class="o">=</span> <span class="n">AllNodes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)))</span>
    <span class="n">todo</span> <span class="o">=</span> <span class="n">AllNodes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">DetachedNodes</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">BarrierNodes</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">region</span> <span class="o">=</span> <span class="p">{</span><span class="n">seed</span><span class="p">}</span>
        <span class="n">new</span> <span class="o">=</span> <span class="p">{</span><span class="n">seed</span><span class="p">}</span>
        <span class="n">nOld</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nCurrent</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">nOld</span> <span class="o">!=</span> <span class="n">nCurrent</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">nOld</span> <span class="o">=</span> <span class="n">nCurrent</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">old</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">NeighborSets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">new</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
            <span class="n">region</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="n">nCurrent</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">todo</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">NodeRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">NodeRegions</span>  </div>


<div class="viewcode-block" id="getConnectedElements">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.getConnectedElements">[docs]</a>
<span class="k">def</span> <span class="nf">getConnectedElements</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">ElemNeighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span><span class="n">BarrierElems</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    getConnectedElements Identifies groups of connected nodes. For a fully </span>
<span class="sd">    connected mesh, a single region will be identified</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list of lists</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list of lists</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    ElemNeighbors : list, optional</span>
<span class="sd">        List of neighboring elements for each element in NodeConn. The default is </span>
<span class="sd">        None. If no value is provided, it will be computed with getNodeNeighbors</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        Connectivity method to be used for getElemNeighbors. The default is &#39;edge&#39;.</span>
<span class="sd">    BarrierElems : set, optional</span>
<span class="sd">        Set of barrier elements that the connected region cannot move past. </span>
<span class="sd">        They can be included in a region, but will not connect to their neighbors</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ElemRegions : list of sets</span>
<span class="sd">        Each set in the list contains a region of connected nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># warnings.warn(&#39;getConnectedElements is still under development.&#39;)</span>
    <span class="n">ElemRegions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ElemNeighbors</span><span class="p">:</span> <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">getElemNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">BarrierElems</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">BarrierElems</span> <span class="k">else</span> <span class="n">e</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ElemNeighbors</span><span class="p">)]</span>
    <span class="n">NeighborSets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">]</span>

    <span class="n">todo</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">BarrierElems</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">region</span> <span class="o">=</span> <span class="p">{</span><span class="n">seed</span><span class="p">}</span>
        <span class="n">new</span> <span class="o">=</span> <span class="p">{</span><span class="n">seed</span><span class="p">}</span>
        <span class="n">nOld</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nCurrent</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">nOld</span> <span class="o">!=</span> <span class="n">nCurrent</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">nOld</span> <span class="o">=</span> <span class="n">nCurrent</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">old</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">NeighborSets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">new</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
            <span class="n">region</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="n">nCurrent</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">todo</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">ElemRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        
    
    <span class="k">return</span> <span class="n">ElemRegions</span>  </div>


<div class="viewcode-block" id="SurfElemNeighbors">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.SurfElemNeighbors">[docs]</a>
<span class="k">def</span> <span class="nf">SurfElemNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">):</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Deprecation Warning - Use getElemNeighbors instead&#39;</span><span class="p">)</span>
    <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">))]</span>
    <span class="n">NodeConnList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">NodeConnArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">)</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">NodeConnArray</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="c1"># An element is neighboring another element when two nodes are shared</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">)):</span>        
        <span class="n">bool0</span> <span class="o">=</span> <span class="p">(</span><span class="n">NodeConnArray</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">NodeConnList</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span>
        <span class="n">bool1</span> <span class="o">=</span> <span class="p">(</span><span class="n">NodeConnArray</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">NodeConnList</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span>
        <span class="n">bool2</span> <span class="o">=</span> <span class="p">(</span><span class="n">NodeConnArray</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">NodeConnList</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span>
        
        <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bool0</span><span class="o">+</span><span class="n">bool1</span><span class="o">+</span><span class="n">bool2</span><span class="p">,</span><span class="n">dims</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ElemNeighbors</span></div>


<div class="viewcode-block" id="Centroids">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.Centroids">[docs]</a>
<span class="k">def</span> <span class="nf">Centroids</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Centroids calculate element centroids.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        List of nodal connectivities.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    centroids : list</span>
<span class="sd">        list of element centroids.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Points</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
    <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">centroids</span></div>

    
<div class="viewcode-block" id="CalcFaceNormal">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.CalcFaceNormal">[docs]</a>
<span class="k">def</span> <span class="nf">CalcFaceNormal</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CalcFaceNormal Calculates normal vectors on the faces of a triangular </span>
<span class="sd">    surface mesh. Asumes triangles are in counter-clockwise when viewed from the outside</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    SurfConn : list</span>
<span class="sd">        Nodal connectivity list of a triangular surface mesh.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ElemNormals list</span>
<span class="sd">        List of element surface normals .</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># def func(elem):</span>
    <span class="c1">#     p0 = NodeCoords[elem[0]]</span>
    <span class="c1">#     p1 = NodeCoords[elem[1]]</span>
    <span class="c1">#     p2 = NodeCoords[elem[2]]</span>
        
    <span class="c1">#     U = np.subtract(p1,p0)</span>
    <span class="c1">#     V = np.subtract(p2,p0)</span>
        
    <span class="c1">#     Nx = U[1]*V[2] - U[2]*V[1]</span>
    <span class="c1">#     Ny = U[2]*V[0] - U[0]*V[2]</span>
    <span class="c1">#     Nz = U[0]*V[1] - U[1]*V[0]</span>
    <span class="c1">#     d = np.sqrt(Nx**2+Ny**2+Nz**2)</span>
    <span class="c1">#     return [Nx/d,Ny/d,Nz/d]</span>
    <span class="c1"># ElemNormals = [func(elem) for elem in SurfConn]</span>

    <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,[[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">)]</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:]</span><span class="o">-</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,:]</span><span class="o">-</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Nz</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">ElemNormals</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="n">d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ElemNormals</span></div>


<div class="viewcode-block" id="Face2NodeNormal">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.Face2NodeNormal">[docs]</a>
<span class="k">def</span> <span class="nf">Face2NodeNormal</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">ElemNormals</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;Angle&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Face2NodeNormal Calculate node normal vectors based on the element face normals</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    ElemConn : list</span>
<span class="sd">        List of elements connected to each node.</span>
<span class="sd">    ElemNormals : list</span>
<span class="sd">        List of element normal vectors.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Method used to determine node normals. The default is &#39;Angle&#39;.</span>
<span class="sd">        Angle - performs an angle weighted average of connected element normals</span>
<span class="sd">        Average - performs a simple averaging of connected element normals</span>
<span class="sd">        MostVisible - Determines the most visible normal - Aubry et al. 2007</span>
<span class="sd">        MostVisible_Loop - Non-vectorized version of MostVisible, slower but more readable</span>
<span class="sd">        MostVisible_Iter - Iterative method for determining the most visible normal - Aubry et al. 2007</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeNormals : list</span>
<span class="sd">        Unit normal vectors for each node.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Angle&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">):</span>
        <span class="c1"># Based on: Grit Thürrner &amp; Charles A. Wüthrich (1998)</span>
        <span class="c1"># Perform angle weighted average to compute vertex normals</span>
        <span class="c1"># Calculate the angles to use as weight</span>

        <span class="c1"># Cast ElemConn into a rectangular matrix</span>
        <span class="c1"># Warning: This code is very vectorized - it might be difficult to debug</span>
        <span class="n">NodeSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">NodeSet</span><span class="p">:</span>
            <span class="n">NodeSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">NodeSet</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="n">NodeSet</span><span class="p">]</span>
        <span class="n">Mask0</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">Masknan</span> <span class="o">=</span> <span class="n">Mask0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">Masknan</span><span class="p">[</span><span class="n">Mask0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
        <span class="n">Ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">ElemNormals</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])[</span><span class="n">R</span><span class="p">]</span>
        <span class="c1"># elemlens = [len(e) for e in NodeConn]</span>
        <span class="c1"># RNodeConn = -1*np.ones([len(NodeConn),max(elemlens)],dtype=int)</span>
        <span class="c1"># for i,elem in enumerate(NodeConn): RNodeConn[i,:elemlens[i]] = elem</span>
        <span class="n">RNodeConn</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ArrayConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">RNodeConn</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">RNodeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)])</span>
        <span class="n">IncidentNodes</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArrayCoords</span><span class="p">[</span><span class="n">IncidentNodes</span><span class="p">]</span><span class="o">-</span><span class="n">ArrayCoords</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:])</span>
        <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># For each node and for each incident element on that node, dot product of the two edges of the element that meet at the node</span>
        <span class="n">dots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Mask0</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># For each node and for each incident element on that node, the product of the norms of the two edges of the element that meet at the node</span>
        <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># cos(alpha) = dot(u,v)/(norm(u)*norm(v))</span>
        <span class="n">cosAlpha</span> <span class="o">=</span> <span class="n">dots</span><span class="o">/</span><span class="n">norms</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">)</span><span class="o">*</span><span class="n">Masknan</span>

        <span class="n">sumAlphaN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">alpha</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Ns</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span> <span class="o">=</span> <span class="n">sumAlphaN</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sumAlphaN</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>

    <span class="k">elif</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Average&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Cast ElemConn into a rectangular matrix</span>
        <span class="n">NodeSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="n">NodeSet</span><span class="p">]</span>
        <span class="n">Ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ElemNormals</span><span class="o">+</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])[</span><span class="n">R</span><span class="p">]</span>
        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;MostVisible&#39;</span><span class="p">:</span>
        
        <span class="c1"># Note: this code uses dot(Ni,Nj) as a surrogate for radius; since Ni,Nj are both unit vectors</span>
        <span class="c1"># cos(theta) = dot(Ni,Nj) -&gt; theta = arccos(dot(Ni,Nj)). Since arccos is a monotonically </span>
        <span class="c1"># decreasing function, if dot(Ni,Nj) &lt; dot(Ni,Nk), then rij &gt; rik</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e-8</span>
        <span class="n">NodeSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">NodeSet</span><span class="p">:</span>
            <span class="n">NodeSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">NodeSet</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">ElemNormals</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])[</span><span class="n">R</span><span class="p">]</span>

        <span class="c1"># 2 Point Circles</span>
        <span class="n">scalmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">Combos2</span> <span class="o">=</span> <span class="n">Ns</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">][:,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Ns</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="mi">2</span><span class="p">)))]</span>
        <span class="n">Nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Combos2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Nb</span> <span class="o">=</span> <span class="n">Nb</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nb</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">scal2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Nb</span> <span class="o">*</span> <span class="n">Combos2</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># 3 Point Circles</span>
        <span class="n">Combos3</span> <span class="o">=</span> <span class="n">Ns</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">][:,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Ns</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="mi">3</span><span class="p">)))]</span>
        <span class="n">Ni</span> <span class="o">=</span> <span class="n">Combos3</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">Nj</span> <span class="o">=</span> <span class="n">Combos3</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="n">Nk</span> <span class="o">=</span> <span class="n">Combos3</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">,:]</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">,</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">Nc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">,</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">))</span><span class="o">/</span><span class="n">denom</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">Nk</span>
            <span class="n">Nc</span> <span class="o">=</span> <span class="n">Nc</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nc</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]</span>
            <span class="n">scal3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Nc</span><span class="o">*</span><span class="n">Ni</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">Nc</span><span class="p">[</span><span class="n">scal3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Nc</span><span class="p">[</span><span class="n">scal3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">scal3</span><span class="p">[</span><span class="n">scal3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">scal3</span><span class="p">[</span><span class="n">scal3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">scal23</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">scal2</span><span class="p">,</span><span class="n">scal3</span><span class="p">])</span>
        <span class="n">Nbc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Nb</span><span class="p">,</span><span class="n">Nc</span><span class="p">])</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;lij,ljk-&gt;lik&#39;</span><span class="p">,</span> <span class="n">Nbc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">Ns</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="n">scal23</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">scal23</span><span class="p">[</span><span class="n">check</span><span class="p">]</span> <span class="o">=</span> <span class="n">scalmin</span>

        <span class="c1"># Indices of the smallest radius that contains all points</span>
        <span class="n">Idx</span> <span class="o">=</span> <span class="n">scal23</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">scal23</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="c1"># In case of duplicates, only taking the first one</span>
        <span class="n">newIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Idx</span><span class="p">)</span>
        <span class="n">newIdx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Idx</span><span class="p">)),</span> <span class="n">Idx</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Idx</span><span class="p">)),</span> <span class="n">Idx</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>

        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span> <span class="o">=</span> <span class="n">Nbc</span><span class="p">[</span><span class="n">newIdx</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))]</span>      <span class="c1"># Normal vectors for each vertex</span>
        <span class="n">NodeSet</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NodeSet</span><span class="p">:</span>
                <span class="n">NodeNormals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">]))]</span>
            <span class="n">elemnormals</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ElemNormals</span><span class="p">[</span><span class="n">elem</span><span class="p">])</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">ElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;angle_old&#39;</span><span class="p">:</span>
                <span class="c1"># Based on: Grit Thürrner &amp; Charles A. Wüthrich (1998)</span>
                <span class="c1"># Perform angle weighted average to compute vertex normals</span>
                <span class="c1"># Calculate the angles to use as weights</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>  
                    <span class="c1"># Loop through the neighboring elements for this node</span>
                    <span class="n">n1</span> <span class="o">=</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># Coordinates of this node</span>
                    <span class="n">n2n3</span> <span class="o">=</span> <span class="p">[]</span>           
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]])):</span>  
                         <span class="c1"># Loop through each node in that neighboring element</span>
                        <span class="k">if</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                            <span class="n">n2n3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]][</span><span class="n">k</span><span class="p">]])</span>
                    <span class="n">n2</span> <span class="o">=</span> <span class="n">n2n3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">n3</span> <span class="o">=</span> <span class="n">n2n3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># Using the dot product to calculate the angle of the neighboring element at the current node (Node i)</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">n3</span><span class="p">,</span><span class="n">n1</span><span class="p">)</span>   <span class="c1"># Vector a</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span><span class="n">n1</span><span class="p">)</span>   <span class="c1"># Vector b</span>
                    <span class="n">angles</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">elemnormals</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">))],</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bottom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">NodeNormals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">NodeNormals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span><span class="o">/</span><span class="n">bottom</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;MostVisible_Loop&#39;</span><span class="p">:</span>
                
                <span class="c1"># This is kept for readability; &#39;MostVisible&#39; is a vectorized equivalent that performs significantly faster</span>
                
                <span class="c1"># Note: this code uses dot(Ni,Nj) as a surrogate for radius; since Ni,Nj are both unit vectors</span>
                <span class="c1"># cos(theta) = dot(Ni,Nj) -&gt; theta = arccos(dot(Ni,Nj)). Since arccos is a monotonically </span>
                <span class="c1"># decreasing function, if dot(Ni,Nj) &lt; dot(Ni,Nk), then rij &gt; rik</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e-8</span>
                <span class="n">scalmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elemnormals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># Check the 2 point circles</span>
                    <span class="n">Ni</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elemnormals</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">elemnormals</span><span class="p">)):</span>
                        <span class="n">Nj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elemnormals</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">Nb</span> <span class="o">=</span> <span class="n">Ni</span><span class="o">+</span><span class="n">Nj</span>
                        <span class="n">Nb</span> <span class="o">=</span> <span class="n">Nb</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nb</span><span class="p">)</span>
                        <span class="n">scal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Nb</span><span class="p">,</span><span class="n">Ni</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">scal</span> <span class="o">&lt;</span> <span class="n">scalmin</span><span class="p">:</span>      
                            <span class="k">pass</span>
                        <span class="k">elif</span> <span class="nb">any</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Nl</span><span class="p">,</span><span class="n">Nb</span><span class="p">)</span> <span class="o">-</span> <span class="n">scal</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="k">for</span> <span class="n">Nl</span> <span class="ow">in</span> <span class="n">elemnormals</span><span class="p">):</span>
                            <span class="k">pass</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">C</span> <span class="o">=</span> <span class="n">Nb</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                            <span class="n">scalmin</span> <span class="o">=</span> <span class="n">scal</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elemnormals</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span> 
                    <span class="c1"># Check the 3 point circles</span>
                    <span class="n">Ni</span> <span class="o">=</span> <span class="n">elemnormals</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">elemnormals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">Nj</span> <span class="o">=</span> <span class="n">elemnormals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">elemnormals</span><span class="p">)):</span>
                            <span class="n">Nk</span> <span class="o">=</span> <span class="n">elemnormals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                            <span class="c1"># denom = (Ni[0]-Nj[0])*(Ni[1]-Nk[1]) - (Ni[0]-Nk[0])*(Ni[1]-Nj[1])</span>
                            <span class="c1"># if denom == 0:</span>
                            <span class="c1">#     continue</span>
                            <span class="c1"># Ncx = ((Ni[2]-Nk[2])*(Ni[1]-Nj[1]) - (Ni[2]-Nj[2])*(Ni[1]*Nk[1]))/denom</span>
                            <span class="c1"># Ncy = ((Ni[0]-Nk[0])*(Ni[2]-Nj[2]) - (Ni[0]-Nj[0])*(Ni[2]-Nk[2]))/denom</span>
                            <span class="c1"># Ncz = 1/np.sqrt(1 + Ncx*Ncx + Ncy*Ncy)</span>
                            <span class="c1"># Ncx = Ncx*Ncz</span>
                            <span class="c1"># Ncy = Ncy*Ncz</span>
                            <span class="c1"># Nc = [Ncx, Ncy, Ncz]</span>

                            <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">,</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> 
                            <span class="k">if</span> <span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="n">Nc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">,</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">))</span><span class="o">/</span><span class="n">denom</span> <span class="o">+</span> <span class="n">Nk</span>
                            <span class="n">nNc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nc</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">nNc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="n">Nc</span> <span class="o">=</span> <span class="n">Nc</span><span class="o">/</span><span class="n">nNc</span>
                            

                            <span class="n">scal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Nc</span><span class="p">,</span> <span class="n">Ni</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">scal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">Nc</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Nc</span><span class="p">]</span>
                                <span class="n">scal</span> <span class="o">=</span> <span class="o">-</span><span class="n">scal</span>
                            <span class="c1"># Nb = Ni+Nj</span>
                            <span class="c1"># Nb = Nb/np.linalg.norm(Nb)</span>
                            <span class="c1"># scal = np.dot(Nc,Ni)</span>
                            <span class="k">if</span> <span class="n">scal</span> <span class="o">&lt;</span> <span class="n">scalmin</span><span class="p">:</span>
                                <span class="k">pass</span>
                            <span class="k">elif</span> <span class="nb">any</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Nl</span><span class="p">,</span><span class="n">Nc</span><span class="p">)</span> <span class="o">-</span> <span class="n">scal</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="k">for</span> <span class="n">Nl</span> <span class="ow">in</span> <span class="n">elemnormals</span><span class="p">):</span>
                                <span class="k">pass</span>   
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">C</span> <span class="o">=</span> <span class="n">Nc</span>
                                <span class="n">scalmin</span> <span class="o">=</span> <span class="n">scal</span>
                <span class="n">NodeNormals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span>    
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">C</span><span class="p">)):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;MostVisible_Iter&#39;</span><span class="p">:</span>
                
                <span class="n">conv</span> <span class="o">=</span> <span class="mf">1e-3</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.5</span>
                
                <span class="c1"># Initial weights]</span>
                <span class="n">ws</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">elemnormals</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elemnormals</span><span class="p">))]</span>
                <span class="c1"># Compute initial guess normal</span>
                <span class="n">Sp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">w</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span><span class="n">elemnormals</span><span class="p">)])</span>
                <span class="n">Np</span> <span class="o">=</span> <span class="n">Sp</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Sp</span><span class="p">)</span>
                
                <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">while</span> <span class="n">thinking</span><span class="p">:</span>
                    <span class="n">k</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="n">alphas</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Np</span><span class="p">,</span><span class="n">Ni</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">Ni</span> <span class="ow">in</span> <span class="n">elemnormals</span><span class="p">]</span>
                    <span class="n">Salpha</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">alphas</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">Salpha</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ws</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="o">*</span><span class="n">alpha</span><span class="o">/</span><span class="n">Salpha</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span><span class="n">alpha</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span><span class="n">alphas</span><span class="p">)]</span>
                        <span class="n">Sw</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>
                        <span class="n">ws</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="o">/</span><span class="n">Sw</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">ws</span><span class="p">]</span>
                        <span class="n">Spnew</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">w</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span><span class="n">elemnormals</span><span class="p">)])</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Spnew</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;merp3&#39;</span><span class="p">)</span>
                        <span class="n">Npnew</span> <span class="o">=</span> <span class="n">Spnew</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Spnew</span><span class="p">)</span>
                        
                        <span class="c1"># Relax</span>
                        <span class="n">Nprel</span> <span class="o">=</span> <span class="n">beta</span><span class="o">*</span><span class="n">Npnew</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">Np</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Np</span><span class="o">-</span><span class="n">Nprel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">conv</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                            <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">Np</span> <span class="o">=</span> <span class="n">Nprel</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Np</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">elemnormals</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">merp</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="n">NodeNormals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Np</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">NodeNormals</span></div>


<div class="viewcode-block" id="BaryTri">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.BaryTri">[docs]</a>
<span class="k">def</span> <span class="nf">BaryTri</span><span class="p">(</span><span class="n">Nodes</span><span class="p">,</span> <span class="n">Pt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    BaryTri returns the bary centric coordinates of a point (Pt) relative to </span>
<span class="sd">    a triangle (Nodes)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Nodes : list</span>
<span class="sd">        List of coordinates of the triangle vertices.</span>
<span class="sd">    Pt : list</span>
<span class="sd">        Coordinates of the point.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alpha : float</span>
<span class="sd">        First barycentric coordinate.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Second barycentric coordinate.</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Third barycentric coordinate.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">BA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
    <span class="c1"># CB = np.subtract(C,B)</span>
    <span class="c1"># AC = np.subtract(A,C)</span>
    <span class="n">CA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>    
    <span class="n">BABA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">BA</span><span class="p">,</span> <span class="n">BA</span><span class="p">)</span>
    <span class="n">BACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">BA</span><span class="p">,</span> <span class="n">CA</span><span class="p">)</span>
    <span class="n">CACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">CA</span><span class="p">,</span> <span class="n">CA</span><span class="p">)</span>
    <span class="n">PABA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Pt</span><span class="p">,</span><span class="n">A</span><span class="p">),</span> <span class="n">BA</span><span class="p">)</span>
    <span class="n">PACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Pt</span><span class="p">,</span><span class="n">A</span><span class="p">),</span> <span class="n">CA</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">BABA</span> <span class="o">*</span> <span class="n">CACA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span> <span class="n">BACA</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span><span class="n">CACA</span> <span class="o">*</span> <span class="n">PABA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span> <span class="n">PACA</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">BABA</span> <span class="o">*</span> <span class="n">PACA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span> <span class="n">PABA</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">gamma</span> <span class="o">-</span> <span class="n">beta</span>
    
    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span></div>


<div class="viewcode-block" id="BaryTris">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.BaryTris">[docs]</a>
<span class="k">def</span> <span class="nf">BaryTris</span><span class="p">(</span><span class="n">Tris</span><span class="p">,</span> <span class="n">Pt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    BaryTri returns the bary centric coordinates of a point (Pt) relative to </span>
<span class="sd">    a triangle (Nodes)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Nodes : list</span>
<span class="sd">        List of coordinates of the triangle vertices.</span>
<span class="sd">    Pt : list</span>
<span class="sd">        Coordinates of the point.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alpha : float</span>
<span class="sd">        First barycentric coordinate.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Second barycentric coordinate.</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Third barycentric coordinate.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">Tris</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">Tris</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">Tris</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">BA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
    <span class="c1"># CB = np.subtract(C,B)</span>
    <span class="c1"># AC = np.subtract(A,C)</span>
    <span class="n">CA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>    
    <span class="n">BABA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">BA</span><span class="o">*</span><span class="n">BA</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">BACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">BA</span><span class="o">*</span><span class="n">CA</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">CACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">CA</span><span class="o">*</span><span class="n">CA</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">PABA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Pt</span><span class="p">,</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">BA</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">PACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Pt</span><span class="p">,</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">CA</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">BABA</span> <span class="o">*</span> <span class="n">CACA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span><span class="n">BACA</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span><span class="n">CACA</span> <span class="o">*</span> <span class="n">PABA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span> <span class="n">PACA</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">BABA</span> <span class="o">*</span> <span class="n">PACA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span> <span class="n">PABA</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">gamma</span> <span class="o">-</span> <span class="n">beta</span><span class="p">;</span>    
    
    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span></div>


<div class="viewcode-block" id="BaryTet">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.BaryTet">[docs]</a>
<span class="k">def</span> <span class="nf">BaryTet</span><span class="p">(</span><span class="n">Nodes</span><span class="p">,</span> <span class="n">Pt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    BaryTet returns the bary centric coordinates of a point (Pt) relative to </span>
<span class="sd">    a tetrahedron (Nodes)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Nodes : list</span>
<span class="sd">        List of coordinates of the tetrahedral vertices.</span>
<span class="sd">    Pt : list</span>
<span class="sd">        Coordinates of the point.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alpha : float</span>
<span class="sd">        First barycentric coordinate.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Second barycentric coordinate.</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Third barycentric coordinate.</span>
<span class="sd">    delta : float</span>
<span class="sd">        Fourth barycentric coordinate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    
    <span class="n">T</span> <span class="o">=</span> <span class="p">[[</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
         <span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
         <span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
         <span class="p">]</span>
    
    <span class="p">[</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Pt</span><span class="p">,</span><span class="n">D</span><span class="p">))</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">+</span> <span class="n">gamma</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">delta</span></div>


<div class="viewcode-block" id="Project2Surface">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.Project2Surface">[docs]</a>
<span class="k">def</span> <span class="nf">Project2Surface</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span><span class="n">Normal</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="n">octree</span><span class="o">=</span><span class="s1">&#39;generate&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Project2Surface Projects a node (NodeCoord) along its normal vector (NodeNormal) onto the </span>
<span class="sd">    surface defined by NodeCoord and SurfConn, returns the index of the </span>
<span class="sd">    element (elemID) that contains the projected node and the barycentric </span>
<span class="sd">    coordinates (alpha, beta, gamma) of that projection within that element</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Point : list or np.ndarray</span>
<span class="sd">        Coordinates of the point to be projected on to the surface.</span>
<span class="sd">    Normal : list or np.ndarray</span>
<span class="sd">        Vector along which the point will be projected.</span>
<span class="sd">    NodeCoords : list or np.ndarray</span>
<span class="sd">        Node coordinates list of the mesh that the point is being projected to.</span>
<span class="sd">    SurfConn : list or np.ndarray</span>
<span class="sd">        Nodal connectivity of the surface mesh that the point is being projected to.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance value, if the projection distance is greater than tol, the projection will be exculded, default is np.inf</span>
<span class="sd">        octree : str (or octree.OctreeNode), optional</span>
<span class="sd">        octree options. An octree representation of the surface can significantly</span>
<span class="sd">        improve mapping speeds, by default &#39;generate&#39;.</span>
<span class="sd">        &#39;generate&#39; - Will generate an octree for use in surface mapping.</span>
<span class="sd">        &#39;none&#39; or None - Won&#39;t generate an octree and will use a brute force approach.</span>
<span class="sd">        octree.OctreeNode - Provide a precompute octree structure corresponding to the surface mesh. Should be created by octree.Surf2Octree(NodeCoords,SurfConn)</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    elemID : int</span>
<span class="sd">        Index of the element in SurfConn that the point gets projected onto.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        First barycentric coordinate of the projected point relative to the triangle identified by elemId</span>
<span class="sd">    beta : float</span>
<span class="sd">        Second barycentric coordinate of the projected point relative to the triangle identified by elemId</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Third barycentric coordinate of the projected point relative to the triangle identified by elemId</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">)</span>

    <span class="n">intersections</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">intersectionPts</span> <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">RaySurfIntersection</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="n">Normal</span><span class="p">,</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">,</span> <span class="n">octree</span><span class="o">=</span><span class="n">octree</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">elemID</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="n">elemID</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distances</span><span class="p">)))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">intersectionPts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">elemID</span> <span class="o">=</span> <span class="n">intersections</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">SurfConn</span><span class="p">[</span><span class="n">elemID</span><span class="p">]]</span>
            <span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">BaryTri</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="n">elemID</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">elemID</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span></div>


<div class="viewcode-block" id="Project2Surface2">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.Project2Surface2">[docs]</a>
<span class="k">def</span> <span class="nf">Project2Surface2</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">Normals</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="n">octree</span><span class="o">=</span><span class="s1">&#39;generate&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Project2Surface Projects a node (NodeCoord) along its normal vector (NodeNormal) onto the </span>
<span class="sd">    surface defined by NodeCoord and SurfConn, returns the index of the </span>
<span class="sd">    element (elemID) that contains the projected node and the barycentric </span>
<span class="sd">    coordinates (alpha, beta, gamma) of that projection within that element</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Point : list or np.ndarray</span>
<span class="sd">        Coordinates of the point to be projected on to the surface.</span>
<span class="sd">    Normal : list or np.ndarray</span>
<span class="sd">        Vector along which the point will be projected.</span>
<span class="sd">    NodeCoords : list or np.ndarray</span>
<span class="sd">        Node coordinates list of the mesh that the point is being projected to.</span>
<span class="sd">    SurfConn : list or np.ndarray</span>
<span class="sd">        Nodal connectivity of the surface mesh that the point is being projected to.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance value, if the projection distance is greater than tol, the projection will be exculded, default is np.inf</span>
<span class="sd">        octree : str (or octree.OctreeNode), optional</span>
<span class="sd">        octree options. An octree representation of the surface can significantly</span>
<span class="sd">        improve mapping speeds, by default &#39;generate&#39;.</span>
<span class="sd">        &#39;generate&#39; - Will generate an octree for use in surface mapping.</span>
<span class="sd">        &#39;none&#39; or None - Won&#39;t generate an octree and will use a brute force approach.</span>
<span class="sd">        octree.OctreeNode - Provide a precompute octree structure corresponding to the surface mesh. Should be created by octree.Surf2Octree(NodeCoords,SurfConn)</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    elemID : int</span>
<span class="sd">        Index of the element in SurfConn that the point gets projected onto.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        First barycentric coordinate of the projected point relative to the triangle identified by elemId</span>
<span class="sd">    beta : float</span>
<span class="sd">        Second barycentric coordinate of the projected point relative to the triangle identified by elemId</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Third barycentric coordinate of the projected point relative to the triangle identified by elemId</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">)</span>

    <span class="n">intersections</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">intersectionPts</span> <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">RaysSurfIntersection</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span> <span class="n">Normals</span><span class="p">,</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">,</span> <span class="n">octree</span><span class="o">=</span><span class="n">octree</span><span class="p">)</span>

    <span class="n">argmindist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">]</span>
    <span class="n">mindist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">argmindist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">)])</span>
    
    <span class="n">elemID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">intersections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">argmindist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">)])</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">intersectionPts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">argmindist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">)])</span>

    <span class="n">mappedbool</span> <span class="o">=</span> <span class="p">(</span><span class="n">elemID</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mindist</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span>
    <span class="n">alphas</span><span class="p">,</span> <span class="n">betas</span><span class="p">,</span> <span class="n">gammas</span> <span class="o">=</span> <span class="n">BaryTris</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">SurfConn</span><span class="p">[</span><span class="n">elemID</span><span class="p">[</span><span class="n">mappedbool</span><span class="p">]]],</span> <span class="n">ps</span><span class="p">[</span><span class="n">mappedbool</span><span class="p">,:])</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">))</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">))</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">))</span>

    <span class="n">alpha</span><span class="p">[</span><span class="n">mappedbool</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphas</span>
    <span class="n">beta</span><span class="p">[</span><span class="n">mappedbool</span><span class="p">]</span> <span class="o">=</span> <span class="n">betas</span>
    <span class="n">gamma</span><span class="p">[</span><span class="n">mappedbool</span><span class="p">]</span> <span class="o">=</span> <span class="n">gammas</span>

    <span class="n">MappingMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">elemID</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>


    <span class="c1"># if len(intersections) == 0:</span>
    <span class="c1">#     elemID = alpha = beta = gamma = -1</span>
    <span class="c1"># elif min(np.abs(distances)) &gt; tol:</span>
    <span class="c1">#     elemID = alpha = beta = gamma = -1</span>
    <span class="c1"># else:</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         idx = np.where(np.abs(distances) == min(np.abs(distances)))[0][0]</span>
    <span class="c1">#         p = intersectionPts[idx]</span>
    <span class="c1">#         elemID = intersections[idx]</span>
    <span class="c1">#         pts = NodeCoords[SurfConn[elemID]]</span>
    <span class="c1">#         alpha,beta,gamma = BaryTri(pts,p)</span>
    <span class="c1">#     except:</span>
    <span class="c1">#         print(distances)</span>
    <span class="c1">#         elemID = alpha = beta = gamma = -1</span>

    <span class="k">return</span> <span class="n">MappingMatrix</span></div>


<div class="viewcode-block" id="SurfMapping">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.SurfMapping">[docs]</a>
<span class="k">def</span> <span class="nf">SurfMapping</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">,</span> <span class="n">NodeCoords2</span><span class="p">,</span> <span class="n">SurfConn2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">octree</span><span class="o">=</span><span class="s1">&#39;generate&#39;</span><span class="p">,</span> <span class="n">return_octree</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SurfMapping Generate a mapping matrix from surface 1 (NodeCoords1, SurfConn1) to surface 2 (NodeCoords2, SurfConn2)</span>
<span class="sd">    Each row of the mapping matrix contains an element ID followed by barycentric coordinates alpha, beta, gamma</span>
<span class="sd">    that define the position of the nodes of surface 1 (NodeCoords1) relative to the specified surface element of </span>
<span class="sd">    surface 2 (SurfConn2). An element ID of -1 indicates a failed mapping.</span>
<span class="sd">    NOTE: Only triangular surface meshes are supported.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords1 : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    SurfConn1 : list</span>
<span class="sd">        List of nodal connectivities.</span>
<span class="sd">    NodeCoords2 : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    SurfConn2 : list</span>
<span class="sd">        List of nodal connectivities.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance value, if the projection distance is greater than tol, the projection will be exculded, default is np.inf</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        If true, will print mapping statistics, by default False.</span>
<span class="sd">    octree : str (or octree.OctreeNode), optional</span>
<span class="sd">        octree options. An octree representation of surface 2 can significantly</span>
<span class="sd">        improve mapping speeds, by default &#39;generate&#39;.</span>
<span class="sd">        &#39;generate&#39; - Will generate an octree for use in surface mapping.</span>
<span class="sd">        &#39;none&#39; or None - Won&#39;t generate an octree and will use a brute force approach.</span>
<span class="sd">        octree.OctreeNode - Provide a precompute octree structure corresponding to surface 2. Should be created by octree.Surf2Octree(NodeCoords2,SurfConn2)</span>
<span class="sd">    return_octree : bool, optional</span>
<span class="sd">        If true, will return the generated or provided octree, by default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MappingMatrix : list</span>
<span class="sd">        len(NodeCoords1)x4 matrix of of barycentric coordinates, defining NodeCoords1 in terms</span>
<span class="sd">        of the triangular surface elements of Surface 2.</span>
<span class="sd">    octree : octree.OctreeNode, optional</span>
<span class="sd">        The generated or provided octree structure corresponding to Surface 2.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">NodeCoords1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">NodeCoords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">SurfConn1</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">SurfConn1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfConn1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">SurfConn2</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">SurfConn2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfConn2</span><span class="p">)</span>

    <span class="n">ElemConn1</span> <span class="o">=</span> <span class="n">getElemConnectivity</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">)</span>
    <span class="n">ElemNormals1</span> <span class="o">=</span> <span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">)</span>
    <span class="n">NodeNormals1</span> <span class="o">=</span> <span class="n">Face2NodeNormal</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">,</span> <span class="n">ElemConn1</span><span class="p">,</span> <span class="n">ElemNormals1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>

    <span class="n">Surf1Nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">SurfConn1</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

    
    <span class="k">if</span> <span class="n">octree</span> <span class="o">==</span> <span class="s1">&#39;generate&#39;</span><span class="p">:</span> <span class="n">octree</span> <span class="o">=</span> <span class="n">octree</span><span class="o">.</span><span class="n">Surf2Octree</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">,</span><span class="n">SurfConn2</span><span class="p">)</span>
    <span class="c1"># tic = time.time()</span>
    <span class="n">MappingMatrix</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">MappingMatrix</span><span class="p">[</span><span class="n">Surf1Nodes</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">Project2Surface2</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">[</span><span class="n">Surf1Nodes</span><span class="p">,:],</span> <span class="n">NodeNormals1</span><span class="p">[</span><span class="n">Surf1Nodes</span><span class="p">,:],</span> <span class="n">NodeCoords2</span><span class="p">,</span> <span class="n">SurfConn2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">octree</span><span class="o">=</span><span class="n">octree</span><span class="p">)</span>
    <span class="c1"># print(time.time()-tic)</span>
    <span class="c1"># tic = time.time()</span>
    <span class="c1"># MappingMatrix = -1*np.ones((len(NodeCoords1),4))</span>
    <span class="c1"># for i in Surf1Nodes:</span>
    <span class="c1">#     MappingMatrix[i] = Project2Surface(NodeCoords1[i], NodeNormals1[i], NodeCoords2, SurfConn2, tol=tol, octree=octree)</span>
    <span class="c1"># print(time.time()-tic)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="n">failcount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">MappingMatrix</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">Surf1Nodes</span><span class="p">),</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.3f}% o</span><span class="s1">f nodes mapped&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">Surf1Nodes</span><span class="p">)</span><span class="o">-</span><span class="n">failcount</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">Surf1Nodes</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">return_octree</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">MappingMatrix</span><span class="p">,</span> <span class="n">octree</span>
    <span class="k">return</span> <span class="n">MappingMatrix</span></div>


<div class="viewcode-block" id="ValueMapping">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.ValueMapping">[docs]</a>
<span class="k">def</span> <span class="nf">ValueMapping</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">,</span> <span class="n">NodeVals1</span><span class="p">,</span> <span class="n">NodeCoords2</span><span class="p">,</span> <span class="n">SurfConn2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> 
<span class="n">octree</span><span class="o">=</span><span class="s1">&#39;generate&#39;</span><span class="p">,</span> <span class="n">MappingMatrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_MappingMatrix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_octree</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ValueMapping Maps nodal values &lt;NodeVals1&gt; from surface 1 to surface 2</span>
<span class="sd">    - Currently only supports triangluar surface meshes</span>
<span class="sd">    TODO: Multi-value mapping may produce errors - need to better verify.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords1 : List of lists</span>
<span class="sd">        Contains coordinates for each node in surface 1. Ex. [[x1,y1,z1],...]</span>
<span class="sd">    SurfConn1 : List of lists</span>
<span class="sd">        Contains the nodal connectivity defining the surface elements.</span>
<span class="sd">    NodeVals1 : List or List of lists</span>
<span class="sd">        Scalar nodal values associated with surface 1. For multiple values: [[x1,x2,x3,...],[y1,y2,y3,...],[z1,z2,z3,...],...]</span>
<span class="sd">    NodeCoords2 : List of lists</span>
<span class="sd">        Contains coordinates for each node in surface 2. Ex. [[x1,y1,z1],...].</span>
<span class="sd">    SurfConn2 : List of lists</span>
<span class="sd">        Contains the nodal connectivity defining the surface elements.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance value, if the projection distance is greater than tol, the projection will be exculded, default is np.inf </span>
<span class="sd">    octree : str (or octree.OctreeNode), optional</span>
<span class="sd">        octree options. An octree representation of surface 1 can significantly</span>
<span class="sd">        improve mapping speeds, by default &#39;generate&#39;.</span>
<span class="sd">        &#39;generate&#39; - Will generate an octree for use in surface mapping.</span>
<span class="sd">        &#39;none&#39; or None - Won&#39;t generate an octree and will use a brute force approach.</span>
<span class="sd">        octree.OctreeNode - Provide a precompute octree structure corresponding to surface 1. Should be created by octree.Surf2Octree(NodeCoords1,SurfConn1)</span>
<span class="sd">    MappingMatrix : list</span>
<span class="sd">        len(NodeCoords2)x4 matrix of of barycentric coordinates, defining NodeCoords2 in terms</span>
<span class="sd">        of the triangular surface elements of Surface 1.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        If true, will print mapping statistics, by default False.</span>
<span class="sd">    return_MappingMatrix : bool, optional</span>
<span class="sd">        If true, will return MappingMatrix, by default False.</span>
<span class="sd">    return_octree : bool, optional</span>
<span class="sd">        If true, will return generated or provided octree, by defualt False.</span>
<span class="sd">        NOTE if MappingMatrix is provided, the octree structure won&#39;t be generated.</span>
<span class="sd">        In this cases, if octree=&#39;generate&#39; and return_octree=True, the returned value</span>
<span class="sd">        for octree will simply be the string &#39;generate&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeVals2 : List</span>
<span class="sd">        Scalar nodal values associated with surface 2, mapped from surface 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># if type(NodeVals1[0]) is list or type(NodeVals1[0]) is np.ndarray:</span>
    <span class="c1">#     singleVal = False</span>
    <span class="c1">#     # NodeVals2 = [[0 for j in range(len(NodeCoords2))] for i in range(len(NodeVals1))]</span>
    <span class="c1"># else:</span>
    <span class="c1">#     singleVal = True</span>
        <span class="c1"># NodeVals2 = [0 for i in range(len(NodeCoords2))]</span>
    <span class="c1"># Map the coordinates from surface 2 to surface 1</span>
    <span class="k">if</span> <span class="n">MappingMatrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">MappingMatrix</span><span class="p">,</span><span class="n">octree</span> <span class="o">=</span> <span class="n">SurfMapping</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">,</span> <span class="n">SurfConn2</span><span class="p">,</span>  <span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">,</span> <span class="n">octree</span><span class="o">=</span><span class="n">octree</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">return_octree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># if singleVal:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># 1D data</span>
        <span class="n">_NodeVals1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># ND data</span>
        <span class="n">_NodeVals1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">2</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">3</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="c1"># NodeVals2 = np.nan*np.ones(np.shape(NodeVals1))</span>
    <span class="n">elemID</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">ArrayConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SurfConn1</span><span class="p">,[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">NodeVals2</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">_NodeVals1</span><span class="p">[</span><span class="n">ArrayConn</span><span class="p">[</span><span class="n">elemID</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> \
            <span class="n">beta</span><span class="o">*</span><span class="n">_NodeVals1</span><span class="p">[</span><span class="n">ArrayConn</span><span class="p">[</span><span class="n">elemID</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> \
            <span class="n">gamma</span><span class="o">*</span><span class="n">_NodeVals1</span><span class="p">[</span><span class="n">ArrayConn</span><span class="p">[</span><span class="n">elemID</span><span class="p">][:,</span><span class="mi">2</span><span class="p">]]</span>
        
            
    <span class="k">if</span> <span class="n">return_MappingMatrix</span> <span class="ow">and</span> <span class="n">return_octree</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeVals2</span><span class="p">,</span> <span class="n">MappingMatrix</span><span class="p">,</span> <span class="n">octree</span>
    <span class="k">elif</span> <span class="n">return_MappingMatrix</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeVals2</span><span class="p">,</span> <span class="n">MappingMatrix</span>
    <span class="k">elif</span> <span class="n">return_octree</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeVals2</span><span class="p">,</span> <span class="n">octree</span>
    <span class="k">return</span> <span class="n">NodeVals2</span></div>


<div class="viewcode-block" id="DeleteDuplicateNodes">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.DeleteDuplicateNodes">[docs]</a>
<span class="k">def</span> <span class="nf">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DeleteDuplicateNodes Remove nodes that are duplicated in the mesh, either at exactly the same location as another </span>
<span class="sd">    node or a distance &lt; tol apart. Nodes are renumbered and elements reconnected such that the geometry and structure</span>
<span class="sd">    of the mesh remains unchanged. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        Contains coordinates for each node. Ex. [[x1,y1,z1],...]</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance value to be used when determining if two nodes are the same. The default is 1e-14.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeCoords2 : list</span>
<span class="sd">        Updated node coordinates without duplicates.</span>
<span class="sd">    NodeConn2 : list </span>
<span class="sd">        Updated node connectivity without duplicate nodes.</span>
<span class="sd">    newIds : list</span>
<span class="sd">        List of node ids used to relabel the node connectivity. The new node id for a node referenced in the original mesh can be obtained as newId = newIds[oldId]. This can be used to reorder data that was associated with the original mesh to be consistent with the new mesh.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># assert len(NodeCoords) &gt; 0, &#39;No nodes in mesh.&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,[],[]</span>
        <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">tol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">arrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span><span class="o">/</span><span class="n">tol</span><span class="p">)</span><span class="o">*</span><span class="n">tol</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">unq</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arrayCoords</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">newIds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unq</span><span class="p">))[</span><span class="n">inv</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">NodeCoords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">NodeCoords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">tempIds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newIds</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">NodeConn2</span> <span class="o">=</span> <span class="n">ExtractRagged</span><span class="p">(</span><span class="n">tempIds</span><span class="p">[</span><span class="n">R</span><span class="p">],</span><span class="n">delval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">NodeConn2</span> <span class="o">=</span> <span class="n">NodeConn</span>
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeCoords2</span><span class="p">,</span><span class="n">NodeConn2</span><span class="p">,</span><span class="n">newIds</span><span class="p">,</span><span class="n">idx</span>
    <span class="k">return</span> <span class="n">NodeCoords2</span><span class="p">,</span><span class="n">NodeConn2</span><span class="p">,</span><span class="n">newIds</span></div>


<div class="viewcode-block" id="RelabelNodes">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.RelabelNodes">[docs]</a>
<span class="k">def</span> <span class="nf">RelabelNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">newIds</span><span class="p">,</span><span class="n">faces</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="c1"># newIds is a list of node ids where the new index is located at the old index</span>
    <span class="c1"># def func(newIds,elem):</span>
    <span class="c1">#     return [newIds[node] for node in elem]</span>
    <span class="c1"># NewConn = pool(delayed(func)(newIds,elem) for elem in NodeConn)</span>
    <span class="n">NewConn</span> <span class="o">=</span> <span class="n">ExtractRagged</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newIds</span><span class="p">,[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">faces</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="n">NewFaces</span> <span class="o">=</span> <span class="n">ExtractRagged</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newIds</span><span class="p">,[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">faces</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">NewFaces</span> <span class="o">=</span> <span class="n">faces</span>
    <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))</span> <span class="c1"># [[] for i in range(len(NodeCoords))]</span>
    <span class="n">NewCoords</span><span class="p">[</span><span class="n">newIds</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="c1"># for i,node in enumerate(NodeCoords):</span>
    <span class="c1">#     NewCoords[newIds[i]] = node</span>
    <span class="k">if</span> <span class="n">faces</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">NewFaces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span> <span class="n">NewConn</span></div>


<div class="viewcode-block" id="DeleteDegenerateElements">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.DeleteDegenerateElements">[docs]</a>
<span class="k">def</span> <span class="nf">DeleteDegenerateElements</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span><span class="n">angletol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DeleteDegenerateElements Deletes degenerate elements from a mesh.</span>
<span class="sd">    TODO: Currently only valid for triangles.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        List of nodal connectivities.</span>
<span class="sd">    angletol : float, optional</span>
<span class="sd">        Tolerance value for determining what constitutes a degenerate element, by default 1e-3. Degenerate elements will be those who have an angle greater than or equal to 180-180*angletol (default 179.82 degrees)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        List of nodal connectivities.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Remove elements that have a collapsed edge - i.e. two collinear edges</span>
    <span class="c1"># TODO: when tol!=0, using CollapseSlivers this is an imperfect solution (at a minimum, tol parameter should be changed)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">NodeCoords</span>
        <span class="n">NewConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">elem</span><span class="p">))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span> <span class="o">=</span> <span class="n">DeleteDegenerateElements</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewConn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span>
        <span class="k">if</span> <span class="n">angletol</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Change to strict=True&quot;</span><span class="p">)</span>
        
        <span class="n">thetal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">angletol</span> <span class="c1"># Maximum angle threshold </span>
        <span class="k">def</span> <span class="nf">do_split</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">EdgeSort</span><span class="p">,</span><span class="n">ConnSort</span><span class="p">,</span><span class="n">AngleSort</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
            
            <span class="n">elem0</span> <span class="o">=</span> <span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">elem1</span> <span class="o">=</span> <span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">NotShared0</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">elem0</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">EdgeSort</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">NotShared1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">elem1</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">EdgeSort</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># Get the node not belonging to the edge</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">AngleSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thetal</span> <span class="ow">and</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">AngleSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thetal</span> <span class="ow">and</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># Both connected elements are degenerate</span>
                <span class="n">NewNode</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NotShared0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">AngleSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thetal</span> <span class="ow">and</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">NewNode</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NotShared0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">AngleSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thetal</span> <span class="ow">and</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">NewNode</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NotShared1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span>
            
            <span class="n">NewId</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">)</span>
            <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewNode</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">while</span> <span class="n">elem0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">NotShared0</span><span class="p">:</span> <span class="n">elem0</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">+</span><span class="n">elem0</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># cycle the element definition so that it starts with the non-shared node (Might be unnecessarily slow)</span>
                <span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">elem0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">elem0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">NewId</span><span class="p">],[</span><span class="n">elem0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">NewId</span><span class="p">,</span><span class="n">elem0</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span>
            <span class="k">if</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">while</span> <span class="n">elem1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">NotShared1</span><span class="p">:</span> <span class="n">elem1</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">+</span><span class="n">elem1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">elem1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">elem1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">NewId</span><span class="p">],[</span><span class="n">elem1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">NewId</span><span class="p">,</span><span class="n">elem1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span>
            
            <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span> <span class="n">NewConn</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="n">NewConn</span> <span class="o">=</span> <span class="n">NewConn</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">Thinking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">maxiter</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">while</span> <span class="n">Thinking</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">)</span>
            <span class="n">Edges</span><span class="p">,</span> <span class="n">EdgeConn</span><span class="p">,</span> <span class="n">EdgeElem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">return_EdgeConn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">UEdges</span><span class="p">,</span> <span class="n">UIdx</span><span class="p">,</span> <span class="n">UInv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">UEdgeElem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeElem</span><span class="p">)[</span><span class="n">UIdx</span><span class="p">]</span>
            <span class="n">UEdgeConn</span> <span class="o">=</span> <span class="n">UInv</span><span class="p">[</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">)]</span>
            <span class="n">EECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">UEdgeElem</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">EdgeElemConn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">Edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Edges</span><span class="p">);</span> <span class="n">EdgeConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">)</span>
            <span class="n">EdgeVectors</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">Edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">Edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">EdgeLengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">EdgeVectors</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">ElemVectors</span> <span class="o">=</span> <span class="n">EdgeVectors</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>
            <span class="n">ElemLengths</span> <span class="o">=</span> <span class="n">EdgeLengths</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>

            <span class="n">OppositeAngles</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ElemLengths</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]),</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]),</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">OppositeAngles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">OppositeAngles</span><span class="p">)</span>

            <span class="n">EdgeOppositeAngles</span> <span class="o">=</span>  <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">OppositeAngles</span>

            <span class="n">sortkey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">EdgeLengths</span><span class="p">[</span><span class="n">UIdx</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">LengthSort</span> <span class="o">=</span> <span class="n">EdgeLengths</span><span class="p">[</span><span class="n">UIdx</span><span class="p">][</span><span class="n">sortkey</span><span class="p">]</span>
            <span class="n">AngleSort</span> <span class="o">=</span> <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">sortkey</span><span class="p">]</span>
            <span class="n">EdgeSort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">UEdges</span><span class="p">)[</span><span class="n">sortkey</span><span class="p">]</span>
            <span class="n">ConnSort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">)[</span><span class="n">sortkey</span><span class="p">]</span>

            <span class="n">AbsLargeAngle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">AngleSort</span> <span class="o">&gt;=</span> <span class="n">thetal</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">todo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">AbsLargeAngle</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Splits</span>
            <span class="n">repeat</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="n">repeat</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
                <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span> <span class="o">=</span> <span class="n">do_split</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">EdgeSort</span><span class="p">,</span><span class="n">ConnSort</span><span class="p">,</span><span class="n">AngleSort</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

            <span class="n">NewConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NewConn</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NewConn</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">)]</span>
            <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">repeat</span><span class="p">:</span>
                <span class="n">Thinking</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Thinking</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span> <span class="o">=</span> <span class="n">DeleteDegenerateElements</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># if len(converter.surf2edges(NewCoords,NewConn)) &gt; 0:</span>
            <span class="c1">#     print(&#39;merp&#39;)</span>
                
    <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span></div>


<div class="viewcode-block" id="MirrorMesh">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.MirrorMesh">[docs]</a>
<span class="k">def</span> <span class="nf">MirrorMesh</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MirrorMesh Creates a mirrored copy of a mesh by mirroring about the planes</span>
<span class="sd">    defined by X=x, Y=y, and Z=z</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        Nodal Coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal Connectivity.</span>
<span class="sd">    x : Numeric, optional</span>
<span class="sd">        YZ plane at X = x. The default is None.</span>
<span class="sd">    y : TYPE, optional</span>
<span class="sd">        XZ plane at Y = y. The default is None.</span>
<span class="sd">    z : TYPE, optional</span>
<span class="sd">        XY plane at Z = z. The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MirroredCoords : list</span>
<span class="sd">        Mirrored Nodal Coordinates.</span>
<span class="sd">    MirroredConn : list</span>
<span class="sd">        Nodal Connectivity of Mirrored Elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">MirroredCoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">NodeCoords</span><span class="p">]</span>
    <span class="n">MirroredConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MirroredCoords</span><span class="p">)):</span>
            <span class="n">MirroredCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">MirroredCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> 
    <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MirroredCoords</span><span class="p">)):</span>
            <span class="n">MirroredCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">MirroredCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">if</span> <span class="n">z</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MirroredCoords</span><span class="p">)):</span>
            <span class="n">MirroredCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">MirroredCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">z</span>
    
    
    <span class="k">return</span> <span class="n">MirroredCoords</span><span class="p">,</span> <span class="n">MirroredConn</span></div>

    
<div class="viewcode-block" id="MergeMesh">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.MergeMesh">[docs]</a>
<span class="k">def</span> <span class="nf">MergeMesh</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">NodeConn1</span><span class="p">,</span> <span class="n">NodeCoords2</span><span class="p">,</span> <span class="n">NodeConn2</span><span class="p">,</span> <span class="n">NodeVals1</span><span class="o">=</span><span class="p">[],</span> <span class="n">NodeVals2</span><span class="o">=</span><span class="p">[],</span> <span class="n">cleanup</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MergeMesh Merge two meshes together</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords1 : list</span>
<span class="sd">        List of nodal coordinates for mesh 1.</span>
<span class="sd">    NodeConn1 : list</span>
<span class="sd">        List of nodal connectivities for mesh 1.</span>
<span class="sd">    NodeCoords2 : list</span>
<span class="sd">        List of nodal coordinates for mesh 2.</span>
<span class="sd">    NodeConn2 : list</span>
<span class="sd">        List of nodal connectivities for mesh 2.</span>
<span class="sd">    NodeVals1 : list, optional</span>
<span class="sd">        List of node data associated with mesh 1, by default []</span>
<span class="sd">    NodeVals2 : list, optional</span>
<span class="sd">        List of node data associated with mesh 2, by default []</span>
<span class="sd">    cleanup : bool, optional</span>
<span class="sd">        If true, duplicate nodes will be deleted and renumbered accordingly, by default True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MergedCoords : list</span>
<span class="sd">        List of nodal coordinates of the merged mesh.</span>
<span class="sd">        Nodes from mesh 1 appear first, followed by those of mesh 2.</span>
<span class="sd">    MergedConn : list</span>
<span class="sd">        List of nodal connectivities of the merged mesh.</span>
<span class="sd">    MergedVals : list, optional</span>
<span class="sd">        If provided, merged list of NodeVals.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">NodeCoords1</span> <span class="o">=</span> <span class="n">NodeCoords1</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeConn1</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">NodeConn1</span> <span class="o">=</span> <span class="n">NodeConn1</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">NodeCoords2</span> <span class="o">=</span> <span class="n">NodeCoords2</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeConn2</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">NodeConn2</span> <span class="o">=</span> <span class="n">NodeConn2</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">NodeVals1</span> <span class="o">=</span> <span class="n">NodeVals1</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeVals2</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">NodeVals2</span> <span class="o">=</span> <span class="n">NodeVals2</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
    <span class="n">MergeCoords</span> <span class="o">=</span> <span class="n">NodeCoords1</span> <span class="o">+</span> <span class="n">NodeCoords2</span>

    <span class="n">MergeConn</span> <span class="o">=</span> <span class="n">NodeConn1</span> <span class="o">+</span> <span class="p">[[</span><span class="n">node</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn2</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">),</span> <span class="s1">&#39;NodeVals lists must contain the number of entries as nodes.&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeVals2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">),</span> <span class="s1">&#39;NodeVals lists must contain the number of entries as nodes.&#39;</span>

        <span class="n">MergeVals</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">)):</span>
            <span class="n">MergeVals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NodeVals1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">NodeVals2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cleanup</span><span class="p">:</span>
            <span class="n">MergeCoords</span><span class="p">,</span><span class="n">MergeConn</span><span class="p">,</span><span class="n">newIds</span> <span class="o">=</span> <span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">MergeCoords</span><span class="p">,</span><span class="n">MergeConn</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MergeVals</span><span class="p">)):</span>
                <span class="n">MergeVals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">MergeVals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">newIds</span><span class="p">]</span>
                
            <span class="k">return</span> <span class="n">MergeCoords</span><span class="p">,</span> <span class="n">MergeConn</span><span class="p">,</span> <span class="n">MergeVals</span>
    
    <span class="k">elif</span> <span class="n">cleanup</span><span class="p">:</span>
        <span class="n">MergeCoords</span><span class="p">,</span><span class="n">MergeConn</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">MergeCoords</span><span class="p">,</span><span class="n">MergeConn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MergeCoords</span><span class="p">,</span> <span class="n">MergeConn</span></div>

    
<div class="viewcode-block" id="DetectFeatures">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.DetectFeatures">[docs]</a>
<span class="k">def</span> <span class="nf">DetectFeatures</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">,</span><span class="n">angle</span><span class="o">=</span><span class="mi">25</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DetectFeatures Classifies nodes as edges or corners if the angle between adjacent</span>
<span class="sd">    surface elements is less than or equal to &lt;angle&gt; (deg)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    SurfConn : list</span>
<span class="sd">        List of nodal connectivities of a surface mesh.</span>
<span class="sd">    angle : float, optional</span>
<span class="sd">        Dihedral angle threshold (in degrees) used to determine whether an edge</span>
<span class="sd">        exists between two adjacent faces, by default 140.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    edges : list</span>
<span class="sd">        list of nodes identified to lie on an edge of the geometry.</span>
<span class="sd">    corners : list</span>
<span class="sd">        list of nodes identified to lie on a corner of the geometry.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">))</span>
    <span class="n">Edges</span><span class="p">,</span> <span class="n">EdgeConn</span><span class="p">,</span> <span class="n">EdgeElem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">,</span><span class="n">return_EdgeConn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">UEdges</span><span class="p">,</span> <span class="n">UIdx</span><span class="p">,</span> <span class="n">UInv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">UEdgeElem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeElem</span><span class="p">)[</span><span class="n">UIdx</span><span class="p">]</span>
    <span class="n">UEdgeConn</span> <span class="o">=</span> <span class="n">UInv</span><span class="p">[</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">)]</span>
    <span class="n">EECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">UEdgeElem</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">EdgeElemConn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
    <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">ConnectedNormals</span> <span class="o">=</span> <span class="n">ElemNormals</span><span class="p">[</span><span class="n">EdgeElemConn</span><span class="p">]</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">quality</span><span class="o">.</span><span class="n">dihedralAngles</span><span class="p">(</span><span class="n">ConnectedNormals</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">ConnectedNormals</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">Abs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">FeatureEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">angles</span> <span class="o">&gt;</span> <span class="n">angle</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">FeatureNodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">FeatureEdges</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">UEdges</span><span class="p">[</span><span class="n">edge</span><span class="p">]]</span>
    <span class="n">unq</span><span class="p">,</span><span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">FeatureNodes</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">corners</span> <span class="o">=</span> <span class="n">unq</span><span class="p">[</span><span class="n">counts</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">unq</span><span class="p">[</span><span class="n">counts</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="c1"># angle = 140</span>
    <span class="c1"># ElemNormals = CalcFaceNormal(NodeCoords,SurfConn)</span>
    <span class="c1"># ElemNeighbors = getElemNeighbors(NodeCoords,SurfConn,mode=&#39;edge&#39;)</span>
    <span class="c1"># edges = []</span>
    <span class="c1"># corners = []</span>
    <span class="c1"># for i in range(len(SurfConn)):  # For each element:</span>
    <span class="c1">#     Ni = ElemNormals[i]</span>
    <span class="c1">#     sharedNodes = []</span>
    <span class="c1">#     for j in ElemNeighbors[i]:   # For each adjacent element:</span>
    <span class="c1">#         Nj = ElemNormals[j]</span>
    <span class="c1">#         theta = 180 - np.arccos(min([1,abs(np.dot(Ni,Nj)/(np.linalg.norm(Ni)*np.linalg.norm(Nj)))]))*180/np.pi</span>
    <span class="c1">#         if theta &lt;= angle:</span>
    <span class="c1">#             sharedNodes.append(np.intersect1d(SurfConn[i],SurfConn[j]).tolist())</span>
    <span class="c1">#     unq,counts = np.unique([x for sublist in sharedNodes for x in sublist],return_counts=True)</span>
    <span class="c1">#     for j in range(len(unq)):</span>
    <span class="c1">#         if counts[j] == 1:</span>
    <span class="c1">#             edges.append(unq[j])</span>
    <span class="c1">#         else:   # counts &gt;= 2</span>
    <span class="c1">#             corners.append(unq[j])</span>
    <span class="c1"># edges = np.unique(edges).tolist()</span>
    <span class="c1"># corners = np.unique(corners).tolist()</span>
    <span class="c1"># edges = [edge for edge in edges if edge not in corners]</span>

    <span class="k">return</span> <span class="n">edges</span><span class="p">,</span><span class="n">corners</span></div>


<div class="viewcode-block" id="PeelHex">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.PeelHex">[docs]</a>
<span class="k">def</span> <span class="nf">PeelHex</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">nLayers</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PeelHex Removes the specified number of layers from a hexahedral mesh</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list of lists</span>
<span class="sd">        Contains coordinates for each node in a voxel mesh. Ex. [[x1,y1,z1],...].</span>
<span class="sd">        The mesh is assumed to consist of only hexahedral elements.</span>
<span class="sd">    NodeConn : List of lists</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    nLayers : int, optional</span>
<span class="sd">        Number of layers to peel. The default is 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    PeeledCoords : List</span>
<span class="sd">        Node coordinates for each node in the peeled mesh.</span>
<span class="sd">    PeeledConn : list</span>
<span class="sd">        Nodal connectivity for each element in the peeled mesh.</span>
<span class="sd">    PeelCoords : list</span>
<span class="sd">        Node coordinates for each node in the layers of the mesh that have</span>
<span class="sd">        been removed.</span>
<span class="sd">    PeelConn : list</span>
<span class="sd">        Nodal connectivity for each element in the layers of the mesh that have</span>
<span class="sd">        been removed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">NewConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>   
    <span class="n">PeelConn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nLayers</span><span class="p">):</span>
        <span class="n">HexSurfConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2surface</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">)</span>
        <span class="n">SurfNodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">HexSurfConn</span><span class="p">)</span>
        <span class="n">SurfNodeSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">SurfNodes</span><span class="p">)</span>
        <span class="n">PeelConn</span> <span class="o">+=</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NewConn</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">&amp;</span><span class="n">SurfNodeSet</span><span class="p">)]</span>
        <span class="n">NewConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NewConn</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">&amp;</span><span class="n">SurfNodeSet</span><span class="p">)]</span>
        
    
    <span class="n">PeelCoords</span><span class="p">,</span><span class="n">PeelConn</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">removeNodes</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">PeelConn</span><span class="p">)</span>
    <span class="n">PeeledCoords</span><span class="p">,</span><span class="n">PeeledConn</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">removeNodes</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">PeeledCoords</span><span class="p">,</span> <span class="n">PeeledConn</span><span class="p">,</span> <span class="n">PeelCoords</span><span class="p">,</span> <span class="n">PeelConn</span></div>

    
<div class="viewcode-block" id="makePyramidLayer">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.makePyramidLayer">[docs]</a>
<span class="k">def</span> <span class="nf">makePyramidLayer</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">,</span><span class="n">PyramidHeight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    makePyramidLayer For a given voxel mesh, will generate a set of pyramid </span>
<span class="sd">    elements that cover the surface of the voxel mesh. To merge the pyramid </span>
<span class="sd">    layer with the voxel mesh, use MergeMesh</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : list</span>
<span class="sd">        Contains coordinates for each node in a voxel mesh. Ex. [[x0,y0,z0],...].</span>
<span class="sd">    VoxelConn : List</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">        The voxel mesh is assumed to consist of a set of uniform cubic hexahedral </span>
<span class="sd">        elements.</span>
<span class="sd">    PyramidHeight : float (or None), optional</span>
<span class="sd">        Height of the pyramids. The default is None.</span>
<span class="sd">        If no height as assigned, it will default to 1/2 of the voxel size</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    PyramidCoords : list</span>
<span class="sd">        List of nodal coordinates for the pyramid elements.</span>
<span class="sd">    PyramidConn : list</span>
<span class="sd">        List of nodal connectivities for the pyramid elements.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">PyramidHeight</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">PyramidHeight</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        
    <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2surface</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">)</span>
    <span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">removeNodes</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">)</span>
    
    <span class="n">FaceNormals</span> <span class="o">=</span> <span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">)</span>
    <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">)</span>
    <span class="n">PyramidConn</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">))]</span>
    <span class="n">PyramidCoords</span> <span class="o">=</span> <span class="n">SurfCoords</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">face</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">face</span><span class="p">]</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tipCoord</span> <span class="o">=</span> <span class="n">centroid</span> <span class="o">+</span> <span class="n">PyramidHeight</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FaceNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="n">PyramidConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">face</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">PyramidCoords</span><span class="p">)]</span>
        <span class="n">PyramidCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tipCoord</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    
    <span class="k">return</span> <span class="n">PyramidCoords</span><span class="p">,</span> <span class="n">PyramidConn</span></div>


<div class="viewcode-block" id="makeVoxelLayer">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.makeVoxelLayer">[docs]</a>
<span class="k">def</span> <span class="nf">makeVoxelLayer</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    makeVoxelLayer For a given voxel mesh, will generate a layer of voxels that</span>
<span class="sd">    wrap around the current voxel mesh. To merge the pyramid </span>
<span class="sd">    layer with the voxel mesh, use MergeMesh</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : list of lists</span>
<span class="sd">        Contains coordinates for each node in a voxel mesh. Ex. [[x1,y1,z1],...].</span>
<span class="sd">        The voxel mesh is assumed to consist of a set of uniform cubic hexahedral </span>
<span class="sd">        elements.</span>
<span class="sd">    VoxelConn : List of lists</span>
<span class="sd">        Nodal connectivity list.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    LayerCoords : TYPE</span>
<span class="sd">        DESCRIPTION.</span>
<span class="sd">    LayerConn : TYPE</span>
<span class="sd">        DESCRIPTION.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: This has the potential to create overlapping voxels</span>
    <span class="n">VoxelSize</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
        
    <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2surface</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">)</span>
    <span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">removeNodes</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">)</span>
    
    <span class="n">FaceNormals</span> <span class="o">=</span> <span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">)</span>
    <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">)</span>
    <span class="n">LayerConn</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">))]</span>
    <span class="n">LayerCoords</span> <span class="o">=</span> <span class="n">SurfCoords</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">face</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">face</span><span class="p">]</span>
        <span class="n">coord0</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">VoxelSize</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FaceNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">coord1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">VoxelSize</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FaceNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">coord2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">VoxelSize</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FaceNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">coord3</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">VoxelSize</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FaceNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="n">LayerConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">face</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">LayerCoords</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">LayerCoords</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">LayerCoords</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">LayerCoords</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">LayerCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord0</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">LayerCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord1</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">LayerCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord2</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">LayerCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord3</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        
    <span class="k">return</span> <span class="n">LayerCoords</span><span class="p">,</span> <span class="n">LayerConn</span></div>

        
<div class="viewcode-block" id="TriSurfVol">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.TriSurfVol">[docs]</a>
<span class="k">def</span> <span class="nf">TriSurfVol</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TriSurfVol Calculates the volume contained within a surface mesh</span>
<span class="sd">    Based on &#39;Efficient feature extraction for 2D/3D objects in mesh </span>
<span class="sd">    representation.&#39; - Zhang, C. and Chen, T., 2001</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list of lists</span>
<span class="sd">        Contains coordinates for each node. Ex. [[x1,y1,z1],...].</span>
<span class="sd">    SurfConn : List of lists</span>
<span class="sd">        Nodal connectivity list for a triangular surface mesh.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    V : float</span>
<span class="sd">        Volume contained within the surface mesh.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">TriSignedVolume</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> 
                     <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> 
                     <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span>
                     <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> 
                     <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> 
                     <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">TriSignedVolume</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">SurfConn</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">V</span></div>

    
<div class="viewcode-block" id="TetMeshVol">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.TetMeshVol">[docs]</a>
<span class="k">def</span> <span class="nf">TetMeshVol</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TetMeshVol Calculates the volume contained within a tetrahedral mesh</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list of lists</span>
<span class="sd">        Contains coordinates for each node. Ex. [[x1,y1,z1],...].</span>
<span class="sd">    NodeConn : List of lists</span>
<span class="sd">        Nodal connectivity list for a tetrahedral mesh.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    V : float</span>
<span class="sd">        Volume contained within the tetrahedral mesh.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">TetVolume</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]))))</span><span class="o">/</span><span class="mi">6</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">TetVolume</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">V</span></div>


<div class="viewcode-block" id="PadRagged">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.PadRagged">[docs]</a>
<span class="k">def</span> <span class="nf">PadRagged</span><span class="p">(</span><span class="n">In</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PadRagged Pads a 2d list of lists with variable length into a rectangular </span>
<span class="sd">    numpy array with specified fill value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    In : list</span>
<span class="sd">        Input list of lists to be padded.</span>
<span class="sd">    fillval : int (or other), optional</span>
<span class="sd">        Value used to pad the ragged array, by default -1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Out : np.ndarray</span>
<span class="sd">        Padded array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">zip_longest</span><span class="p">(</span><span class="o">*</span><span class="n">In</span><span class="p">,</span><span class="n">fillvalue</span><span class="o">=</span><span class="n">fillval</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">Out</span></div>


<div class="viewcode-block" id="ExtractRagged_old">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.ExtractRagged_old">[docs]</a>
<span class="k">def</span> <span class="nf">ExtractRagged_old</span><span class="p">(</span><span class="n">In</span><span class="p">,</span><span class="n">delval</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ExtractRagged Extracts a list of list from a 2d numpy array, removing the </span>
<span class="sd">    specified value, generally creating a ragged array unless there is no padding</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    In : numpy.ndarray</span>
<span class="sd">        Input array.</span>
<span class="sd">    delval : int (or other), optional</span>
<span class="sd">        Padding value to be removed from the input array, by default -1.</span>
<span class="sd">    dtype : type, optional</span>
<span class="sd">        type to cast the output result to, by default None.</span>
<span class="sd">        If None, no casting will be performed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Out : list</span>
<span class="sd">        Output list of lists with the specified value &lt;delval&gt; removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">In</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">In</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">In</span><span class="p">)</span>
        <span class="n">In</span> <span class="o">=</span> <span class="n">In</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">delval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">delval</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">delval</span> <span class="o">==</span> <span class="n">In</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">In</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">Out</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">delval</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">In</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">In</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">Out</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">delval</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">z</span> <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span><span class="o">!=</span> <span class="n">delval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">In</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Currently only supported for 2- or 3D matrices&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Out</span> <span class="o">=</span> <span class="n">In</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Out</span></div>


<div class="viewcode-block" id="ExtractRagged">
<a class="viewcode-back" href="../../Mesh.html#Mesh.utils.ExtractRagged">[docs]</a>
<span class="k">def</span> <span class="nf">ExtractRagged</span><span class="p">(</span><span class="n">In</span><span class="p">,</span><span class="n">delval</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">In</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">In</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">In</span><span class="p">)</span>
        <span class="n">In</span> <span class="o">=</span> <span class="n">In</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">delval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">delval</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">where</span> <span class="o">=</span> <span class="n">In</span> <span class="o">!=</span> <span class="n">delval</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">In</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">Out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">In</span><span class="p">[</span><span class="n">where</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">where</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Out = [x.tolist() for x in Out]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">In</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">Out</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">delval</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">z</span> <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span><span class="o">!=</span> <span class="n">delval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">In</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Currently only supported for 2- or 3D matrices&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Out</span> <span class="o">=</span> <span class="n">In</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Out</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Timothy O. Josephson.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>