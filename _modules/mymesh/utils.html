
<!DOCTYPE html>


<html lang="en" data-content_root="../../" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mymesh.utils &#8212; MyMesh vdev Manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/mymesh.css?v=1e1bb860" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=3ce10a4d"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=4ea706d9"></script>
    <script src="../../_static/thebelab-helper.js"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/mymesh/utils';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="dev" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
    
    <img src="../../_static/mymesh_logo.png" class="logo__image only-light" alt="MyMesh vdev Manual - Home"/>
    <img src="../../_static/mymesh_logo.png" class="logo__image only-dark pst-js-only" alt="MyMesh vdev Manual - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../guide.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../theory.html">
    Theory Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../dev.html">
    Development
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/BU-SMBL/mymesh" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../guide.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../theory.html">
    Theory Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../dev.html">
    Development
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/BU-SMBL/mymesh" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    
    <li class="breadcrumb-item"><a href="../mymesh.html" class="nav-link">mymesh</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">mymesh.utils</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for mymesh.utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Created on Wed Sep 29 18:31:03 2021</span>
<span class="c1"># @author: toj</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Various mesh utilities for mesh measurements, manipulations, cleanup, and more</span>

<span class="sd">.. currentmodule:: mymesh.utils</span>


<span class="sd">Mesh Connectivity</span>
<span class="sd">=================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    getNodeNeighbors</span>
<span class="sd">    getElemConnectivity</span>
<span class="sd">    getNodeNeighborhood</span>
<span class="sd">    getNodeNeighborhoodByRadius</span>
<span class="sd">    getElemNeighbors</span>
<span class="sd">    getConnectedNodes</span>
<span class="sd">    getConnectedElements</span>

<span class="sd">Mesh Measurements</span>
<span class="sd">=================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    Centroids</span>
<span class="sd">    CalcFaceNormal</span>
<span class="sd">    Face2NodeNormal</span>
<span class="sd">    DetectFeatures</span>
<span class="sd">    TriSurfVol</span>
<span class="sd">    TetMeshVol</span>
<span class="sd">    MVBB</span>
<span class="sd">    AABB</span>

<span class="sd">Mesh Manipulations</span>
<span class="sd">==================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    MirrorMesh</span>
<span class="sd">    MergeMesh</span>
<span class="sd">    DilateVoxel</span>
<span class="sd">    ErodeVoxel</span>
<span class="sd">    makePyramidLayer</span>

<span class="sd">Surface Projection</span>
<span class="sd">==================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    ValueMapping</span>
<span class="sd">    SurfMapping</span>
<span class="sd">    Project2Surface</span>
<span class="sd">    BaryTri</span>
<span class="sd">    BaryTris</span>
<span class="sd">    BaryTet</span>

<span class="sd">Mesh Cleanup</span>
<span class="sd">============</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    DeleteDuplicateNodes</span>
<span class="sd">    DeleteDegenerateElements</span>
<span class="sd">    CleanupDegenerateElements</span>
<span class="sd">    RelabelNodes</span>

<span class="sd">Miscellaneous </span>
<span class="sd">=============</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    SortRaggedByLength</span>
<span class="sd">    SplitRaggedByLength</span>
<span class="sd">    PadRagged</span>
<span class="sd">    ExtractRagged</span>
<span class="sd">    identify_type</span>
<span class="sd">    identify_elem</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span><span class="o">,</span><span class="w"> </span><span class="nn">warnings</span><span class="o">,</span><span class="w"> </span><span class="nn">copy</span><span class="o">,</span><span class="w"> </span><span class="nn">time</span><span class="o">,</span><span class="w"> </span><span class="nn">itertools</span><span class="o">,</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">converter</span><span class="p">,</span> <span class="n">delaunay</span><span class="p">,</span> <span class="n">rays</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">improvement</span><span class="p">,</span> <span class="n">quality</span><span class="p">,</span> <span class="n">mesh</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">try_njit</span><span class="p">,</span> <span class="n">check_numba</span>

<div class="viewcode-block" id="getNodeNeighbors">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.getNodeNeighbors.html#mymesh.utils.getNodeNeighbors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getNodeNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">ElemType</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the adjacent nodes for each node in the mesh</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : array_like</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : array_like</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    ElemType : str, optional</span>
<span class="sd">        Type of element contained in the mesh, by default &#39;auto&#39;.</span>
<span class="sd">        See converter.solid2edges() for details.</span>
<span class="sd">        &#39;auto&#39; is suitable for most element types and mixed-element meshes,</span>
<span class="sd">        4-node elements are assumed to be tets, not quads, unless ElemType is </span>
<span class="sd">        set to &#39;quad&#39; or &#39;surf&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeNeighbors : list</span>
<span class="sd">        List of neighboring nodes for each node in NodeCoords.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Edges</span><span class="p">,</span><span class="n">EdgeElem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ElemType</span><span class="o">=</span><span class="n">ElemType</span><span class="p">)</span>
    
    <span class="n">UEdges</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">inv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">NotInMesh</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">UEdges</span><span class="p">))</span>
    <span class="n">Neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">UEdges</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">NotInMesh</span><span class="p">)))</span>
    <span class="n">Idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">UEdges</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span><span class="nb">list</span><span class="p">(</span><span class="n">NotInMesh</span><span class="p">))</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">Idx</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

    <span class="n">key_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">z</span> <span class="k">for</span> <span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">z</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Idx</span><span class="p">[</span><span class="n">arg</span><span class="p">],</span><span class="n">Neighbors</span><span class="p">[</span><span class="n">arg</span><span class="p">]),</span> <span class="n">key_func</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">NodeNeighbors</span>             </div>


<div class="viewcode-block" id="getElemConnectivity">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.getElemConnectivity.html#mymesh.utils.getElemConnectivity">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getElemConnectivity</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the elements connected to each node in the mesh</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : array_like</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : array_like</span>
<span class="sd">        Nodal connectivity list.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ElemConn : list</span>
<span class="sd">        List of elements connected to each node.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">nodes</span><span class="p">,</span><span class="n">elems</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span>
        <span class="n">NotInMesh</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">NotInMesh</span><span class="p">)</span>
        <span class="n">elems</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>

        <span class="n">ElemConn</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">elem</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">group</span> <span class="k">if</span> <span class="n">elem</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">elems</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ElemConn</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="n">ElemConn</span></div>


<div class="viewcode-block" id="getNodeNeighborhood">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.getNodeNeighborhood.html#mymesh.utils.getNodeNeighborhood">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getNodeNeighborhood</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">nRings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives the connected nodes in an n ring neighborhood for each node in the mesh</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    nRings : int</span>
<span class="sd">        Number of rings to include.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeNeighborhoods : list</span>
<span class="sd">        List of neighboring nodes in an n ring neighborhood around each node in </span>
<span class="sd">        NodeCoords.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">NodeNeighborhoods</span> <span class="o">=</span> <span class="p">[[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">))]</span>
    <span class="k">if</span> <span class="n">nRings</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeNeighborhoods</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRings</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># For each ring, loop through and add the neighbors of the nodes in the neighborhood to the neighborhood</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighborhoods</span><span class="p">)):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">])):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">):</span>
                            <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">NodeNeighborhoods</span></div>

            
<div class="viewcode-block" id="getNodeNeighborhoodByRadius">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.getNodeNeighborhoodByRadius.html#mymesh.utils.getNodeNeighborhoodByRadius">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getNodeNeighborhoodByRadius</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">Radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives the connected nodes in a neighborhood with a specified radius for each node in the mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    radius : float</span>
<span class="sd">        Radius of around each node.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeNeighborhoods : list</span>
<span class="sd">        List of neighboring nodes in an neighborhood around each node in </span>
<span class="sd">        NodeCoords with the neighborhoods specified by a radius.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">NodeNeighborhoods</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighborhoods</span><span class="p">)):</span>
        <span class="n">thisNode</span> <span class="o">=</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                            <span class="p">(</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                                <span class="p">(</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">Radius</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">thinking</span><span class="p">:</span>
            <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">])):</span>                    
                    <span class="k">if</span> <span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">):</span>
                        <span class="n">otherNode</span> <span class="o">=</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">otherNode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">otherNode</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">thisNode</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">otherNode</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">Radius</span><span class="p">:</span>
                            <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">NodeNeighborhoods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">NodeNeighborhoods</span>   </div>


<div class="viewcode-block" id="getElemNeighbors">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.getElemNeighbors.html#mymesh.utils.getElemNeighbors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getElemNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">,</span><span class="n">ElemConn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get list of neighboring elements for each element in the mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        List of nodal connectivities.</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        Neighbor mode, will determine what type of connectivity constitutes an element</span>
<span class="sd">        neighbor, by default &#39;face&#39;.</span>
<span class="sd">        &#39;node&#39; : Any elements that share at least one node are considered neighbors. TODO: Not currently implemented.</span>
<span class="sd">        &#39;edge&#39; : Any elements that share an edge are considered neighbors.</span>
<span class="sd">        &#39;face&#39; : Any elements that share a face are considered neighbors. NOTE that in surface meshes, no elements share faces.</span>
<span class="sd">    ElemConn : list, optional</span>
<span class="sd">        Node-Element connectivity of the mesh as obtained by getNodeNeighbors.</span>
<span class="sd">        If supplied, won&#39;t require an additional call to getNodeNeighbors.</span>
<span class="sd">        Only relevant if mode == &#39;node&#39;, by default None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ElemNeighbors : list</span>
<span class="sd">        List of element neighbors. For each element, there is a list of the</span>
<span class="sd">        indices of the neighboring elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get Element neighbors </span>
    
    <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;node&#39;</span><span class="p">:</span>
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">))]</span>
        <span class="n">ElemConn</span> <span class="o">=</span> <span class="n">getElemConnectivity</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">]</span> 
    <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;edge&#39;</span><span class="p">:</span>
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">))]</span>
        <span class="n">Edges</span><span class="p">,</span><span class="n">EdgeConn</span><span class="p">,</span><span class="n">EdgeElem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_EdgeConn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">UEdges</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">inv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">UEdgeConn</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">)]</span>
        <span class="n">UEdgeElem</span> <span class="o">=</span> <span class="n">EdgeElem</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">EdgeElemConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">)))</span> <span class="c1"># Elements attached to each edge</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">EECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">UEdgeElem</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="n">ElemNeighbors</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">ElemNeighbors</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">]</span> 

    <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;face&#39;</span><span class="p">:</span>
        <span class="c1">#TODO: This needs to updated, can be made faster, should use converter.faces2unique</span>
        <span class="n">faces</span><span class="p">,</span><span class="n">faceconn</span><span class="p">,</span><span class="n">faceelem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2faces</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">return_FaceConn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_FaceElem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">######</span>
        <span class="c1"># if v == 1:</span>
        <span class="n">sortface</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">face</span><span class="p">))</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">]</span>
        <span class="n">FaceElem</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">facekey</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sortface</span><span class="p">):</span>
            <span class="n">FaceElem</span><span class="p">[</span><span class="n">facekey</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">faceelem</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="n">ElemNeighborDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">fs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">faceconn</span><span class="p">):</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">{</span><span class="n">elem</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fs</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">FaceElem</span><span class="p">[</span><span class="n">sortface</span><span class="p">[</span><span class="n">f</span><span class="p">]]}</span>
            <span class="n">neighbors</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ElemNeighborDict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbors</span>
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ElemNeighborDict</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">faceconn</span><span class="p">))]</span>
        
        <span class="c1">#####</span>
        <span class="c1"># elif v == 0:</span>
        <span class="c1">#     ElemNeighbors = [set() for i in range(len(NodeConn))]</span>
        <span class="c1">#     # Pad Ragged arrays in case of mixed-element meshes</span>
        <span class="c1">#     Rfaces = PadRagged(faces)</span>
        <span class="c1">#     Rfaceconn = PadRagged(faceconn)</span>
        <span class="c1">#     # Get all unique element faces (accounting for flipped versions of faces)</span>
        <span class="c1">#     _,idx,inv = np.unique(np.sort(Rfaces,axis=1),axis=0,return_index=True,return_inverse=True)</span>
        <span class="c1">#     RFaces = Rfaces[idx]</span>
        <span class="c1">#     FaceElem = faceelem[idx]</span>
        <span class="c1">#     RFaces = np.append(RFaces, np.repeat(-1,RFaces.shape[1])[None,:],axis=0)</span>
        <span class="c1">#     inv = np.append(inv,-1)</span>
        <span class="c1">#     RFaceConn = inv[Rfaceconn] # Faces attached to each element</span>
        <span class="c1">#     # Face-Element Connectivity</span>
        <span class="c1">#     FaceElemConn = np.nan*(np.ones((len(RFaces),2)))</span>
    
        <span class="c1">#     FECidx = (FaceElem[RFaceConn] == np.repeat(np.arange(len(NodeConn))[:,None],RFaceConn.shape[1],axis=1)).astype(int)</span>
        <span class="c1">#     FaceElemConn[RFaceConn,FECidx] = np.repeat(np.arange(len(NodeConn))[:,None],RFaceConn.shape[1],axis=1)</span>
        <span class="c1">#     FaceElemConn = [[int(x) if not np.isnan(x) else x for x in y] for y in FaceElemConn[:-1]]</span>
    
        <span class="c1">#     for i in range(len(FaceElemConn)):</span>
        <span class="c1">#         if np.any(np.isnan(FaceElemConn[i])): continue</span>
        <span class="c1">#         ElemNeighbors[FaceElemConn[i][0]].add(FaceElemConn[i][1])</span>
        <span class="c1">#         ElemNeighbors[FaceElemConn[i][1]].add(FaceElemConn[i][0])</span>
        <span class="c1">#     ElemNeighbors = [list(s) for s in ElemNeighbors] </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid mode. Must be &quot;edge&quot; or &quot;face&quot;.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ElemNeighbors</span></div>


<div class="viewcode-block" id="getConnectedNodes">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.getConnectedNodes.html#mymesh.utils.getConnectedNodes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getConnectedNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">NodeNeighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">BarrierNodes</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies groups of connected nodes. For a fully </span>
<span class="sd">    connected mesh, a single region will be identified</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list of lists</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list of lists</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    NodeNeighbors : list, optional</span>
<span class="sd">        List of neighboring nodes for each node in NodeCoords. The default is </span>
<span class="sd">        None. If no value is provided, it will be computed with getNodeNeighbors</span>
<span class="sd">    BarrierNodes : set, optional</span>
<span class="sd">        Set of nodes that can separate regions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeRegions : list of sets</span>
<span class="sd">        Each set in the list contains a region of connected nodes. Sorted by </span>
<span class="sd">        size of region such that the region with the most nodes is first in </span>
<span class="sd">        the list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">NodeRegions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">NodeNeighbors</span><span class="p">:</span> <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">BarrierNodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">BarrierNodes</span> <span class="k">else</span> <span class="n">n</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">)]</span>
    <span class="n">NeighborSets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">]</span>
    <span class="n">AllNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)))</span>
    <span class="n">DetachedNodes</span> <span class="o">=</span> <span class="n">AllNodes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])))</span>
    <span class="n">todo</span> <span class="o">=</span> <span class="n">AllNodes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">DetachedNodes</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">BarrierNodes</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">region</span> <span class="o">=</span> <span class="p">{</span><span class="n">seed</span><span class="p">}</span>
        <span class="n">new</span> <span class="o">=</span> <span class="p">{</span><span class="n">seed</span><span class="p">}</span>
        <span class="n">nOld</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nCurrent</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">nOld</span> <span class="o">!=</span> <span class="n">nCurrent</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">nOld</span> <span class="o">=</span> <span class="n">nCurrent</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">old</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">NeighborSets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">new</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
            <span class="n">region</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="n">nCurrent</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">todo</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">NodeRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
    <span class="n">NodeRegions</span> <span class="o">=</span> <span class="p">[</span><span class="n">NodeRegions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">NodeRegions</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">NodeRegions</span>  </div>


<div class="viewcode-block" id="getConnectedElements">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.getConnectedElements.html#mymesh.utils.getConnectedElements">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getConnectedElements</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">ElemNeighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span><span class="n">BarrierElems</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies groups of connected nodes. For a fully </span>
<span class="sd">    connected mesh, a single region will be identified</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list of lists</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list of lists</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    ElemNeighbors : list, optional</span>
<span class="sd">        List of neighboring elements for each element in NodeConn. The default is </span>
<span class="sd">        None. If no value is provided, it will be computed with getNodeNeighbors</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        Connectivity method to be used for getElemNeighbors. The default is &#39;edge&#39;.</span>
<span class="sd">    BarrierElems : set, optional</span>
<span class="sd">        Set of barrier elements that the connected region cannot move past. </span>
<span class="sd">        They can be included in a region, but will not connect to their neighbors</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ElemRegions : list of sets</span>
<span class="sd">        Each set in the list contains a region of connected nodes. Sorted by </span>
<span class="sd">        size of region such that the region with the most nodes is first in </span>
<span class="sd">        the list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ElemRegions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ElemNeighbors</span><span class="p">:</span> <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">getElemNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">BarrierElems</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">BarrierElems</span> <span class="k">else</span> <span class="n">e</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ElemNeighbors</span><span class="p">)]</span>
    <span class="n">NeighborSets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">]</span>

    <span class="n">todo</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">BarrierElems</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">region</span> <span class="o">=</span> <span class="p">{</span><span class="n">seed</span><span class="p">}</span>
        <span class="n">new</span> <span class="o">=</span> <span class="p">{</span><span class="n">seed</span><span class="p">}</span>
        <span class="n">nOld</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nCurrent</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">nOld</span> <span class="o">!=</span> <span class="n">nCurrent</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">nOld</span> <span class="o">=</span> <span class="n">nCurrent</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">old</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">NeighborSets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">new</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
            <span class="n">region</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="n">nCurrent</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">todo</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">ElemRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
    <span class="n">ElemRegions</span> <span class="o">=</span> <span class="p">[</span><span class="n">ElemRegions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">ElemRegions</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">ElemRegions</span>  </div>


<div class="viewcode-block" id="Centroids">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.Centroids.html#mymesh.utils.Centroids">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">Centroids</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate element centroids.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        List of nodal connectivities.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    centroids : list</span>
<span class="sd">        list of element centroids.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ArrayConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
        <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">ArrayConn</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
    <span class="n">Points</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">ArrayConn</span><span class="p">]</span>
    <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">centroids</span></div>

    
<div class="viewcode-block" id="CalcFaceNormal">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.CalcFaceNormal.html#mymesh.utils.CalcFaceNormal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">CalcFaceNormal</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates normal vectors on the faces of a triangular </span>
<span class="sd">    surface mesh. Assumes triangles are in counter-clockwise when viewed from the outside</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    SurfConn : list</span>
<span class="sd">        Nodal connectivity list of a triangular surface mesh.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ElemNormals list</span>
<span class="sd">        List of element surface normals .</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">TriConn</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">surf2tris</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">,</span> <span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">TriConn</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">check_numba</span><span class="p">():</span>
        <span class="n">TriNormals</span> <span class="o">=</span> <span class="n">_tri_normals</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:]</span><span class="o">-</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,:]</span><span class="o">-</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">Nx</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Ny</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Nz</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">TriNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">N</span><span class="p">)),</span> <span class="n">where</span><span class="o">=</span><span class="n">d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">),</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">ElemNormals</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">TriNormals</span><span class="p">)</span>
    <span class="n">ElemNormals</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">inv</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ElemNormals</span></div>


<span class="nd">@try_njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_tri_normals</span><span class="p">(</span><span class="n">Tris</span><span class="p">):</span>
    
    <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">Tris</span><span class="p">),</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">tri</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Tris</span><span class="p">):</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">tri</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">tri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">Nx</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Ny</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Nz</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Ny</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Nz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ElemNormals</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Nx</span><span class="o">/</span><span class="n">norm</span>
            <span class="n">ElemNormals</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ny</span><span class="o">/</span><span class="n">norm</span>
            <span class="n">ElemNormals</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Nz</span><span class="o">/</span><span class="n">norm</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ElemNormals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ElemNormals</span>

<div class="viewcode-block" id="Face2NodeNormal">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.Face2NodeNormal.html#mymesh.utils.Face2NodeNormal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">Face2NodeNormal</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">ElemNormals</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;Angle&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate node normal vectors based on the element face normals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    ElemConn : list</span>
<span class="sd">        List of elements connected to each node.</span>
<span class="sd">    ElemNormals : list</span>
<span class="sd">        List of element normal vectors.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Method used to determine node normals. The default is &#39;Angle&#39;.</span>

<span class="sd">        - Angle - performs an angle weighted average of connected element normals :cite:p:`Thurrner1998`</span>
<span class="sd">        - Average - performs a simple averaging of connected element normals</span>
<span class="sd">        - MostVisible - determines the most visible normal :cite:p:`Aubry2008a`</span>
<span class="sd">        - MostVisible_Loop - non-vectorized version of MostVisible, slower but more readable</span>
<span class="sd">        - MostVisible_Iter - iterative method for determining the most visible normal :cite:p:`Aubry2008a`</span>

<span class="sd">        MostVisible_Loop and MostVisible_Iter are included for completeness, but in</span>
<span class="sd">        general, MostVisible should be used instead.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeNormals : list</span>
<span class="sd">        Unit normal vectors for each node.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">):</span>
        <span class="c1"># Based on: Grit Thürrner &amp; Charles A. Wüthrich (1998)</span>
        <span class="c1"># Perform angle weighted average to compute vertex normals</span>
        <span class="c1"># Calculate the angles to use as weight</span>

        <span class="c1"># Cast ElemConn into a rectangular matrix</span>
        <span class="c1"># Warning: This code is very vectorized - it might be difficult to debug</span>
        <span class="n">NodeSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">NodeSet</span><span class="p">:</span>
            <span class="n">NodeSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">NodeSet</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="n">NodeSet</span><span class="p">]</span>
        <span class="n">Mask0</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">Masknan</span> <span class="o">=</span> <span class="n">Mask0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">Masknan</span><span class="p">[</span><span class="n">Mask0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
        <span class="n">Ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">ElemNormals</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])[</span><span class="n">R</span><span class="p">]</span>

        <span class="n">RNodeConn</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ArrayConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">RNodeConn</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">RNodeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)])</span>
        <span class="n">IncidentNodes</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArrayCoords</span><span class="p">[</span><span class="n">IncidentNodes</span><span class="p">]</span><span class="o">-</span><span class="n">ArrayCoords</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:])</span>
        <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># For each node and for each incident element on that node, dot product of the two edges of the element that meet at the node</span>
        <span class="n">dots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Mask0</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># For each node and for each incident element on that node, the product of the norms of the two edges of the element that meet at the node</span>
        <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># cos(alpha) = dot(u,v)/(norm(u)*norm(v))</span>
        <span class="n">cosAlpha</span> <span class="o">=</span> <span class="n">dots</span><span class="o">/</span><span class="n">norms</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">),</span> <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="n">cosAlpha</span><span class="o">&gt;=-</span><span class="mi">1</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">cosAlpha</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">Masknan</span>

        <span class="n">sumAlphaN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">alpha</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Ns</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span> <span class="o">=</span> <span class="n">sumAlphaN</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sumAlphaN</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>

    <span class="k">elif</span> <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Cast ElemConn into a rectangular matrix</span>
        <span class="n">NodeSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="n">NodeSet</span><span class="p">]</span>
        <span class="n">Ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ElemNormals</span><span class="p">,[[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="n">R</span><span class="p">]</span>
        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span> <span class="o">=</span> <span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;MostVisible&#39;</span><span class="p">:</span>
        
        <span class="c1"># Note: this code uses dot(Ni,Nj) as a surrogate for radius; since Ni,Nj are both unit vectors</span>
        <span class="c1"># cos(theta) = dot(Ni,Nj) -&gt; theta = arccos(dot(Ni,Nj)). Since arccos is a monotonically </span>
        <span class="c1"># decreasing function, if dot(Ni,Nj) &lt; dot(Ni,Nk), then rij &gt; rik</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e-8</span>
        <span class="n">NodeSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">NodeSet</span><span class="p">:</span>
            <span class="n">NodeSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">NodeSet</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">R</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Handling for case where no nodes have more than 2 connected elements</span>
            <span class="n">tempR</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
            <span class="n">tempR</span><span class="p">[:,:</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">R</span><span class="p">)[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">R</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">tempR</span>
        <span class="n">Ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">ElemNormals</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])[</span><span class="n">R</span><span class="p">]</span>

        <span class="c1"># 2 Point Circles</span>
        <span class="n">scalmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">Combos2</span> <span class="o">=</span> <span class="n">Ns</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">][:,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Ns</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="mi">2</span><span class="p">)))]</span>
        <span class="n">Nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Combos2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Nb</span> <span class="o">=</span> <span class="n">Nb</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nb</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">scal2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Nb</span> <span class="o">*</span> <span class="n">Combos2</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># 3 Point Circles</span>
        <span class="n">Combos3</span> <span class="o">=</span> <span class="n">Ns</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">][:,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Ns</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="mi">3</span><span class="p">)))]</span>
        <span class="n">Ni</span> <span class="o">=</span> <span class="n">Combos3</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">Nj</span> <span class="o">=</span> <span class="n">Combos3</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="n">Nk</span> <span class="o">=</span> <span class="n">Combos3</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">,:]</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">,</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">Nc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="n">Nk</span><span class="p">,</span><span class="n">Nj</span><span class="o">-</span><span class="n">Nk</span><span class="p">))</span><span class="o">/</span><span class="n">denom</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">Nk</span>
            <span class="n">Nc</span> <span class="o">=</span> <span class="n">Nc</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Nc</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]</span>
            <span class="n">scal3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Nc</span><span class="o">*</span><span class="n">Ni</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">Nc</span><span class="p">[</span><span class="n">scal3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Nc</span><span class="p">[</span><span class="n">scal3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">scal3</span><span class="p">[</span><span class="n">scal3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">scal3</span><span class="p">[</span><span class="n">scal3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">scal23</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">scal2</span><span class="p">,</span><span class="n">scal3</span><span class="p">])</span>
        <span class="n">Nbc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Nb</span><span class="p">,</span><span class="n">Nc</span><span class="p">])</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;lij,ljk-&gt;lik&#39;</span><span class="p">,</span> <span class="n">Nbc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">Ns</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="n">scal23</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">scal23</span><span class="p">[</span><span class="n">check</span><span class="p">]</span> <span class="o">=</span> <span class="n">scalmin</span>

        <span class="c1"># Indices of the smallest radius that contains all points</span>
        <span class="n">Idx</span> <span class="o">=</span> <span class="n">scal23</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">scal23</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="c1"># In case of duplicates, only taking the first one</span>
        <span class="n">newIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Idx</span><span class="p">)</span>
        <span class="n">newIdx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Idx</span><span class="p">)),</span> <span class="n">Idx</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Idx</span><span class="p">)),</span> <span class="n">Idx</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>

        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">NodeNormals</span><span class="p">[</span><span class="n">NodeSet</span><span class="p">]</span> <span class="o">=</span> <span class="n">Nbc</span><span class="p">[</span><span class="n">newIdx</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid method: </span><span class="si">{</span><span class="n">method</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># NodeNormals = [[] for i in range(len(NodeCoords))]      # Normal vectors for each vertex</span>
        <span class="c1"># NodeSet = {n for elem in NodeConn for n in elem}</span>
        <span class="c1"># for i in range(len(NodeCoords)):</span>
        <span class="c1">#     if i not in NodeSet:</span>
        <span class="c1">#         NodeNormals[i] = [np.nan,np.nan,np.nan]</span>
        <span class="c1">#         continue</span>
        <span class="c1">#     angles = [0 for j in range(len(ElemConn[i]))]</span>
        <span class="c1">#     elemnormals = [np.array(ElemNormals[elem]) for elem in ElemConn[i]]</span>

        <span class="c1">#     if method == &#39;MostVisible_Loop&#39;:</span>
                
        <span class="c1">#         # This is kept for readability; &#39;MostVisible&#39; is a vectorized equivalent that performs significantly faster</span>
                
        <span class="c1">#         # Note: this code uses dot(Ni,Nj) as a surrogate for radius; since Ni,Nj are both unit vectors</span>
        <span class="c1">#         # cos(theta) = dot(Ni,Nj) -&gt; theta = arccos(dot(Ni,Nj)). Since arccos is a monotonically </span>
        <span class="c1">#         # decreasing function, if dot(Ni,Nj) &lt; dot(Ni,Nk), then rij &gt; rik</span>
        <span class="c1">#         eps = -1e-8</span>
        <span class="c1">#         scalmin = -1</span>
        <span class="c1">#         C = [np.nan,np.nan,np.nan]</span>
        <span class="c1">#         for ii in range(len(elemnormals)-1):</span>
        <span class="c1">#             # Check the 2 point circles</span>
        <span class="c1">#             Ni = np.array(elemnormals[ii])</span>
        <span class="c1">#             for j in range(ii+1,len(elemnormals)):</span>
        <span class="c1">#                 Nj = np.array(elemnormals[j])</span>
        <span class="c1">#                 Nb = Ni+Nj</span>
        <span class="c1">#                 Nb = Nb/np.linalg.norm(Nb)</span>
        <span class="c1">#                 scal = np.dot(Nb,Ni)</span>
        <span class="c1">#                 if scal &lt; scalmin:      </span>
        <span class="c1">#                     pass</span>
        <span class="c1">#                 elif any((np.dot(Nl,Nb) - scal) &lt; eps for Nl in elemnormals):</span>
        <span class="c1">#                     pass</span>
        <span class="c1">#                 else:</span>
        <span class="c1">#                     C = Nb.tolist()</span>
        <span class="c1">#                     scalmin = scal</span>
        <span class="c1">#         for ii in range(len(elemnormals)-2): </span>
        <span class="c1">#             # Check the 3 point circles</span>
        <span class="c1">#             Ni = elemnormals[ii]</span>
        <span class="c1">#             for j in range(ii+1,len(elemnormals)-1):</span>
        <span class="c1">#                 Nj = elemnormals[j]</span>
        <span class="c1">#                 for k in range(j+1,len(elemnormals)):</span>
        <span class="c1">#                     Nk = elemnormals[k]</span>

        <span class="c1">#                     denom = (2*np.linalg.norm(np.cross(Ni-Nk,Nj-Nk))**2) </span>
        <span class="c1">#                     if denom == 0:</span>
        <span class="c1">#                         continue</span>
        <span class="c1">#                     Nc = np.cross(np.linalg.norm(Ni-Nk)**2 * (Nj-Nk) - np.linalg.norm(Nj-Nk)**2 * (Ni-Nk), np.cross(Ni-Nk,Nj-Nk))/denom + Nk</span>
        <span class="c1">#                     nNc = np.linalg.norm(Nc)</span>
        <span class="c1">#                     if nNc == 0:</span>
        <span class="c1">#                         continue</span>
        <span class="c1">#                     Nc = Nc/nNc</span>
                            

        <span class="c1">#                     scal = np.dot(Nc, Ni)</span>
        <span class="c1">#                     if scal &lt; 0:</span>
        <span class="c1">#                         Nc = [-1*n for n in Nc]</span>
        <span class="c1">#                         scal = -scal</span>
        <span class="c1">#                     if scal &lt; scalmin:</span>
        <span class="c1">#                         pass</span>
        <span class="c1">#                     elif any((np.dot(Nl,Nc) - scal) &lt; eps for Nl in elemnormals):</span>
        <span class="c1">#                         pass   </span>
        <span class="c1">#                     else:</span>
        <span class="c1">#                         C = Nc</span>
        <span class="c1">#                         scalmin = scal</span>
        <span class="c1">#         NodeNormals[i] = C    </span>
        <span class="c1">#         if np.any(np.isnan(C)):</span>
        <span class="c1">#             print(i)</span>
                
        <span class="c1">#     elif method == &#39;MostVisible_Iter&#39;:</span>
                
        <span class="c1">#         conv = 1e-3</span>
        <span class="c1">#         beta = 0.5</span>
                
        <span class="c1">#         # Initial weights</span>
        <span class="c1">#         ws = [1/len(elemnormals) for i in range(len(elemnormals))]</span>
        <span class="c1">#         # Compute initial guess normal</span>
        <span class="c1">#         Sp = sum([w*n for w,n in zip(ws,elemnormals)])</span>
        <span class="c1">#         Np = Sp/np.linalg.norm(Sp)</span>
                
        <span class="c1">#         k = 0</span>
        <span class="c1">#         thinking = True</span>
        <span class="c1">#         while thinking:</span>
        <span class="c1">#             k+=1</span>
        <span class="c1">#             alphas = [np.arccos(np.clip(np.dot(Np,Ni),-1,1)) for Ni in elemnormals]</span>
        <span class="c1">#             Salpha = sum(alphas)</span>
        <span class="c1">#             if Salpha == 0:</span>
        <span class="c1">#                 thinking = False</span>
        <span class="c1">#             else:</span>
        <span class="c1">#                 ws = [w*alpha/Salpha for w,alpha in zip(ws,alphas)]</span>
        <span class="c1">#                 Sw = sum(ws)</span>
        <span class="c1">#                 ws = [w/Sw for w in ws]</span>
        <span class="c1">#                 Spnew = sum([w*n for w,n in zip(ws,elemnormals)])</span>
        <span class="c1">#                 if np.linalg.norm(Spnew) == 0:</span>
        <span class="c1">#                     print(&#39;merp3&#39;)</span>
        <span class="c1">#                 Npnew = Spnew/np.linalg.norm(Spnew)</span>
                        
        <span class="c1">#                 # Relax</span>
        <span class="c1">#                 Nprel = beta*Npnew + (1-beta)*Np</span>
        <span class="c1">#                 if np.linalg.norm(Np-Nprel) &lt; conv or k &gt; 100:</span>
        <span class="c1">#                     thinking = False</span>
        <span class="c1">#                 Np = Nprel</span>
        <span class="c1">#         if any(np.isnan(Np)) and len(elemnormals)&gt;0:</span>
        <span class="c1">#             merp = 2</span>
        <span class="c1">#         NodeNormals[i] = Np.tolist()</span>
    <span class="k">return</span> <span class="n">NodeNormals</span></div>


<div class="viewcode-block" id="BaryTri">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.BaryTri.html#mymesh.utils.BaryTri">[docs]</a>
<span class="nd">@try_njit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">BaryTri</span><span class="p">(</span><span class="n">Nodes</span><span class="p">,</span> <span class="n">Pt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the bary centric coordinates of a point (Pt) relative to </span>
<span class="sd">    a triangle (Nodes)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Nodes : np.ndarray</span>
<span class="sd">        List of coordinates of the triangle vertices.</span>
<span class="sd">    Pt : np.ndarray</span>
<span class="sd">        Coordinates of the point.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alpha : float</span>
<span class="sd">        First barycentric coordinate.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Second barycentric coordinate.</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Third barycentric coordinate.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">Pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Pt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">BA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
    <span class="c1"># CB = np.subtract(C,B)</span>
    <span class="c1"># AC = np.subtract(A,C)</span>
    <span class="n">CA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>    
    <span class="n">BABA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">BA</span><span class="p">,</span> <span class="n">BA</span><span class="p">)</span>
    <span class="n">BACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">BA</span><span class="p">,</span> <span class="n">CA</span><span class="p">)</span>
    <span class="n">CACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">CA</span><span class="p">,</span> <span class="n">CA</span><span class="p">)</span>
    <span class="n">PABA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Pt</span><span class="p">,</span><span class="n">A</span><span class="p">),</span> <span class="n">BA</span><span class="p">)</span>
    <span class="n">PACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Pt</span><span class="p">,</span><span class="n">A</span><span class="p">),</span> <span class="n">CA</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">BABA</span> <span class="o">*</span> <span class="n">CACA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span> <span class="n">BACA</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span><span class="n">CACA</span> <span class="o">*</span> <span class="n">PABA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span> <span class="n">PACA</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">BABA</span> <span class="o">*</span> <span class="n">PACA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span> <span class="n">PABA</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">gamma</span> <span class="o">-</span> <span class="n">beta</span>
    
    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span></div>


<div class="viewcode-block" id="BaryTris">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.BaryTris.html#mymesh.utils.BaryTris">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">BaryTris</span><span class="p">(</span><span class="n">Tris</span><span class="p">,</span> <span class="n">Pt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the barycentric coordinates of a point or points relative to </span>
<span class="sd">    a triangle. This can either compare a set of n triangles to a single point, </span>
<span class="sd">    or pairwise comparison between n triangles and n points. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Tris : array_like</span>
<span class="sd">        nx3x3 coordinates of the vertices. The array should be formatted as if</span>
<span class="sd">        obtained by indexing NodeCoords[NodeConn] for a purely triangular mesh.</span>
<span class="sd">    Pt : array_like</span>
<span class="sd">        Coordinates of the point or points. For a single point, this should have</span>
<span class="sd">        the a shape = (3,), for a set of points, this should have a shape = (n,3)</span>
<span class="sd">        where n is equal to the number of triangles. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alpha : float</span>
<span class="sd">        First barycentric coordinate.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Second barycentric coordinate.</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Third barycentric coordinate.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">Tris</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">Tris</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">Tris</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">BA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
    <span class="c1"># CB = np.subtract(C,B)</span>
    <span class="c1"># AC = np.subtract(A,C)</span>
    <span class="n">CA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>    
    <span class="n">BABA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">BA</span><span class="o">*</span><span class="n">BA</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">BACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">BA</span><span class="o">*</span><span class="n">CA</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">CACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">CA</span><span class="o">*</span><span class="n">CA</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">PABA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Pt</span><span class="p">,</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">BA</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">PACA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Pt</span><span class="p">,</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">CA</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">BABA</span> <span class="o">*</span> <span class="n">CACA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span><span class="n">BACA</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span><span class="n">CACA</span> <span class="o">*</span> <span class="n">PABA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span> <span class="n">PACA</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">BABA</span> <span class="o">*</span> <span class="n">PACA</span> <span class="o">-</span> <span class="n">BACA</span> <span class="o">*</span> <span class="n">PABA</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">gamma</span> <span class="o">-</span> <span class="n">beta</span><span class="p">;</span>    
    
    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span></div>


<div class="viewcode-block" id="BaryTet">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.BaryTet.html#mymesh.utils.BaryTet">[docs]</a>
<span class="nd">@try_njit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">BaryTet</span><span class="p">(</span><span class="n">Nodes</span><span class="p">,</span> <span class="n">Pt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the bary centric coordinates of a point (Pt) relative to </span>
<span class="sd">    a tetrahedron (Nodes)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Nodes : list</span>
<span class="sd">        List of coordinates of the tetrahedral vertices.</span>
<span class="sd">    Pt : list</span>
<span class="sd">        Coordinates of the point.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alpha : float</span>
<span class="sd">        First barycentric coordinate.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Second barycentric coordinate.</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Third barycentric coordinate.</span>
<span class="sd">    delta : float</span>
<span class="sd">        Fourth barycentric coordinate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">Nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
         <span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
         <span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">D</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
         <span class="p">])</span>
    
    <span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Pt</span><span class="p">,</span><span class="n">D</span><span class="p">))</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">+</span> <span class="n">gamma</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">delta</span></div>


<div class="viewcode-block" id="Project2Surface">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.Project2Surface.html#mymesh.utils.Project2Surface">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">Project2Surface</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">Normals</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="n">Octree</span><span class="o">=</span><span class="s1">&#39;generate&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Projects a node along its normal vector onto a surface. Returns the index of </span>
<span class="sd">    the element (elemID) that contains the projected node and the barycentric </span>
<span class="sd">    coordinates (alpha, beta, gamma) of that projection within that element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Point : list or np.ndarray</span>
<span class="sd">        Coordinates of the point to be projected on to the surface.</span>
<span class="sd">    Normal : list or np.ndarray</span>
<span class="sd">        Vector along which the point will be projected.</span>
<span class="sd">    NodeCoords : list or np.ndarray</span>
<span class="sd">        Node coordinates list of the mesh that the point is being projected to.</span>
<span class="sd">    SurfConn : list or np.ndarray</span>
<span class="sd">        Nodal connectivity of the surface mesh that the point is being projected to.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance value, if the projection distance is greater than tol, the projection will be exculded, default is np.inf</span>
<span class="sd">        Octree : str (or tree.OctreeNode), optional</span>
<span class="sd">        octree options. An octree representation of the surface can significantly</span>
<span class="sd">        improve mapping speeds, by default &#39;generate&#39;.</span>
<span class="sd">        &#39;generate&#39; - Will generate an octree for use in surface mapping.</span>
<span class="sd">        &#39;none&#39; or None - Won&#39;t generate an octree and will use a brute force approach.</span>
<span class="sd">        tree.OctreeNode - Provide a precompute octree structure corresponding to the surface mesh. Should be created by tree.Surface2Octree(NodeCoords,SurfConn)</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MappingMatrix : np.ndarray</span>
<span class="sd">        nx4 array consisting of the element ID (in SurfConn) and three barycentric coordinates (alpha, beta, gamma) for each point in Points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">)</span>

    <span class="n">intersections</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">intersectionPts</span> <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">RaysSurfIntersection</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span> <span class="n">Normals</span><span class="p">,</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">,</span> <span class="n">Octree</span><span class="o">=</span><span class="n">Octree</span><span class="p">)</span>

    <span class="n">argmindist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">]</span>
    <span class="n">mindist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">argmindist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">)])</span>
    
    <span class="n">elemID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">intersections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">argmindist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">)])</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">intersectionPts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">argmindist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">)])</span>

    <span class="n">mappedbool</span> <span class="o">=</span> <span class="p">(</span><span class="n">elemID</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mindist</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span>
    <span class="n">alphas</span><span class="p">,</span> <span class="n">betas</span><span class="p">,</span> <span class="n">gammas</span> <span class="o">=</span> <span class="n">BaryTris</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">SurfConn</span><span class="p">[</span><span class="n">elemID</span><span class="p">[</span><span class="n">mappedbool</span><span class="p">]]],</span> <span class="n">ps</span><span class="p">[</span><span class="n">mappedbool</span><span class="p">,:])</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">))</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">))</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">))</span>

    <span class="n">alpha</span><span class="p">[</span><span class="n">mappedbool</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphas</span>
    <span class="n">beta</span><span class="p">[</span><span class="n">mappedbool</span><span class="p">]</span> <span class="o">=</span> <span class="n">betas</span>
    <span class="n">gamma</span><span class="p">[</span><span class="n">mappedbool</span><span class="p">]</span> <span class="o">=</span> <span class="n">gammas</span>

    <span class="n">MappingMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">elemID</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">MappingMatrix</span></div>


<div class="viewcode-block" id="SurfMapping">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.SurfMapping.html#mymesh.utils.SurfMapping">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">SurfMapping</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">,</span> <span class="n">NodeCoords2</span><span class="p">,</span> <span class="n">SurfConn2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Octree</span><span class="o">=</span><span class="s1">&#39;generate&#39;</span><span class="p">,</span> <span class="n">return_octree</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a mapping matrix from to map data from one surface to another using</span>
<span class="sd">    barycentric interpolation.  Each row of the mapping matrix contains an </span>
<span class="sd">    element ID followed by barycentric coordinates alpha, beta, gamma  that </span>
<span class="sd">    define the position of the nodes of surface 1 (NodeCoords1) relative to the </span>
<span class="sd">    specified surface element of surface 2 (SurfConn2). An element ID of -1 </span>
<span class="sd">    indicates a failed mapping.</span>
<span class="sd">    NOTE: Only triangular surface meshes are supported.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords1 : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    SurfConn1 : list</span>
<span class="sd">        List of nodal connectivities.</span>
<span class="sd">    NodeCoords2 : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    SurfConn2 : list</span>
<span class="sd">        List of nodal connectivities.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance value, if the projection distance is greater than tol, the projection will be exculded, default is np.inf</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        If true, will print mapping statistics, by default False.</span>
<span class="sd">    Octree : str (or tree.OctreeNode), optional</span>
<span class="sd">        octree options. An octree representation of surface 2 can significantly</span>
<span class="sd">        improve mapping speeds, by default &#39;generate&#39;.</span>
<span class="sd">        &#39;generate&#39; - Will generate an octree for use in surface mapping.</span>
<span class="sd">        &#39;none&#39; or None - Won&#39;t generate an octree and will use a brute force approach.</span>
<span class="sd">        tree.OctreeNode - Provide a precompute octree structure corresponding to surface 2. Should be created by tree.Surface2Octree(NodeCoords2,SurfConn2)</span>
<span class="sd">    return_octree : bool, optional</span>
<span class="sd">        If true, will return the generated or provided octree, by default False.</span>
<span class="sd">    npts : int, optional</span>
<span class="sd">        Number of points to map. A random sample of min(npts, len(NodeCoords1)) from Surface 1</span>
<span class="sd">        will be mapped , by default np.inf (all points).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MappingMatrix : list</span>
<span class="sd">        min(npts, len(NodeCoords1))x4 matrix of of barycentric coordinates, defining NodeCoords1 in terms</span>
<span class="sd">        of the triangular surface elements of Surface 2.</span>
<span class="sd">    Octree : tree.OctreeNode, optional</span>
<span class="sd">        The generated or provided octree structure corresponding to Surface 2.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">NodeCoords1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">NodeCoords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">SurfConn1</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">SurfConn1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfConn1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">SurfConn2</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">SurfConn2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfConn2</span><span class="p">)</span>

    <span class="n">Surf1Nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">SurfConn1</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">npts</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Surf1Nodes</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">)</span>
        <span class="n">NodeIds</span> <span class="o">=</span> <span class="n">Surf1Nodes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">npts</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Surf1Nodes</span><span class="p">)),</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">NodeIds</span> <span class="o">=</span> <span class="n">Surf1Nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">assert</span> <span class="n">SurfConn1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">SurfConn2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Currently only triangular surfaces are supported.&#39;</span>

    <span class="n">ElemConn1</span> <span class="o">=</span> <span class="n">getElemConnectivity</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">)</span>
    <span class="n">ElemNormals1</span> <span class="o">=</span> <span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">)</span>
    <span class="n">NodeNormals1</span> <span class="o">=</span> <span class="n">Face2NodeNormal</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">,</span> <span class="n">ElemConn1</span><span class="p">,</span> <span class="n">ElemNormals1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="n">Octree</span> <span class="o">==</span> <span class="s1">&#39;generate&#39;</span><span class="p">:</span> <span class="n">Octree</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">Surface2Octree</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">,</span><span class="n">SurfConn2</span><span class="p">)</span>
    
    <span class="n">MappingMatrix</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">MappingMatrix</span><span class="p">[</span><span class="n">NodeIds</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">Project2Surface</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">[</span><span class="n">NodeIds</span><span class="p">,:],</span> <span class="n">NodeNormals1</span><span class="p">[</span><span class="n">NodeIds</span><span class="p">,:],</span> <span class="n">NodeCoords2</span><span class="p">,</span> <span class="n">SurfConn2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">Octree</span><span class="o">=</span><span class="n">Octree</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="n">failcount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">MappingMatrix</span><span class="p">[</span><span class="n">NodeIds</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.3f}% o</span><span class="s1">f nodes mapped&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeIds</span><span class="p">)</span><span class="o">-</span><span class="n">failcount</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeIds</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">return_octree</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">MappingMatrix</span><span class="p">,</span> <span class="n">Octree</span>
    <span class="k">return</span> <span class="n">MappingMatrix</span></div>


<div class="viewcode-block" id="ValueMapping">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.ValueMapping.html#mymesh.utils.ValueMapping">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ValueMapping</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">,</span> <span class="n">NodeVals1</span><span class="p">,</span> <span class="n">NodeCoords2</span><span class="p">,</span> <span class="n">SurfConn2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">Octree</span><span class="o">=</span><span class="s1">&#39;generate&#39;</span><span class="p">,</span> <span class="n">MappingMatrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_MappingMatrix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_octree</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps nodal values one surface to another. This currently only supports </span>
<span class="sd">    triangluar surface meshes</span>
<span class="sd">    TODO: Multi-value mapping may produce errors - need to better verify.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords1 : List of lists</span>
<span class="sd">        Contains coordinates for each node in surface 1. Ex. [[x1,y1,z1],...]</span>
<span class="sd">    SurfConn1 : List of lists</span>
<span class="sd">        Contains the nodal connectivity defining the surface elements.</span>
<span class="sd">    NodeVals1 : List or List of lists</span>
<span class="sd">        Scalar nodal values associated with surface 1. For multiple values: [[x1,x2,x3,...],[y1,y2,y3,...],[z1,z2,z3,...],...]</span>
<span class="sd">    NodeCoords2 : List of lists</span>
<span class="sd">        Contains coordinates for each node in surface 2. Ex. [[x1,y1,z1],...].</span>
<span class="sd">    SurfConn2 : List of lists</span>
<span class="sd">        Contains the nodal connectivity defining the surface elements.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance value, if the projection distance is greater than tol, the projection will be exculded, default is np.inf </span>
<span class="sd">    Octree : str (or tree.OctreeNode), optional</span>
<span class="sd">        octree options. An octree representation of surface 1 can significantly</span>
<span class="sd">        improve mapping speeds, by default &#39;generate&#39;.</span>
<span class="sd">        &#39;generate&#39; - Will generate an octree for use in surface mapping.</span>
<span class="sd">        &#39;none&#39; or None - Won&#39;t generate an octree and will use a brute force approach.</span>
<span class="sd">        tree.OctreeNode - Provide a precompute octree structure corresponding to surface 1. Should be created by tree.Surface2Octree(NodeCoords1,SurfConn1)</span>
<span class="sd">    MappingMatrix : list</span>
<span class="sd">        len(NodeCoords2)x4 matrix of of barycentric coordinates, defining NodeCoords2 in terms</span>
<span class="sd">        of the triangular surface elements of Surface 1.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        If true, will print mapping statistics, by default False.</span>
<span class="sd">    return_MappingMatrix : bool, optional</span>
<span class="sd">        If true, will return MappingMatrix, by default False.</span>
<span class="sd">    return_octree : bool, optional</span>
<span class="sd">        If true, will return generated or provided octree, by defualt False.</span>
<span class="sd">        NOTE if MappingMatrix is provided, the octree structure won&#39;t be generated.</span>
<span class="sd">        In this cases, if Octree=&#39;generate&#39; and return_octree=True, the returned value</span>
<span class="sd">        for octree will simply be the string &#39;generate&#39;.</span>
<span class="sd">    npts : int, optional</span>
<span class="sd">        Number of points to map. Values from Surface 1 will be mapped to random sample of </span>
<span class="sd">        min(npts, len(NodeCoords2) in Surface 2, by default np.inf (all points).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeVals2 : List</span>
<span class="sd">        Scalar nodal values associated with surface 2, mapped from surface 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># if type(NodeVals1[0]) is list or type(NodeVals1[0]) is np.ndarray:</span>
    <span class="c1">#     singleVal = False</span>
    <span class="c1">#     # NodeVals2 = [[0 for j in range(len(NodeCoords2))] for i in range(len(NodeVals1))]</span>
    <span class="c1"># else:</span>
    <span class="c1">#     singleVal = True</span>
        <span class="c1"># NodeVals2 = [0 for i in range(len(NodeCoords2))]</span>
    <span class="c1"># Map the coordinates from surface 2 to surface 1</span>
    <span class="k">if</span> <span class="n">MappingMatrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">MappingMatrix</span><span class="p">,</span><span class="n">Octree</span> <span class="o">=</span> <span class="n">SurfMapping</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">,</span> <span class="n">SurfConn2</span><span class="p">,</span> <span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">SurfConn1</span><span class="p">,</span> <span class="n">Octree</span><span class="o">=</span><span class="n">Octree</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">return_octree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="n">npts</span><span class="p">)</span>

    <span class="c1"># if singleVal:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># 1D data</span>
        <span class="n">_NodeVals1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># ND data</span>
        <span class="n">_NodeVals1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">2</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">3</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="c1"># NodeVals2 = np.nan*np.ones(np.shape(NodeVals1))</span>
    <span class="n">elemID</span> <span class="o">=</span> <span class="n">MappingMatrix</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">ArrayConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SurfConn1</span><span class="p">,[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">NodeVals2</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">_NodeVals1</span><span class="p">[</span><span class="n">ArrayConn</span><span class="p">[</span><span class="n">elemID</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> \
            <span class="n">beta</span><span class="o">*</span><span class="n">_NodeVals1</span><span class="p">[</span><span class="n">ArrayConn</span><span class="p">[</span><span class="n">elemID</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> \
            <span class="n">gamma</span><span class="o">*</span><span class="n">_NodeVals1</span><span class="p">[</span><span class="n">ArrayConn</span><span class="p">[</span><span class="n">elemID</span><span class="p">][:,</span><span class="mi">2</span><span class="p">]]</span>
        
            
    <span class="k">if</span> <span class="n">return_MappingMatrix</span> <span class="ow">and</span> <span class="n">return_octree</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeVals2</span><span class="p">,</span> <span class="n">MappingMatrix</span><span class="p">,</span> <span class="n">Octree</span>
    <span class="k">elif</span> <span class="n">return_MappingMatrix</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeVals2</span><span class="p">,</span> <span class="n">MappingMatrix</span>
    <span class="k">elif</span> <span class="n">return_octree</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeVals2</span><span class="p">,</span> <span class="n">Octree</span>
    <span class="k">return</span> <span class="n">NodeVals2</span></div>


<div class="viewcode-block" id="DeleteDuplicateNodes">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.DeleteDuplicateNodes.html#mymesh.utils.DeleteDuplicateNodes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove nodes that are duplicated in the mesh, either at exactly the same location as another node or a distance &lt; tol apart. Nodes are renumbered and elements reconnected such that the geometry and structure</span>
<span class="sd">    of the mesh remains unchanged. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        Contains coordinates for each node. Ex. [[x1,y1,z1],...]</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance value to be used when determining if two nodes are the same. The default is 1e-14.</span>
<span class="sd">    return_idx : bool, optional</span>
<span class="sd">        Returns the indices of each row of NodeCoords in the order that they&#39;re sorted place into the new array, by default False.</span>
<span class="sd">    return_inv : bool, optional</span>
<span class="sd">        Returns the indices that reverse the operation, by default False.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NewCoords : list</span>
<span class="sd">        Updated node coordinates without duplicates.</span>
<span class="sd">    NewConn : list </span>
<span class="sd">        Updated node connectivity without duplicate nodes.</span>
<span class="sd">    idx : np.ndarray</span>
<span class="sd">        Array of indices that convert from the original node coordinates to the new node coordinates (NewCoords = [NodeCoords[i] for i in idx])</span>
<span class="sd">    inv : np.ndarray</span>
<span class="sd">        Array of indices that can reverse the operation to convert from the new node coordinates to old node coordinates (NodeCoords = [NewCoords[i] for i in inv]).</span>
<span class="sd">    </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; NodeCoords = [[0.,0.,0.],</span>
<span class="sd">                      [0.,1.,0.],</span>
<span class="sd">                      [1.,1.,0.],</span>
<span class="sd">                      [0.,0.,0.],</span>
<span class="sd">                      [1.,1.,0.],</span>
<span class="sd">                      [1.,0.,0.]]</span>
<span class="sd">    &gt;&gt;&gt; NodeConn = [[0,1,2],[3,4,5]]</span>
<span class="sd">    &gt;&gt;&gt; NewCoords, NewConn, idx, inv = utils.DeleteDuplicateNodes(NodeCoords,NodeConn, return_idx=True,return_inv=True)</span>
<span class="sd">    &gt;&gt;&gt; NewConn</span>
<span class="sd">    [[0, 1, 3], [0, 3, 2]]</span>
<span class="sd">    &gt;&gt;&gt; NewCoords == [NodeCoords[i] for i in idx]</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; NodeCoords == [NewCoords[i] for i in inv]</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_idx</span> <span class="ow">and</span> <span class="n">return_inv</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">elif</span> <span class="n">return_idx</span> <span class="ow">or</span> <span class="n">return_inv</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span>

    <span class="k">if</span> <span class="n">tol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">arrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span><span class="o">/</span><span class="n">tol</span><span class="p">)</span><span class="o">*</span><span class="n">tol</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">unq</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arrayCoords</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">NewCoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="c1"># NodeConn already an array</span>
            <span class="n">NewConn</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">NodeConn</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try to index with NodeConn, assuming it&#39;s rectangular (uniform element type)</span>
                <span class="n">NewConn</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">NodeConn</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># If NodeConn is a ragged list of lists (mixed element types), pad ragged</span>
                <span class="n">tempIds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">NewConn</span> <span class="o">=</span> <span class="n">ExtractRagged</span><span class="p">(</span><span class="n">tempIds</span><span class="p">[</span><span class="n">R</span><span class="p">],</span><span class="n">delval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">NewConn</span> <span class="o">=</span> <span class="n">NodeConn</span>

    <span class="n">returns</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_idx</span><span class="p">,</span> <span class="n">return_inv</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NewConn</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">inv</span><span class="p">))</span> <span class="k">if</span> <span class="n">returns</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">RemoveNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes nodes that aren&#39;t held by any element</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : array_like</span>
<span class="sd">        Node coordinates</span>
<span class="sd">    NodeConn : array_like</span>
<span class="sd">        Node connectivity</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NewNodeCoords : array_like</span>
<span class="sd">        New set of node coordinates where unused nodes have been removed</span>
<span class="sd">    NewNodeConn : array_like</span>
<span class="sd">        Renumbered set of node connectivities to be consistent with NewNodeCoords</span>
<span class="sd">    OriginalIds : np.ndarray</span>
<span class="sd">        The indices the original IDs of the nodes still in the mesh. This can be used</span>
<span class="sd">        to remove entries in associated node data (ex. new_data = old_data[OriginalIds]).</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">NodeConn</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span>
        
    <span class="n">node_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">node_mask</span><span class="p">[</span><span class="n">F</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="n">OriginalIds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">node_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">replace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">replace</span><span class="p">[</span><span class="n">OriginalIds</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">OriginalIds</span><span class="p">))</span>
    
    <span class="n">NewNodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)[</span><span class="n">OriginalIds</span><span class="p">]</span>
    <span class="n">New</span> <span class="o">=</span> <span class="n">replace</span><span class="p">[</span><span class="n">F</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">NewNodeConn</span> <span class="o">=</span> <span class="n">New</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">NodeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Newiter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">New</span><span class="p">)</span>
        <span class="n">NewNodeConn</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">Newiter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)))</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">NewNodeCoords</span><span class="p">,</span> <span class="n">NewNodeConn</span><span class="p">,</span> <span class="n">OriginalIds</span>

<div class="viewcode-block" id="RelabelNodes">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.RelabelNodes.html#mymesh.utils.RelabelNodes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">RelabelNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">newIds</span><span class="p">,</span><span class="n">faces</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Relabel the nodes in the mesh according to the newIds list</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : array_like</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : array_like</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    newIds : list</span>
<span class="sd">        list of node ids where the new index is located at the old index</span>
<span class="sd">    faces : list, optional</span>
<span class="sd">        list of face elements, that will also be relabel, by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NewCoords : array_like</span>
<span class="sd">        Relabeled of nodal coordinates.</span>
<span class="sd">    NewConn : array_like</span>
<span class="sd">        Relabeled nodal connectivity list.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    
    <span class="n">NewConn</span> <span class="o">=</span> <span class="n">ExtractRagged</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newIds</span><span class="p">,[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">faces</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="n">NewFaces</span> <span class="o">=</span> <span class="n">ExtractRagged</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newIds</span><span class="p">,[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">faces</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">NewFaces</span> <span class="o">=</span> <span class="n">faces</span>
    <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))</span> 
    <span class="n">NewCoords</span><span class="p">[</span><span class="n">newIds</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">faces</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">NewFaces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span> <span class="n">NewConn</span></div>


<div class="viewcode-block" id="DeleteDegenerateElements">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.DeleteDegenerateElements.html#mymesh.utils.DeleteDegenerateElements">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">DeleteDegenerateElements</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span><span class="n">angletol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deletes degenerate elements from a mesh.</span>
<span class="sd">    TODO: Currently only valid for triangles.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        List of nodal connectivities.</span>
<span class="sd">    angletol : float, optional</span>
<span class="sd">        Tolerance value for determining what constitutes a degenerate element, by default 1e-3. Degenerate elements will be those who have an angle greater than or equal to 180-180*angletol (default 179.82 degrees)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        List of nodal connectivities.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Remove elements that have a collapsed edge - i.e. two collinear edges</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">NodeCoords</span>
        <span class="n">NewConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">elem</span><span class="p">))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span> <span class="o">=</span> <span class="n">DeleteDegenerateElements</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewConn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span>
        <span class="k">if</span> <span class="n">angletol</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Change to strict=True&quot;</span><span class="p">)</span>
        
        <span class="n">thetal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">angletol</span> <span class="c1"># Maximum angle threshold </span>
        <span class="k">def</span><span class="w"> </span><span class="nf">do_split</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">EdgeSort</span><span class="p">,</span><span class="n">ConnSort</span><span class="p">,</span><span class="n">AngleSort</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
            
            <span class="n">elem0</span> <span class="o">=</span> <span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">elem1</span> <span class="o">=</span> <span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">NotShared0</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">elem0</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">EdgeSort</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">NotShared1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">elem1</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">EdgeSort</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># Get the node not belonging to the edge</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">AngleSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thetal</span> <span class="ow">and</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">AngleSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thetal</span> <span class="ow">and</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># Both connected elements are degenerate</span>
                <span class="n">NewNode</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NotShared0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">AngleSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thetal</span> <span class="ow">and</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">NewNode</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NotShared0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">AngleSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thetal</span> <span class="ow">and</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">NewNode</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">NotShared1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span>
            
            <span class="n">NewId</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">)</span>
            <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewNode</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">while</span> <span class="n">elem0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">NotShared0</span><span class="p">:</span> <span class="n">elem0</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">+</span><span class="n">elem0</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># cycle the element definition so that it starts with the non-shared node (Might be unnecessarily slow)</span>
                <span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">elem0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">elem0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">NewId</span><span class="p">],[</span><span class="n">elem0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">NewId</span><span class="p">,</span><span class="n">elem0</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span>
            <span class="k">if</span> <span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="k">while</span> <span class="n">elem1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">NotShared1</span><span class="p">:</span> <span class="n">elem1</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">+</span><span class="n">elem1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">elem1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">elem1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">NewId</span><span class="p">],[</span><span class="n">elem1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">NewId</span><span class="p">,</span><span class="n">elem1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span>
            
            <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span> <span class="n">NewConn</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="n">NewConn</span> <span class="o">=</span> <span class="n">NewConn</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">Thinking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">maxiter</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">while</span> <span class="n">Thinking</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">)</span>
            <span class="n">Edges</span><span class="p">,</span> <span class="n">EdgeConn</span><span class="p">,</span> <span class="n">EdgeElem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">return_EdgeConn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">UEdges</span><span class="p">,</span> <span class="n">UIdx</span><span class="p">,</span> <span class="n">UInv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">UEdgeElem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeElem</span><span class="p">)[</span><span class="n">UIdx</span><span class="p">]</span>
            <span class="n">UEdgeConn</span> <span class="o">=</span> <span class="n">UInv</span><span class="p">[</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">)]</span>
            <span class="n">EECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">UEdgeElem</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">EdgeElemConn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">Edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Edges</span><span class="p">);</span> <span class="n">EdgeConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">)</span>
            <span class="n">EdgeVectors</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">Edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">Edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">EdgeLengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">EdgeVectors</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">ElemVectors</span> <span class="o">=</span> <span class="n">EdgeVectors</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>
            <span class="n">ElemLengths</span> <span class="o">=</span> <span class="n">EdgeLengths</span><span class="p">[</span><span class="n">EdgeConn</span><span class="p">]</span>

            <span class="n">OppositeAngles</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ElemLengths</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]),</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]),</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">OppositeAngles</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*-</span><span class="n">ElemVectors</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ElemLengths</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">OppositeAngles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">OppositeAngles</span><span class="p">)</span>

            <span class="n">EdgeOppositeAngles</span> <span class="o">=</span>  <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">OppositeAngles</span>

            <span class="n">sortkey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">EdgeLengths</span><span class="p">[</span><span class="n">UIdx</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">LengthSort</span> <span class="o">=</span> <span class="n">EdgeLengths</span><span class="p">[</span><span class="n">UIdx</span><span class="p">][</span><span class="n">sortkey</span><span class="p">]</span>
            <span class="n">AngleSort</span> <span class="o">=</span> <span class="n">EdgeOppositeAngles</span><span class="p">[</span><span class="n">sortkey</span><span class="p">]</span>
            <span class="n">EdgeSort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">UEdges</span><span class="p">)[</span><span class="n">sortkey</span><span class="p">]</span>
            <span class="n">ConnSort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">EdgeElemConn</span><span class="p">)[</span><span class="n">sortkey</span><span class="p">]</span>

            <span class="n">AbsLargeAngle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">AngleSort</span> <span class="o">&gt;=</span> <span class="n">thetal</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">todo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">AbsLargeAngle</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Splits</span>
            <span class="n">repeat</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">ConnSort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="n">repeat</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
                <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span> <span class="o">=</span> <span class="n">do_split</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">EdgeSort</span><span class="p">,</span><span class="n">ConnSort</span><span class="p">,</span><span class="n">AngleSort</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

            <span class="n">NewConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NewConn</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NewConn</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">)]</span>
            <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">repeat</span><span class="p">:</span>
                <span class="n">Thinking</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Thinking</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span> <span class="o">=</span> <span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span> <span class="o">=</span> <span class="n">DeleteDegenerateElements</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span></div>


<div class="viewcode-block" id="CleanupDegenerateElements">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.CleanupDegenerateElements.html#mymesh.utils.CleanupDegenerateElements">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">CleanupDegenerateElements</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">Type</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">return_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks for elements with degenerate edges and either changes the element type or </span>
<span class="sd">    removes the element depending on how degenerate it is. Elements</span>
<span class="sd">    with less than 3 (for surface meshes) or 4 (for volume meshes) unique nodes will be deleted, others will be reduced (ex. a quad with 3 unique nodes will be converted </span>
<span class="sd">    to a triangle). The ordering of nodes will be kept.</span>

<span class="sd">    This function only changes the mesh of an element in NodeConn has the same node number</span>
<span class="sd">    more than once. For meshes that have two differently numbered nodes at the same </span>
<span class="sd">    location, first use utils.DeleteDuplicateNodes.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : array_like</span>
<span class="sd">        Node coordinates</span>
<span class="sd">    NodeConn : list, array_like</span>
<span class="sd">        Node connectivity</span>
<span class="sd">    Type : str, optional</span>
<span class="sd">        Specifies whether the mesh contains surface elements (tris, quads) or volume</span>
<span class="sd">        elements (tets, hexs, etc.). Must be either &quot;auto&quot;, &quot;surf&quot; or &quot;vol&quot;. If</span>
<span class="sd">        &quot;auto&quot;, Type will be inferred using :func:`identify_type`.</span>
<span class="sd">        By default &quot;auto&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeCoords : array_like</span>
<span class="sd">        Node coordinates (these are simply passed through from the input)</span>
<span class="sd">    NewConn : list, array_like</span>
<span class="sd">        Updated node connectivity </span>
<span class="sd">        idx : np.ndarray</span>
<span class="sd">        Array of indices that convert from the original list of elements IDs to the new list </span>
<span class="sd">        of element IDs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rowunique</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">min_node</span><span class="p">):</span>
        <span class="c1"># based on unutbu&#39;s answer to https://stackoverflow.com/questions/26958233/numpy-row-wise-unique-elements</span>
        <span class="n">PadConn</span> <span class="o">=</span> <span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
    
        <span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PadConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">PadConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">uConn</span> <span class="o">=</span> <span class="n">PadConn</span> <span class="o">+</span> <span class="n">weight</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">uConn</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">uConn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">PadConn</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">uConn</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">PadConn</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>

        
        <span class="n">to_delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uConn</span><span class="o">!=-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_node</span>
        <span class="k">if</span> <span class="n">PadConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">:</span>
            <span class="c1"># Special attention need for degenerate wedge elements</span>
            <span class="n">wedge_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">PadConn</span><span class="o">!=-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
            <span class="n">wedge2tet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">wedge_rows</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uConn</span><span class="o">!=-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">wedge2pyr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">wedge_rows</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uConn</span><span class="o">!=-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">tetints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">uConn</span><span class="p">[</span><span class="n">wedge2tet</span><span class="p">,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Note that the number of possible cases is much less than the maximum 6 digit binary (63) </span>
            <span class="c1"># since unique always keeps the first occurence of a duplicate, and there can only be two &quot;1&quot;s</span>

            <span class="c1"># Cases where a quad face has collapsed make the pyramid degenerate plane, should be removed</span>
            <span class="n">to_delete</span><span class="p">[</span><span class="n">wedge2tet</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">tetints</span><span class="p">,</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">18</span><span class="p">))]]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Reordering for proper tets</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2tet</span><span class="p">[</span><span class="n">tetints</span> <span class="o">==</span> <span class="mi">10</span><span class="p">],</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2tet</span><span class="p">[</span><span class="n">tetints</span> <span class="o">==</span> <span class="mi">10</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>    <span class="c1"># node 2, 4 removed</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2tet</span><span class="p">[</span><span class="n">tetints</span> <span class="o">==</span> <span class="mi">12</span><span class="p">],</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2tet</span><span class="p">[</span><span class="n">tetints</span> <span class="o">==</span> <span class="mi">12</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>    <span class="c1"># node 2, 3 removed</span>

            <span class="c1"># Okay cases: 3, 5, 6, 17, 24</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">tetints</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">24</span><span class="p">))):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unaccounted for wedge-to-tet case(s) in CleanupDegenerateElements: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tetints</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">tetints</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">24</span><span class="p">))]))</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">. This is a bug, please report.&#39;</span><span class="p">)</span>

            <span class="n">pyrints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">uConn</span><span class="p">[</span><span class="n">wedge2pyr</span><span class="p">,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Pyramids need to be reordered (note case 32 where node 0 is removed never occurs since unique always keeps the first occurence of a duplicate)</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>    <span class="c1"># node 5 removed</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">2</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>    <span class="c1"># node 4 removed</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">4</span><span class="p">],</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">4</span><span class="p">]][:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>    <span class="c1"># node 3 removed</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">8</span><span class="p">],</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">8</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>    <span class="c1"># node 2 removed</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">16</span><span class="p">],</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">wedge2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">16</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># node 1 removed</span>
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">pyrints</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">])):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unaccounted for wedge-to-pyr case(s) in CleanupDegenerateElements: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pyrints</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">pyrints</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">])]))</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">. This is a bug, please report.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">PadConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">:</span>
            <span class="c1"># Special attention need for degenerate hex elements</span>

            <span class="n">hex_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">PadConn</span><span class="o">!=-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span>
            <span class="n">hex2tet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">hex_rows</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uConn</span><span class="o">!=-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">hex2pyr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">hex_rows</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uConn</span><span class="o">!=-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">hex2wdg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">hex_rows</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uConn</span><span class="o">!=-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">tetints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">uConn</span><span class="p">[</span><span class="n">hex2tet</span><span class="p">,</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">pyrints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">,</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">wdgints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">uConn</span><span class="p">[</span><span class="n">hex2wdg</span><span class="p">,</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Wedge cases: TODO: Not all cases accounted for</span>
            <span class="c1"># Case 3 : Face 3 vertical collapse (2==6, 3==7)</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">hex2wdg</span><span class="p">[</span><span class="n">wdgints</span> <span class="o">==</span> <span class="mi">3</span><span class="p">],</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">hex2wdg</span><span class="p">[</span><span class="n">wdgints</span> <span class="o">==</span> <span class="mi">3</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span>
            
            <span class="c1"># Case 9 : Face 4 vertical collapse (0==5, 3==7)</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">hex2wdg</span><span class="p">[</span><span class="n">wdgints</span> <span class="o">==</span> <span class="mi">9</span><span class="p">],</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">hex2wdg</span><span class="p">[</span><span class="n">wdgints</span> <span class="o">==</span> <span class="mi">9</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span>

            <span class="c1"># Case 12 : Face 1 vertical collapse (0==4, 1==5)</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">hex2wdg</span><span class="p">[</span><span class="n">wdgints</span> <span class="o">==</span> <span class="mi">12</span><span class="p">],</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">hex2wdg</span><span class="p">[</span><span class="n">wdgints</span> <span class="o">==</span> <span class="mi">12</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>

            <span class="c1"># Pyramid cases:</span>
            <span class="c1"># Case 112 : Face 0 collapse (0==1==2==3)</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">112</span><span class="p">],</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">112</span><span class="p">]][:,[</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>

            <span class="c1"># Case 76 : Face 1 collapse (0==1==4==5)</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">76</span><span class="p">],</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">76</span><span class="p">]][:,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>

            <span class="c1"># Case 38 : Face 2 collapse (1==2==5==6)</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">38</span><span class="p">],</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">38</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>

            <span class="c1"># Case 25 : Face 4 collapse (0==3==4==7)</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">25</span><span class="p">],</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">25</span><span class="p">]][:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span>

            <span class="c1"># Case 19 : Face 3 collapse (2==3==6==7)</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">19</span><span class="p">],</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">19</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span>

            <span class="c1"># Case 7 : Face 5 collapse (4==5==6==7)</span>
            <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">7</span><span class="p">],</span> <span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="n">hex2pyr</span><span class="p">[</span><span class="n">pyrints</span> <span class="o">==</span> <span class="mi">7</span><span class="p">]][:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">wdgints</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wdgints</span> <span class="o">!=</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wdgints</span> <span class="o">!=</span> <span class="mi">12</span><span class="p">)):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unaccounted for hex-to-wedge case(s) in CleanupDegenerateElements. This is a bug, please report.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">pyrints</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pyrints</span> <span class="o">!=</span> <span class="mi">19</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pyrints</span> <span class="o">!=</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pyrints</span> <span class="o">!=</span> <span class="mi">38</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pyrints</span> <span class="o">!=</span> <span class="mi">76</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pyrints</span> <span class="o">!=</span> <span class="mi">112</span><span class="p">)):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unaccounted for hex-to-pyr case(s) in CleanupDegenerateElements. This is a bug, please report.&#39;</span><span class="p">)</span>
            <span class="c1"># if len(tetints) &gt; 0:</span>
            <span class="c1">#     warnings.warn(f&#39;Unaccounted for hex-to-tet case(s) in CleanupDegenerateElements. This is a bug, please report.&#39;)</span>

        <span class="n">uConn</span> <span class="o">=</span> <span class="n">uConn</span><span class="p">[</span><span class="o">~</span><span class="n">to_delete</span><span class="p">]</span>
        <span class="n">NewConn</span> <span class="o">=</span> <span class="n">ExtractRagged</span><span class="p">(</span><span class="n">uConn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">NewConn</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">to_delete</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">Type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">Type</span> <span class="o">=</span> <span class="n">identify_type</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;surf&#39;</span><span class="p">:</span>
        <span class="n">NewConn</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">rowunique</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">Type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;vol&#39;</span><span class="p">:</span>
        <span class="n">NewConn</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">rowunique</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Type must be &quot;surf&quot; or &quot;vol&quot;, not </span><span class="si">{</span><span class="n">Type</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NewConn</span><span class="p">,</span> <span class="n">idx</span>
    <span class="k">return</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NewConn</span></div>


<div class="viewcode-block" id="MirrorMesh">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.MirrorMesh.html#mymesh.utils.MirrorMesh">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">MirrorMesh</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a mirrored copy of a mesh by mirroring about the planes</span>
<span class="sd">    defined by X=x, Y=y, and Z=z</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        Nodal Coordinates.</span>
<span class="sd">    NodeConn : list</span>
<span class="sd">        Nodal Connectivity.</span>
<span class="sd">    x : float, optional</span>
<span class="sd">        YZ plane at X = x. The default is None.</span>
<span class="sd">    y : float, optional</span>
<span class="sd">        XZ plane at Y = y. The default is None.</span>
<span class="sd">    z : float, optional</span>
<span class="sd">        XY plane at Z = z. The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MirroredCoords : list</span>
<span class="sd">        Mirrored Nodal Coordinates.</span>
<span class="sd">    MirroredConn : list</span>
<span class="sd">        Nodal Connectivity of Mirrored Elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No mirror plane was specified, specify at least one of x, y, or z.&#39;</span><span class="p">)</span>
    <span class="n">MirroredCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">MirroredCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">MirroredCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> 
    <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">MirroredCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">MirroredCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">if</span> <span class="n">z</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">MirroredCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">MirroredCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">z</span> 
    
    <span class="k">return</span> <span class="n">MirroredCoords</span><span class="p">,</span> <span class="n">NodeConn</span></div>

    
<div class="viewcode-block" id="MergeMesh">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.MergeMesh.html#mymesh.utils.MergeMesh">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">MergeMesh</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">NodeConn1</span><span class="p">,</span> <span class="n">NodeCoords2</span><span class="p">,</span> <span class="n">NodeConn2</span><span class="p">,</span> <span class="n">NodeVals1</span><span class="o">=</span><span class="p">[],</span> <span class="n">NodeVals2</span><span class="o">=</span><span class="p">[],</span> <span class="n">cleanup</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge two meshes together</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords1 : list</span>
<span class="sd">        List of nodal coordinates for mesh 1.</span>
<span class="sd">    NodeConn1 : list</span>
<span class="sd">        List of nodal connectivities for mesh 1.</span>
<span class="sd">    NodeCoords2 : list</span>
<span class="sd">        List of nodal coordinates for mesh 2.</span>
<span class="sd">    NodeConn2 : list</span>
<span class="sd">        List of nodal connectivities for mesh 2.</span>
<span class="sd">    NodeVals1 : list, optional</span>
<span class="sd">        List of node data associated with mesh 1, by default []</span>
<span class="sd">    NodeVals2 : list, optional</span>
<span class="sd">        List of node data associated with mesh 2, by default []</span>
<span class="sd">    cleanup : bool, optional</span>
<span class="sd">        If true, duplicate nodes will be deleted and renumbered accordingly, by default True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MergedCoords : list</span>
<span class="sd">        List of nodal coordinates of the merged mesh.</span>
<span class="sd">        Nodes from mesh 1 appear first, followed by those of mesh 2.</span>
<span class="sd">    MergedConn : list</span>
<span class="sd">        List of nodal connectivities of the merged mesh.</span>
<span class="sd">    MergedVals : list, optional</span>
<span class="sd">        If provided, merged list of NodeVals.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">MergeCoords</span> <span class="o">=</span> <span class="n">NodeCoords1</span> <span class="o">+</span> <span class="n">NodeCoords2</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">MergeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">NodeCoords1</span><span class="p">,</span> <span class="n">NodeCoords2</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeConn1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeConn2</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeConn1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeConn2</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># Use vstack if NodeConns are arrays and compatible sizes</span>
        <span class="n">MergeConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">NodeConn1</span><span class="p">,</span> <span class="n">NodeConn2</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Handle as lists</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeConn2</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">NodeConn2</span> <span class="o">=</span> <span class="p">(</span><span class="n">NodeConn2</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">NodeConn2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">node</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NodeConn2</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeConn1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">NodeConn1</span> <span class="o">=</span> <span class="n">NodeConn1</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
        <span class="n">MergeConn</span> <span class="o">=</span> <span class="n">NodeConn1</span> <span class="o">+</span> <span class="n">NodeConn2</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords1</span><span class="p">),</span> <span class="s1">&#39;NodeVals lists must contain the number of entries as nodes.&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeVals2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords2</span><span class="p">),</span> <span class="s1">&#39;NodeVals lists must contain the number of entries as nodes.&#39;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">NodeVals2</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">MergeVals</span> <span class="o">=</span> <span class="n">NodeVals1</span> <span class="o">+</span> <span class="n">NodeVals2</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeVals2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">MergeVals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">NodeVals1</span><span class="p">,</span> <span class="n">NodeVals2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeVals1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeVals2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">MergeVals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">NodeVals1</span><span class="p">,</span> <span class="n">NodeVals2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dimensions of NodeVals1 and NodeVals2 are incompatible&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">cleanup</span><span class="p">:</span>
            <span class="n">MergeCoords</span><span class="p">,</span><span class="n">MergeConn</span><span class="p">,</span><span class="n">inv</span> <span class="o">=</span> <span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">MergeCoords</span><span class="p">,</span><span class="n">MergeConn</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MergeVals</span><span class="p">)):</span>
                <span class="n">MergeVals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">MergeVals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">]</span>
                
            <span class="k">return</span> <span class="n">MergeCoords</span><span class="p">,</span> <span class="n">MergeConn</span><span class="p">,</span> <span class="n">MergeVals</span>
    
    <span class="k">elif</span> <span class="n">cleanup</span><span class="p">:</span>
        <span class="n">MergeCoords</span><span class="p">,</span><span class="n">MergeConn</span> <span class="o">=</span> <span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">MergeCoords</span><span class="p">,</span><span class="n">MergeConn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MergeCoords</span><span class="p">,</span> <span class="n">MergeConn</span></div>

    
<div class="viewcode-block" id="DetectFeatures">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.DetectFeatures.html#mymesh.utils.DetectFeatures">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">DetectFeatures</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">,</span><span class="n">angle</span><span class="o">=</span><span class="mi">25</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classifies nodes as edges or corners if the angle between adjacent</span>
<span class="sd">    surface elements is less than or equal to `angle`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list</span>
<span class="sd">        List of nodal coordinates.</span>
<span class="sd">    SurfConn : list</span>
<span class="sd">        List of nodal connectivities of a surface mesh.</span>
<span class="sd">    angle : float, optional</span>
<span class="sd">        Dihedral angle threshold (in degrees) used to determine whether an edge</span>
<span class="sd">        exists between two adjacent faces, by default 25.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    edges : list</span>
<span class="sd">        list of nodes identified to lie on an edge of the geometry.</span>
<span class="sd">    corners : list</span>
<span class="sd">        list of nodes identified to lie on a corner of the geometry.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        background = primitives.Grid([0,1,0,1,0,1], .02, ElemType=&#39;tet&#39;)</span>
<span class="sd">        S = implicit.TetMesh(implicit.thickenf(implicit.gyroid,1), [0,1,0,1,0,1], .03, background=background)</span>
<span class="sd">        edges, corners = utils.DetectFeatures(S.NodeCoords, S.SurfConn)</span>
<span class="sd">        features = np.zeros(S.NNode)</span>
<span class="sd">        features[edges] = 1</span>
<span class="sd">        features[corners] = 2</span>
<span class="sd">        S.plot(scalars=features, color=&#39;coolwarm&#39;, bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">))</span>
    <span class="n">Edges</span><span class="p">,</span> <span class="n">EdgeConn</span><span class="p">,</span> <span class="n">EdgeElem</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2edges</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">,</span><span class="n">return_EdgeConn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_EdgeElem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">UEdges</span><span class="p">,</span> <span class="n">UIdx</span><span class="p">,</span> <span class="n">UInv</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">edges2unique</span><span class="p">(</span><span class="n">Edges</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">UEdgeElem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EdgeElem</span><span class="p">)[</span><span class="n">UIdx</span><span class="p">]</span>
    <span class="n">UEdgeConn</span> <span class="o">=</span> <span class="n">UInv</span><span class="p">[</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">)]</span>
    <span class="n">EECidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">UEdgeElem</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">EdgeElemConn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">UEdges</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
    <span class="n">EdgeElemConn</span><span class="p">[</span><span class="n">UEdgeConn</span><span class="p">,</span><span class="n">EECidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeConn</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">UEdgeConn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">ConnectedNormals</span> <span class="o">=</span> <span class="n">ElemNormals</span><span class="p">[</span><span class="n">EdgeElemConn</span><span class="p">]</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">quality</span><span class="o">.</span><span class="n">dihedralAngles</span><span class="p">(</span><span class="n">ConnectedNormals</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">ConnectedNormals</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">Abs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">FeatureEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">angles</span> <span class="o">&gt;</span> <span class="n">angle</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">FeatureNodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">FeatureEdges</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">UEdges</span><span class="p">[</span><span class="n">edge</span><span class="p">]]</span>
    <span class="n">unq</span><span class="p">,</span><span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">FeatureNodes</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">corners</span> <span class="o">=</span> <span class="n">unq</span><span class="p">[</span><span class="n">counts</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">unq</span><span class="p">[</span><span class="n">counts</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">edges</span><span class="p">,</span><span class="n">corners</span></div>


<div class="viewcode-block" id="makePyramidLayer">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.makePyramidLayer.html#mymesh.utils.makePyramidLayer">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">makePyramidLayer</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">,</span><span class="n">PyramidHeight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a set of pyramid elements that cover the surface of the voxel mesh. </span>
<span class="sd">    To merge the pyramid layer with the voxel mesh, use :func:`MergeMesh`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : list</span>
<span class="sd">        Contains coordinates for each node in a voxel mesh. Ex. [[x0,y0,z0],...].</span>
<span class="sd">    VoxelConn : List</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">        The voxel mesh is assumed to consist of a set of uniform cubic hexahedral </span>
<span class="sd">        elements.</span>
<span class="sd">    PyramidHeight : float (or None), optional</span>
<span class="sd">        Height of the pyramids. The default is None.</span>
<span class="sd">        If no height as assigned, it will default to 1/2 of the voxel size</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    PyramidCoords : list</span>
<span class="sd">        List of nodal coordinates for the pyramid elements.</span>
<span class="sd">    PyramidConn : list</span>
<span class="sd">        List of nodal connectivities for the pyramid elements.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">PyramidHeight</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">PyramidHeight</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        
    <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2surface</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">)</span>
    <span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">RemoveNodes</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">)</span>
    
    <span class="n">FaceNormals</span> <span class="o">=</span> <span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">)</span>
    <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">)</span>
    <span class="n">PyramidConn</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">))]</span>
    <span class="n">PyramidCoords</span> <span class="o">=</span> <span class="n">SurfCoords</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">face</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">face</span><span class="p">]</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tipCoord</span> <span class="o">=</span> <span class="n">centroid</span> <span class="o">+</span> <span class="n">PyramidHeight</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FaceNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="n">PyramidConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">face</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">PyramidCoords</span><span class="p">)]</span>
        <span class="n">PyramidCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tipCoord</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    
    <span class="k">return</span> <span class="n">PyramidCoords</span><span class="p">,</span> <span class="n">PyramidConn</span></div>


<div class="viewcode-block" id="ErodeVoxel">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.ErodeVoxel.html#mymesh.utils.ErodeVoxel">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ErodeVoxel</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">nLayers</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes the specified number of layers from a hexahedral mesh</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list of lists</span>
<span class="sd">        Contains coordinates for each node in a voxel mesh. Ex. [[x1,y1,z1],...].</span>
<span class="sd">        The mesh is assumed to consist of only hexahedral elements.</span>
<span class="sd">    NodeConn : List of lists</span>
<span class="sd">        Nodal connectivity list.</span>
<span class="sd">    nLayers : int, optional</span>
<span class="sd">        Number of layers to peel. The default is 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    PeeledCoords : List</span>
<span class="sd">        Node coordinates for each node in the peeled mesh.</span>
<span class="sd">    PeeledConn : list</span>
<span class="sd">        Nodal connectivity for each element in the peeled mesh.</span>
<span class="sd">    PeelCoords : list</span>
<span class="sd">        Node coordinates for each node in the layers of the mesh that have</span>
<span class="sd">        been removed.</span>
<span class="sd">    PeelConn : list</span>
<span class="sd">        Nodal connectivity for each element in the layers of the mesh that have</span>
<span class="sd">        been removed.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">NewConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>   
    <span class="n">PeelConn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nLayers</span><span class="p">):</span>
        <span class="n">HexSurfConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2surface</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">)</span>
        <span class="n">SurfNodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">HexSurfConn</span><span class="p">)</span>
        <span class="n">SurfNodeSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">SurfNodes</span><span class="p">)</span>
        <span class="n">PeelConn</span> <span class="o">+=</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NewConn</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">&amp;</span><span class="n">SurfNodeSet</span><span class="p">)]</span>
        <span class="n">NewConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NewConn</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">&amp;</span><span class="n">SurfNodeSet</span><span class="p">)]</span>
    
    <span class="n">PeelCoords</span><span class="p">,</span><span class="n">PeelConn</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">RemoveNodes</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">PeelConn</span><span class="p">)</span>
    <span class="n">PeeledCoords</span><span class="p">,</span><span class="n">PeeledConn</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">RemoveNodes</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">PeeledCoords</span><span class="p">,</span> <span class="n">PeeledConn</span><span class="p">,</span> <span class="n">PeelCoords</span><span class="p">,</span> <span class="n">PeelConn</span></div>


<div class="viewcode-block" id="DilateVoxel">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.DilateVoxel.html#mymesh.utils.DilateVoxel">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">DilateVoxel</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a given voxel mesh, will generate a layer of voxels that</span>
<span class="sd">    wrap around the current voxel mesh. </span>
<span class="sd">    NOTE: This has the potential to create overlapping voxels</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : list of lists</span>
<span class="sd">        Contains coordinates for each node in a voxel mesh. Ex. [[x1,y1,z1],...].</span>
<span class="sd">        The voxel mesh is assumed to consist of a set of uniform cubic hexahedral </span>
<span class="sd">        elements.</span>
<span class="sd">    VoxelConn : List of lists</span>
<span class="sd">        Nodal connectivity list.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    LayerCoords : list</span>
<span class="sd">        New node coordinates.</span>
<span class="sd">    LayerConn : TYPE</span>
<span class="sd">        New node connectivity.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">VoxelSize</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
        
    <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">solid2surface</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">)</span>
    <span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">RemoveNodes</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">)</span>
    
    <span class="n">FaceNormals</span> <span class="o">=</span> <span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">,</span><span class="n">SurfConn</span><span class="p">)</span>
    <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">)</span>
    <span class="n">LayerConn</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">))]</span>
    <span class="n">LayerCoords</span> <span class="o">=</span> <span class="n">SurfCoords</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">face</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">SurfConn</span><span class="p">):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">face</span><span class="p">]</span>
        <span class="n">coord0</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">VoxelSize</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FaceNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">coord1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">VoxelSize</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FaceNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">coord2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">VoxelSize</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FaceNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">coord3</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">VoxelSize</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FaceNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="n">LayerConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">face</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">LayerCoords</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">LayerCoords</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">LayerCoords</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">LayerCoords</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">LayerCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord0</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">LayerCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord1</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">LayerCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord2</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">LayerCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord3</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        
    <span class="k">return</span> <span class="n">LayerCoords</span><span class="p">,</span> <span class="n">LayerConn</span></div>

        
<div class="viewcode-block" id="TriSurfVol">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.TriSurfVol.html#mymesh.utils.TriSurfVol">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">TriSurfVol</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the volume contained within a surface mesh.</span>
<span class="sd">    Based on &#39;Efficient feature extraction for 2D/3D objects in mesh </span>
<span class="sd">    representation.&#39; - Zhang, C. and Chen, T., 2001</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list of lists</span>
<span class="sd">        Contains coordinates for each node. Ex. [[x1,y1,z1],...].</span>
<span class="sd">    SurfConn : List of lists</span>
<span class="sd">        Nodal connectivity list for a triangular surface mesh.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    V : float</span>
<span class="sd">        Volume contained within the surface mesh.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">TriSignedVolume</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> 
                     <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> 
                     <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span>
                     <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> 
                     <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> 
                     <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">TriSignedVolume</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">SurfConn</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">V</span></div>

    
<div class="viewcode-block" id="TetMeshVol">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.TetMeshVol.html#mymesh.utils.TetMeshVol">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">TetMeshVol</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the volume contained within a tetrahedral mesh</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : list of lists</span>
<span class="sd">        Contains coordinates for each node. Ex. [[x1,y1,z1],...].</span>
<span class="sd">    NodeConn : List of lists</span>
<span class="sd">        Nodal connectivity list for a tetrahedral mesh.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    V : float</span>
<span class="sd">        Volume contained within the tetrahedral mesh.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vs</span> <span class="o">=</span> <span class="n">quality</span><span class="o">.</span><span class="n">Volume</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">V</span></div>


<div class="viewcode-block" id="MVBB">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.MVBB.html#mymesh.utils.MVBB">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">MVBB</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span> <span class="n">return_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the minimum volume bounding box of the set of points</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Points : array_like</span>
<span class="sd">        nx3 point coordinates.</span>
<span class="sd">    return_matrix : bool, optional</span>
<span class="sd">        option to return the rotation matrix that aligns the input Points with the local coordinate</span>
<span class="sd">        system of the MVBB, by default False.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mvbb : np.ndarray</span>
<span class="sd">        Coordinates of the corners of the MVBB</span>
<span class="sd">    mat : np.ndarray, optional</span>
<span class="sd">        Rotation matrix that aligns the input Points with the local coordinate</span>
<span class="sd">        system of the MVBB</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="c1"># hull = scipy.spatial.ConvexHull(Points)</span>
    <span class="c1"># hull_points, hull_facets,_ = RemoveNodes(Points, hull.simplices)</span>
    <span class="c1"># hull_points = np.asarray(hull_points)</span>
    <span class="n">hull</span> <span class="o">=</span> <span class="n">delaunay</span><span class="o">.</span><span class="n">ConvexHull</span><span class="p">(</span><span class="n">Points</span><span class="p">)</span>
    <span class="n">hull</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">hull</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">hull</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">RemoveNodes</span><span class="p">(</span><span class="o">*</span><span class="n">hull</span><span class="p">)</span> <span class="c1"># removes nodes that aren&#39;t in the hull</span>

    <span class="c1"># Calculate rotation matrices to align each hull facet with [0,0,-1] (so that it&#39;s rotated to the minimal z plane)</span>
    <span class="n">normals</span> <span class="o">=</span> <span class="n">hull</span><span class="o">.</span><span class="n">ElemNormals</span>
    <span class="n">rot_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">normals</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">rot_axes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">normals</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">rot_axes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">normals</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rot_axes</span> <span class="o">=</span> <span class="n">rot_axes</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rot_axes</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">normals</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">thetas</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">normals</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">outer_prod</span> <span class="o">=</span> <span class="n">rot_axes</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">rot_axes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">cross_prod_matrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">cross_prod_matrices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">rot_axes</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">cross_prod_matrices</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="n">rot_axes</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">cross_prod_matrices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>  <span class="n">rot_axes</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cross_prod_matrices</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">rot_axes</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cross_prod_matrices</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">rot_axes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cross_prod_matrices</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="n">rot_axes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rot_matrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetas</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span><span class="nb">len</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetas</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">cross_prod_matrices</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetas</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">outer_prod</span>

    <span class="c1"># NOTE: might be able to reduce memory usage by not explicitly obtaining the rotation matrices (see https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle)</span>

    <span class="c1"># For each possible rotation, rotate all of the points</span>
    <span class="n">rotated_points</span> <span class="o">=</span> <span class="n">rot_matrices</span> <span class="o">@</span> <span class="n">hull</span><span class="o">.</span><span class="n">NodeCoords</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="c1"># Get the local coordinate system axis-aligned bounding boxes for each rotation</span>
    <span class="n">mins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rotated_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">maxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rotated_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Calculate the box volumes and find the smallest</span>
    <span class="n">side_lengths</span> <span class="o">=</span> <span class="n">maxs</span> <span class="o">-</span> <span class="n">mins</span>
    <span class="n">volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">side_lengths</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">min_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">volumes</span><span class="p">)</span>

    <span class="c1"># Get local coordinates of the MVBB</span>
    <span class="n">rotated_bb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">mins</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="n">min_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                        <span class="p">])</span>
    <span class="c1"># Return the MVBB to the original coordinate system</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">rot_matrices</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>
    <span class="n">mvbb</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="nd">@rotated_bb</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>


    <span class="k">if</span> <span class="n">return_matrix</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mvbb</span><span class="p">,</span> <span class="n">mat</span>
    <span class="k">return</span> <span class="n">mvbb</span></div>


<div class="viewcode-block" id="AABB">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.AABB.html#mymesh.utils.AABB">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">AABB</span><span class="p">(</span><span class="n">Points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the axis-aligned bounding box of a set of points</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Points : array_like</span>
<span class="sd">        nx3 point coordinates.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    aabb : np.ndarray</span>
<span class="sd">        Coordinates of the corners of the AABB</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">mins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">maxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">aabb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">mins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">maxs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">maxs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">mins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">mins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">maxs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">maxs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">mins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">])</span>
    <span class="k">return</span> <span class="n">aabb</span></div>


<div class="viewcode-block" id="SortRaggedByLength">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.SortRaggedByLength.html#mymesh.utils.SortRaggedByLength">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">SortRaggedByLength</span><span class="p">(</span><span class="n">In</span><span class="p">,</span> <span class="n">return_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_inv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_separators</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sorted a ragged list of lists by the length of each sublist</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    In : list</span>
<span class="sd">        List of lists to be sorted</span>
<span class="sd">    return_idx : bool, optional</span>
<span class="sd">        Returns the indices of each row of In in the order that they&#39;re sorted into Out, by default False.</span>
<span class="sd">    return_inv : bool, optional</span>
<span class="sd">        Returns the indices that reverse the sorting operation, by default False.</span>
<span class="sd">    return_separators : bool, optional</span>
<span class="sd">        Returns the indices that separate sections of the list by length. Determining these separators requires a small amount of additional work, by default False. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Out : list</span>
<span class="sd">        List of lists sorted by row length</span>
<span class="sd">    idx : np.ndarray, optional</span>
<span class="sd">        Indices used to reorder In to Out. These are the indices of each row of In in the order that they&#39;re sorted into Out. Returned if return_idx is True.</span>
<span class="sd">    inv : np.ndarray, optional</span>
<span class="sd">        Indices to recover the original List (in) from the output (Out). Return if return_inv us True.</span>
<span class="sd">    separators : np.ndarray, optional</span>
<span class="sd">        Indices of Out that separate sections of the list by length. These separators will always include 0 as the first separator and len(Out) as the last separator. With the exception of the last separator, each separator is the start of a new section and are set such that the sublists of equal-length lists can be accessed by slices with two adjacent separators. </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; In = [[0,1], [2, 3, 4, 5], [6, 7], [8, 9, 10]]</span>
<span class="sd">    &gt;&gt;&gt; Out, idx, inv = utils.SortRaggedByLength(In, return_idx=True, return_inv=True)</span>
<span class="sd">    &gt;&gt;&gt; Out</span>
<span class="sd">    &gt;&gt;&gt; [In[i] for i in idx] == Out</span>
<span class="sd">    &gt;&gt;&gt; [Out[i] for i in inv] == In</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">In</span><span class="p">)))</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">lengths</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">Out</span> <span class="o">=</span> <span class="p">[</span><span class="n">In</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_separators</span><span class="p">:</span>
        <span class="n">separators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">!=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">Out</span><span class="p">)]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">separators</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">return_inv</span><span class="p">:</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> 
        <span class="n">inv</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">returns</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_idx</span><span class="p">,</span> <span class="n">return_inv</span><span class="p">,</span> <span class="n">return_separators</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">returns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">Out</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">separators</span><span class="p">))</span> <span class="k">if</span> <span class="n">returns</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Out</span></div>


<div class="viewcode-block" id="SplitRaggedByLength">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.SplitRaggedByLength.html#mymesh.utils.SplitRaggedByLength">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">SplitRaggedByLength</span><span class="p">(</span><span class="n">In</span><span class="p">,</span> <span class="n">return_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_inv</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split a ragged list of lists into a list of array_like groupings of the original list in which all rows are equal length. The returned list will be the length of the number of unique row lengths of the original list of lists.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    In : list</span>
<span class="sd">        List of lists to be sorted</span>
<span class="sd">    return_idx : bool, optional</span>
<span class="sd">        Returns the indices of each row of In in the order that they&#39;re sorted into Out, by default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Out : list</span>
<span class="sd">        List of array_like groupings of the original list in which all rows are equal length.</span>
<span class="sd">    idx : np.ndarray, optional</span>
<span class="sd">        Indices used to reorder In to Out. These are the indices of each row of In in the order that they&#39;re sorted into Out. Returned if return_idx is True.</span>
<span class="sd">    inv : np.ndarray, optional</span>
<span class="sd">        Indices to recover the original List (in) from the output (Out). Return if return_inv us True.</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; In = [[0,1], [2, 3, 4, 5], [6, 7], [8, 9, 10]]</span>
<span class="sd">    &gt;&gt;&gt; Out = utils.SplitRaggedByLength(In)</span>
<span class="sd">    &gt;&gt;&gt; Out</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">out</span> <span class="o">=</span> <span class="n">SortRaggedByLength</span><span class="p">(</span><span class="n">In</span><span class="p">,</span> <span class="n">return_idx</span><span class="o">=</span><span class="n">return_idx</span><span class="p">,</span> <span class="n">return_inv</span><span class="o">=</span><span class="n">return_inv</span><span class="p">,</span> <span class="n">return_separators</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">In_sorted</span><span class="p">,</span> <span class="n">In_idx</span><span class="p">,</span> <span class="n">In_inv</span><span class="p">,</span> <span class="n">separators</span> <span class="o">=</span> <span class="p">[</span><span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_idx</span><span class="p">,</span> <span class="n">return_inv</span><span class="p">,</span> <span class="kc">True</span><span class="p">)]</span>

    <span class="n">Out</span> <span class="o">=</span> <span class="p">[</span><span class="n">In_sorted</span><span class="p">[</span><span class="n">separators</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">separators</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">separators</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">In_idx</span><span class="p">[</span><span class="n">separators</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">separators</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">separators</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">return_inv</span><span class="p">:</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="p">[</span><span class="n">In_inv</span><span class="p">[</span><span class="n">separators</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">separators</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">separators</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">returns</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_idx</span><span class="p">,</span> <span class="n">return_inv</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">returns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">Out</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">inv</span><span class="p">))</span> <span class="k">if</span> <span class="n">returns</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Out</span></div>


<div class="viewcode-block" id="PadRagged">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.PadRagged.html#mymesh.utils.PadRagged">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">PadRagged</span><span class="p">(</span><span class="n">In</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pads a 2d list of lists with variable length into a rectangular </span>
<span class="sd">    numpy array with specified fill value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    In : list</span>
<span class="sd">        Input list of lists to be padded.</span>
<span class="sd">    fillval : int (or other), optional</span>
<span class="sd">        Value used to pad the ragged array, by default -1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Out : np.ndarray</span>
<span class="sd">        Padded array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Out = np.array(list(itertools.zip_longest(*In,fillvalue=fillval))).T</span>
    <span class="n">maxL</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">In</span><span class="p">)</span>
    <span class="n">Out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">In</span><span class="p">),</span> <span class="n">maxL</span><span class="p">),</span> <span class="n">fillval</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">In</span><span class="p">):</span>
        <span class="n">Out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)]</span> <span class="o">=</span> <span class="n">row</span>

    <span class="k">return</span> <span class="n">Out</span></div>


<div class="viewcode-block" id="ExtractRagged">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.ExtractRagged.html#mymesh.utils.ExtractRagged">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ExtractRagged</span><span class="p">(</span><span class="n">In</span><span class="p">,</span><span class="n">delval</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a padded numpy array to a ragged list of list by removing entries that match the specified value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    In : np.ndarray</span>
<span class="sd">        Input array</span>
<span class="sd">    delval : int, optional</span>
<span class="sd">        Value to remove from the input array, by default -1</span>
<span class="sd">    dtype : type, optional</span>
<span class="sd">        Data type to cast the array to, by default the data type is unchanged.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Out : list</span>
<span class="sd">        Output list of lists with the specified value removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">if</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">In</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">In</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">In</span><span class="p">)</span>
        <span class="n">In</span> <span class="o">=</span> <span class="n">In</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">delval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">delval</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">delval</span><span class="p">):</span>
        <span class="n">delval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">In</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">In</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">In</span><span class="p">)</span>
        <span class="n">In</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">In</span><span class="p">)]</span> <span class="o">=</span> <span class="n">delval</span>
    <span class="n">where</span> <span class="o">=</span> <span class="n">In</span> <span class="o">!=</span> <span class="n">delval</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">In</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">Out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">In</span><span class="p">[</span><span class="n">where</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">where</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">In</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">Out</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">delval</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">z</span> <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span><span class="o">!=</span> <span class="n">delval</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">In</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Currently only supported for 2- or 3D matrices&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Out</span> <span class="o">=</span> <span class="n">In</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Out</span></div>


<div class="viewcode-block" id="identify_type">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.identify_type.html#mymesh.utils.identify_type">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">identify_type</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify the mesh as either a surface or volume.</span>

<span class="sd">        A mesh is classified as a volume mesh (``vol``) if any elements are unambiguous </span>
<span class="sd">        volume elements - pyramid (5 nodes), wedge (6), hexahedron (8), or if </span>
<span class="sd">        any of a random sample of 10 elements (or all elements if NElem &lt; 10) has</span>
<span class="sd">        a volume less than machine precision (``np.finfo(float).eps``). </span>
<span class="sd">        Alternatively, a surface mesh (``surf``) is identified if any of the elements is </span>
<span class="sd">        a triangle (3 nodes). In the case of a mesh containing both triangular</span>
<span class="sd">        and volume elements, the mesh will be classified arbitrarily by whichever</span>
<span class="sd">        appears first in NodeConn. A ``line`` mesh is identified if any line (2</span>
<span class="sd">         node) elements are present.</span>

<span class="sd">        This approach has a chance of mislabeling the mesh in some rare or </span>
<span class="sd">        non-standard scenarios, but attempts to be as efficient as possible</span>
<span class="sd">        to minimize overhead when creating a mesh. Potentially ambiguous meshes</span>
<span class="sd">        are:</span>

<span class="sd">        - </span>
<span class="sd">            Meshes containing both triangular elements and volume elements </span>
<span class="sd">            (this should generally be avoided as most functions aren&#39;t set up</span>
<span class="sd">            to handle that case).</span>
<span class="sd">        - </span>
<span class="sd">            Tetrahedral meshes with many degenerate elements with </span>
<span class="sd">            abs(vol) &lt; machine precision. </span>
<span class="sd">        - Quadrilateral meshes with non-planar elements.</span>

<span class="sd">        In such cases, Type should be specified explicitly when creating the mesh</span>
<span class="sd">        object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        NodeCoords : array_like</span>
<span class="sd">            Node coordinates.</span>
<span class="sd">        NodeConn : array_like</span>
<span class="sd">            Node connectivity.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Type : str</span>
<span class="sd">            Mesh type, either &#39;line&#39;, &#39;surf&#39;, &#39;vol&#39;, or &#39;empty&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>        

        <span class="c1"># Check if the mesh is empty</span>
        <span class="n">NNode</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">NElem</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">NNode</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">NElem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Type</span> <span class="o">=</span> <span class="s1">&#39;empty&#39;</span>
            <span class="k">return</span> <span class="n">Type</span>
        
        <span class="c1"># Check node dimensions, if it&#39;s 2D, then it must be a surface or line</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">Type</span> <span class="o">=</span> <span class="s1">&#39;line&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Type</span> <span class="o">=</span> <span class="s1">&#39;surf&#39;</span>
            <span class="k">return</span> <span class="n">Type</span>

        <span class="c1"># Check element lengths</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">)</span>
        <span class="n">vol_elem_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">}</span> <span class="c1"># Set of unambiguous volume element lengths</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lengths</span><span class="p">:</span>
            <span class="c1"># NOTE: any mesh containing triangle and volume elements will be </span>
            <span class="c1"># arbitrarily classified by whichever comes first.</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># The presence of any edge elements triggers &#39;line&#39;</span>
                <span class="n">Type</span> <span class="o">=</span> <span class="s1">&#39;line&#39;</span>
                <span class="k">return</span> <span class="n">Type</span>

            <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># The presence of any triangular elements triggers &#39;surf&#39;</span>
                <span class="n">Type</span> <span class="o">=</span> <span class="s1">&#39;surf&#39;</span>
                <span class="k">return</span> <span class="n">Type</span>
        
            <span class="k">elif</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">vol_elem_set</span><span class="p">:</span>
                <span class="c1"># The presence of any unambiguous volume elements triggers &#39;vol&#39;</span>
                <span class="n">Type</span> <span class="o">=</span> <span class="s1">&#39;vol&#39;</span>
                <span class="k">return</span> <span class="n">Type</span>

        <span class="c1"># If still ambiguous, check volumes of a random selection of elements</span>
        <span class="k">if</span> <span class="n">NElem</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">TempConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">NElem</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">TempConn</span> <span class="o">=</span> <span class="n">NodeConn</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">quality</span><span class="o">.</span><span class="n">Volume</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">TempConn</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
            <span class="c1"># If any of the sampled element volumes exceed machine precision,</span>
            <span class="c1"># mesh is assumed to be a volume mesh, otherwise a surface</span>
            <span class="n">Type</span> <span class="o">=</span> <span class="s1">&#39;vol&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Type</span> <span class="o">=</span> <span class="s1">&#39;surf&#39;</span>

        <span class="k">return</span> <span class="n">Type</span>    </div>


<div class="viewcode-block" id="identify_elem">
<a class="viewcode-back" href="../../generated/submodules/mymesh.utils.identify_elem.html#mymesh.utils.identify_elem">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">identify_elem</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">Type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify the types of elements present in the mesh. This provides this only</span>
<span class="sd">    identifies the unique types present, not the type of each individual </span>
<span class="sd">    element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : array_like</span>
<span class="sd">        Node coordinates.</span>
<span class="sd">    NodeConn : array_like</span>
<span class="sd">        Node connectivity.</span>
<span class="sd">    Type : str, NoneType, optional</span>
<span class="sd">        Type of mesh (`&#39;line&#39;`, `&#39;surf&#39;`, `&#39;vol&#39;`), if known. For some meshes</span>
<span class="sd">        this won&#39;t be needed, if it is but isn&#39;t provided, it will be identified</span>
<span class="sd">        using :func:`identify_type`. By default None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    elems : list</span>
<span class="sd">        List of strings identifying the element types present in the mesh</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; S = primitives.Sphere([0,0,0], 1, Type=&#39;surf&#39;)</span>
<span class="sd">    &gt;&gt;&gt; utils.identify_elem(S.NodeCoords, S.NodeConn)</span>
<span class="sd">    [&#39;tri&#39;, &#39;quad&#39;]</span>

<span class="sd">    &gt;&gt;&gt; S = primitives.Sphere([0,0,0], 1, Type=&#39;surf&#39;, ElemType=&#39;tri&#39;)</span>
<span class="sd">    &gt;&gt;&gt; utils.identify_elem(S.NodeCoords, S.NodeConn)</span>
<span class="sd">    [&#39;tri&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ambiguous_lengths</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">}</span> <span class="c1"># Element lengths that are ambiguous</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">and</span> <span class="n">NodeConn</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">object</span><span class="p">:</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)[</span><span class="mi">1</span><span class="p">],)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
            <span class="n">lengths</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)[</span><span class="mi">1</span><span class="p">],)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># ragged list of lists, check all lengths</span>
            <span class="n">lengths</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)))</span>
    
    <span class="n">lengths</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">l</span> <span class="ow">in</span> <span class="n">ambiguous_lengths</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lengths</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Type</span> <span class="o">=</span> <span class="n">identify_type</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>

    
    <span class="n">elems</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lengths</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;line&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;tri&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">6</span> <span class="ow">and</span> <span class="n">Type</span> <span class="o">==</span> <span class="s1">&#39;surf&#39;</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;tri6&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">Type</span> <span class="o">==</span> <span class="s1">&#39;surf&#39;</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;quad&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">8</span> <span class="ow">and</span> <span class="n">Type</span> <span class="o">==</span> <span class="s1">&#39;surf&#39;</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;quad8&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">Type</span> <span class="o">==</span> <span class="s1">&#39;vol&#39;</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;tet&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;pyr&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;wdg&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;tet10&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">20</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;hex20&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;unknown&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">elems</span></div>


<span class="nd">@try_njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">RotateNormalToVector</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">Normal</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reorient nodes to align an asociated normal vector with a chosen vector.</span>
<span class="sd">    This can be used to reorient a mesh so that a particular element is facing</span>
<span class="sd">    in a certain direction</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    NodeCoords : np.ndarray(dtype=np.float64)</span>
<span class="sd">        Array of node coordinates (shape=(n,3))</span>
<span class="sd">    Normal : np.ndarray(dtype=np.float64)</span>
<span class="sd">        Normal vector associated with the nodes (shape=(3,)). This could </span>
<span class="sd">        be the normal vector of a particular node or element of the mesh, or </span>
<span class="sd">        some other vector related to the nodes that is the basis of reorientation.</span>
<span class="sd">    Vector : np.ndarray(dtype=np.float64)</span>
<span class="sd">        Vector which the nodes will be rotated so that Normal is aligned with it (shape=(3,)).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    RotCoords : np.ndarray</span>
<span class="sd">        Coordinates of the rotated nodes. These will be positioned arbitrarily</span>
<span class="sd">        in space, but will be rotated so that Normal is parallel with Vector</span>
<span class="sd">    R : np.ndarray</span>
<span class="sd">        3x3 rotation matrix. RotCoords = (R @ NodeCoords.T).T</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">Normal</span> <span class="o">=</span> <span class="n">Normal</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Normal</span><span class="p">)</span>
    <span class="n">Vector</span> <span class="o">=</span> <span class="n">Vector</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Vector</span><span class="p">)</span>
    <span class="n">Cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span><span class="n">Vector</span><span class="p">)</span> 
    <span class="n">CrossNorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Cross</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">CrossNorm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1"># RotAxis = np.array([[0,0,1],[1,0,0],[0,1,0]],dtype=np.float64) @ Normal[:,None]</span>
        <span class="n">RotAxis</span> <span class="o">=</span> <span class="n">Normal</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">RotAxis</span> <span class="o">=</span> <span class="n">Cross</span><span class="o">/</span><span class="n">CrossNorm</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
        <span class="n">Angle</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Vector</span><span class="p">,</span> <span class="n">Normal</span><span class="p">))</span>
    
    <span class="n">outer_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">RotAxis</span><span class="p">,</span> <span class="n">RotAxis</span><span class="p">)</span>
    <span class="n">cross_prod_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">cross_prod_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">RotAxis</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">cross_prod_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="n">RotAxis</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">cross_prod_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>  <span class="n">RotAxis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cross_prod_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">RotAxis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cross_prod_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">RotAxis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cross_prod_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="n">RotAxis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Angle</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Angle</span><span class="p">)</span><span class="o">*</span><span class="n">cross_prod_matrix</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Angle</span><span class="p">))</span><span class="o">*</span><span class="n">outer_prod</span>

    <span class="n">RotCoords</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">@</span> <span class="n">NodeCoords</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">RotCoords</span><span class="p">,</span> <span class="n">R</span>

    
</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2023, Timothy O. Josephson.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>