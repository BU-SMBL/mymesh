
<!DOCTYPE html>


<html lang="en" data-content_root="../../" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mymesh.implicit &#8212; MyMesh v0.1.0 Manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/mymesh.css?v=152078be" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../../_static/documentation_options.js?v=01f34227"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=4ea706d9"></script>
    <script src="../../_static/thebelab-helper.js"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/mymesh/implicit';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
    
    <img src="../../_static/mymesh_logo.png" class="logo__image only-light" alt="MyMesh v0.1.0 Manual - Home"/>
    <img src="../../_static/mymesh_logo.png" class="logo__image only-dark pst-js-only" alt="MyMesh v0.1.0 Manual - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../guide.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../theory.html">
    Theory Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../dev.html">
    Development
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/BU-SMBL/mymesh" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../guide.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../theory.html">
    Theory Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../dev.html">
    Development
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/BU-SMBL/mymesh" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">mymesh.implicit</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for mymesh.implicit</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Created on Fri Jan 14 17:43:57 2022</span>
<span class="c1"># @author: toj</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Implicit function meshing tools</span>

<span class="sd">An implicit function f(x,y,z) describes a surface in 3D where the surface is</span>
<span class="sd">located on the f(x,y,z) = 0 isosurface. The default convention used in this</span>
<span class="sd">module is that values less than zero are considered &quot;inside&quot; the surface,</span>
<span class="sd">and values above zero are considered &quot;outside&quot;. </span>


<span class="sd">.. currentmodule:: mymesh.implicit</span>


<span class="sd">Mesh Generation</span>
<span class="sd">===============</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    VoxelMesh</span>
<span class="sd">    SurfaceMesh</span>
<span class="sd">    TetMesh</span>
<span class="sd">    SurfaceNodeOptimization</span>

<span class="sd">Implicit Functions</span>
<span class="sd">==================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    gyroid</span>
<span class="sd">    lidinoid</span>
<span class="sd">    primitive</span>
<span class="sd">    neovius</span>
<span class="sd">    diamond</span>
<span class="sd">    cylinder</span>
<span class="sd">    box</span>
<span class="sd">    xplane</span>
<span class="sd">    yplane</span>
<span class="sd">    zplane</span>
<span class="sd">    sphere</span>
<span class="sd">    torus</span>

<span class="sd">Implicit Function Operators</span>
<span class="sd">===========================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    offset</span>
<span class="sd">    union</span>
<span class="sd">    diff</span>
<span class="sd">    thicken</span>
<span class="sd">    intersection</span>
<span class="sd">    unionf</span>
<span class="sd">    difff</span>
<span class="sd">    intersectionf</span>
<span class="sd">    thickenf</span>
<span class="sd">    unions</span>
<span class="sd">    diffs</span>
<span class="sd">    intersections</span>
<span class="sd">    thickens</span>
<span class="sd">    rMax</span>
<span class="sd">    rMin</span>

<span class="sd">Other Implicit Mesh Utilities</span>
<span class="sd">=============================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    mesh2sdf</span>
<span class="sd">    mesh2udf</span>
<span class="sd">    grid2fun</span>
<span class="sd">    grid2grad</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># %%</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">bisect</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">contour</span><span class="p">,</span> <span class="n">quality</span><span class="p">,</span> <span class="n">improvement</span><span class="p">,</span> <span class="n">rays</span><span class="p">,</span> <span class="n">octree</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">primitives</span>

<span class="c1"># Mesh generators</span>
<div class="viewcode-block" id="VoxelMesh">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.VoxelMesh.html#mymesh.implicit.VoxelMesh">[docs]</a>
<span class="k">def</span> <span class="nf">VoxelMesh</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate voxel mesh of an implicit function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function that describes the geometry of the object to be meshed. The function should be of the form v = f(x,y,z,*args,**kwargs) where x, y, and z are 1D numpy arrays of x, y and z coordinates and v is a 1D numpy array of function values. Additional arguments and keyword arguments may be passed through args and kwargs.</span>
<span class="sd">    bounds : array_like</span>
<span class="sd">        6 element array, list, or tuple with the minimum and maximum bounds in each direction that the function will be evaluated. This should be formatted as: [xmin, xmax, ymin, ymax, zmin, zmax]</span>
<span class="sd">    h : scalar, tuple</span>
<span class="sd">        Element side length. Can be specified as a single scalar value, or a three element tuple (or array_like).</span>
<span class="sd">    threshold : scalar</span>
<span class="sd">        Isovalue threshold to use for keeping/removing elements, by default 0.</span>
<span class="sd">    threshold_direction : signed integer</span>
<span class="sd">        If threshold_direction is negative (default), values less than or equal to the threshold will be considered &quot;inside&quot; the mesh and the opposite if threshold_direction is positive, by default -1.</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        Mode for determining which elements are kept, by default &#39;any&#39;.</span>
<span class="sd">        Voxels will be kept if:</span>
<span class="sd">        &#39;any&#39; - if any node of a voxel is inside the surface, </span>
<span class="sd">        &#39;all&#39; - if all nodes of a voxel are inside the surface, </span>
<span class="sd">        &#39;centroid&#39; - if the centroid of the voxel is inside the surface. Centroids performs additional evaluation of the function, which could slow mesh generation for expensive to evaluate functions,</span>
<span class="sd">        &#39;boundary&#39; - if the voxel contains values above and below the threshold,</span>
<span class="sd">        &#39;notrim&#39; - all voxels are kept</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Tuple of additional positional arguments for func, by default ().</span>
<span class="sd">    kwargs : dict, optional</span>
<span class="sd">        Dictionary of additional keyword arguments for func, by default {}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    voxel : mymesh.mesh</span>
<span class="sd">        Mesh object containing the voxel mesh. The values of the function at each node are stored in voxel.NodeData[&#39;func&#39;]</span>

<span class="sd">        .. note:: Due to the ability to unpack the mesh object to NodeCoords and NodeConn, the NodeCoords and NodeConn array can be returned directly (instead of the mesh object) by running: ``NodeCoords, NodeConn = implicit.VoxelMesh(...)``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        voxel = implicit.VoxelMesh(implicit.gyroid, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        voxel.plot(bgcolor=&#39;w&#39;, scalars=voxel.NodeData[&#39;func&#39;])</span>

<span class="sd">    &quot;&quot;&quot;</span>        
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>

    <span class="c1"># If func is a sympy-based function, convert it to numpy</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">GridConn</span> <span class="o">=</span> <span class="n">primitives</span><span class="o">.</span><span class="n">Grid</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">exact_h</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">Values</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">threshold_direction</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">NodeVals</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">Values</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">threshold</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">Values</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
            <span class="n">voxel</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">voxel</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">()</span>
        <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">return</span> <span class="n">voxel</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;notrim&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;centroid&#39;</span><span class="p">:</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">GridConn</span><span class="p">)</span>
            <span class="n">Inside</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">centroids</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">centroids</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">centroids</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">threshold</span>
            <span class="n">VoxelConn</span> <span class="o">=</span> <span class="n">GridConn</span><span class="p">[</span><span class="n">Inside</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Inside</span> <span class="o">=</span> <span class="n">NodeVals</span> <span class="o">&lt;=</span> <span class="n">threshold</span>
            <span class="n">ElemInsides</span> <span class="o">=</span> <span class="n">Inside</span><span class="p">[</span><span class="n">GridConn</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;any&#39;</span><span class="p">:</span>
                <span class="n">VoxelConn</span> <span class="o">=</span> <span class="n">GridConn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ElemInsides</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="n">VoxelConn</span> <span class="o">=</span> <span class="n">GridConn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ElemInsides</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span>
                <span class="n">VoxelConn</span> <span class="o">=</span> <span class="n">GridConn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ElemInsides</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ElemInsides</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;mode must be &quot;any&quot;, &quot;all&quot;, &quot;centroid&quot;, &quot;boundary&quot;, or &quot;notrim&quot;.&#39;</span><span class="p">)</span>

        <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">OriginalIds</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">RemoveNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">)</span>
        <span class="n">Values</span> <span class="o">=</span> <span class="n">Values</span><span class="p">[</span><span class="n">OriginalIds</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>   
        <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">GridConn</span>
    
    <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Values</span>

    <span class="k">return</span> <span class="n">voxel</span></div>


<div class="viewcode-block" id="SurfaceMesh">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.SurfaceMesh.html#mymesh.implicit.SurfaceMesh">[docs]</a>
<span class="k">def</span> <span class="nf">SurfaceMesh</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mc&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">mixed_elements</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">snap2surf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a surface mesh of an implicit function </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function that describes the geometry of the object to be meshed. The function should be of the form v = f(x,y,z,*args,**kwargs) where x, y, and z are 1D numpy arrays of x, y and z coordinates and v is a 1D numpy array of function values. For method=&#39;mc&#39;, x, y, and z will be 3D coordinate arrays and v must be 3D as well. Additional arguments and keyword arguments may be passed through args and kwargs.</span>
<span class="sd">    bounds : array_like</span>
<span class="sd">        6 element array, list, or tuple with the minimum and maximum bounds in each direction that the function will be evaluated. This should be formatted as: [xmin, xmax, ymin, ymax, zmin, zmax]</span>
<span class="sd">    h : scalar, tuple</span>
<span class="sd">        Element side length. Can be specified as a single scalar value, or a three element tuple (or array_like).</span>
<span class="sd">    threshold : scalar</span>
<span class="sd">        Isovalue threshold to use for keeping/removing elements, by default 0.</span>
<span class="sd">    threshold_direction : signed integer</span>
<span class="sd">        If threshold_direction is negative (default), values less than or equal to the threshold will be considered &quot;inside&quot; the mesh and the opposite if threshold_direction is positive, by default -1.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Surface triangulation method, by default &#39;mc&#39;.</span>
<span class="sd">        &#39;mc&#39; : Marching cubes (see contour.MarchingCubesImage) (default)</span>

<span class="sd">        &#39;mc33&#39; : Marching cubes 33 (see contour.MarchingCubes)</span>

<span class="sd">        &#39;mt&#39; : Marching tetrahedra (see contour.MarchingTetrahedra)</span>
<span class="sd">    interpolation : str, optional</span>
<span class="sd">        Method of interpolation used for placing the vertices on the approximated isosurface. This can be &#39;midpoint&#39;, &#39;linear&#39;, or &#39;cubic&#39;, by default &#39;linear&#39;. If &#39;cubic&#39; is selected, method is overridden to be &#39;mc&#39;. </span>
<span class="sd">    mixed_elements : bool, optional</span>
<span class="sd">        If marching tetrahedra is used, setting mixed_elements to True will allow</span>
<span class="sd">        for a surface mesh with a combination of quads and tris, by default False.</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Tuple of additional positional arguments for func, by default ().</span>
<span class="sd">    kwargs : dict, optional</span>
<span class="sd">        Dictionary of additional keyword arguments for func, by default {}.</span>
<span class="sd">    snap2surf : bool or float, optional</span>
<span class="sd">        Option to use :func:`~mymesh.contour.SnapGrid2Surf` which moves points</span>
<span class="sd">        of the background mesh to lie on the surface. If specified as a float </span>
<span class="sd">        in the range [0, 0.5], sets the snapping parameter which indicates</span>
<span class="sd">        the relative distance within which a point is snapped (0 = no snapping,</span>
<span class="sd">        0.5 = all possible points are snapped). If True, default snapping</span>
<span class="sd">        parameter of 0.2 is used. Snapping isn&#39;t compatible with method == &#39;mc&#39; </span>
<span class="sd">        or interpolation==&#39;cubic&#39;, if either of these options are selected,</span>
<span class="sd">        no snapping will occur, regardless of the snap2surf input. By default, </span>
<span class="sd">        True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    surface : mymesh.mesh</span>
<span class="sd">        Mesh object containing the surface mesh.</span>

<span class="sd">        .. note:: Due to the ability to unpack the mesh object to NodeCoords and NodeConn, the NodeCoords and NodeConn array can be returned directly (instead of the mesh object) by running: ``NodeCoords, NodeConn = implicit.SurfaceMesh(...)``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.gyroid, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">threshold_direction</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">snap2surf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">snap</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snap2surf</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">assert</span> <span class="n">snap2surf</span> <span class="o">&lt;=</span> <span class="mf">0.5</span> <span class="ow">and</span> <span class="n">snap2surf</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Snapping parameter must be in the range [0,0.5]&#39;</span>
        <span class="n">snap</span> <span class="o">=</span> <span class="n">snap2surf</span>
        <span class="n">snap2surf</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mc&#39;</span> <span class="ow">or</span> <span class="n">interpolation</span><span class="o">==</span><span class="s1">&#39;cubic&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;mc&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Using cubic interpolation overrides contour method to be marching cubes (&quot;mc&quot;).&#39;</span><span class="p">)</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="n">zs</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">MarchingCubesImage</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;original&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span><span class="n">VertexValues</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">SurfCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">SurfCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">SurfCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mc33&#39;</span><span class="p">:</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">vector_func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=</span><span class="n">threshold_direction</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;notrim&#39;</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">snap2surf</span><span class="p">:</span>
            <span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">SnapGrid2Surf</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">],</span> <span class="n">snap</span><span class="o">=</span><span class="n">snap</span><span class="p">)</span>
        <span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">MarchingCubes</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;33&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span><span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mt&#39;</span><span class="p">:</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">vector_func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;notrim&#39;</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">snap2surf</span><span class="p">:</span>
            <span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">SnapGrid2Surf</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">],</span> <span class="n">snap</span><span class="o">=</span><span class="n">snap</span><span class="p">)</span>
        <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">hex2tet</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;1to6&#39;</span><span class="p">)</span>
        <span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">MarchingTetrahedra</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">],</span> <span class="n">Type</span><span class="o">=</span><span class="s1">&#39;surf&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">,</span> <span class="n">mixed_elements</span><span class="o">=</span><span class="n">mixed_elements</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
        <span class="n">surface</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">surface</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">surface</span></div>


<div class="viewcode-block" id="TetMesh">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.TetMesh.html#mymesh.implicit.TetMesh">[docs]</a>
<span class="k">def</span> <span class="nf">TetMesh</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">background</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">snap2surf</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a tetrahedral mesh of an implicit function </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function that describes the geometry of the object to be meshed. The function should be of the form v = f(x,y,z,*args,**kwargs) where x, y, and z are 1D numpy arrays of x, y and z coordinates and v is a 1D numpy array of function values. For method=&#39;mc&#39;, x, y, and z will be 3D coordinate arrays and v must be 3D as well. Additional arguments and keyword arguments may be passed through args and kwargs.</span>
<span class="sd">    bounds : array_like</span>
<span class="sd">        6 element array, list, or tuple with the minimum and maximum bounds in each direction that the function will be evaluated. This should be formatted as: [xmin, xmax, ymin, ymax, zmin, zmax]</span>
<span class="sd">    h : scalar, tuple</span>
<span class="sd">        Element side length. Can be specified as a single scalar value, or a three element tuple (or array_like).</span>
<span class="sd">    threshold : scalar</span>
<span class="sd">        Isovalue threshold to use for keeping/removing elements, by default 0.</span>
<span class="sd">    threshold_direction : signed integer</span>
<span class="sd">        If threshold_direction is negative (default), values less than or equal to the threshold will be considered &quot;inside&quot; the mesh and the opposite if threshold_direction is positive, by default -1.</span>
<span class="sd">    interpolation : str, optional</span>
<span class="sd">        Method of interpolation used for placing the vertices on the approximated </span>
<span class="sd">        isosurface. This can be &#39;midpoint&#39;, &#39;linear&#39;, or &#39;quadratic&#39;, by default</span>
<span class="sd">        &#39;linear&#39;. </span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Tuple of additional positional arguments for func, by default ().</span>
<span class="sd">    kwargs : dict, optional</span>
<span class="sd">        Dictionary of additional keyword arguments for func, by default {}.</span>
<span class="sd">    background : None or mymesh.mesh, optional</span>
<span class="sd">        Background tetrahedral mesh to use for evaluating the function and performing</span>
<span class="sd">        marching tetrahedra. If a mesh is provide, bounds and h will be ignored. </span>
<span class="sd">        If None is provided, a uniform tetrahedral grid will be used, by default None.</span>
<span class="sd">    snap2surf : bool or float, optional</span>
<span class="sd">        Option to use :func:`~mymesh.contour.SnapGrid2Surf` which moves points</span>
<span class="sd">        of the background mesh to lie on the surface. If specified as a float </span>
<span class="sd">        in the range [0, 0.5], sets the snapping parameter which indicates</span>
<span class="sd">        the relative distance within which a point is snapped (0 = no snapping,</span>
<span class="sd">        0.5 = all possible points are snapped). If True, default snapping</span>
<span class="sd">        parameter of 0.2 is used. By default, True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tet : mymesh.mesh</span>
<span class="sd">        Mesh object containing the tetrahedral mesh.</span>

<span class="sd">        .. note:: Due to the ability to unpack the mesh object to NodeCoords and NodeConn, the NodeCoords and NodeConn array can be returned directly (instead of the mesh object) by running: ``NodeCoords, NodeConn = implicit.TetMesh(...)``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        tet = implicit.TetMesh(implicit.gyroid, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        tet.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">threshold_direction</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="kc">False</span>
        
    <span class="k">if</span> <span class="n">snap2surf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">snap</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snap2surf</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">assert</span> <span class="n">snap2surf</span> <span class="o">&lt;=</span> <span class="mf">0.5</span> <span class="ow">and</span> <span class="n">snap2surf</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Snapping parameter must be in the range [0,0.5]&#39;</span>
        <span class="n">snap</span> <span class="o">=</span> <span class="n">snap2surf</span>
        <span class="n">snap2surf</span> <span class="o">=</span> <span class="kc">True</span>
    

    <span class="k">if</span> <span class="n">background</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">vector_func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">snap2surf</span><span class="p">:</span>
            <span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">SnapGrid2Surf</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">],</span> <span class="n">snap</span><span class="o">=</span><span class="n">snap</span><span class="p">)</span><span class="c1">#, FixedNodes = voxel.SurfNodes)</span>
        <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">hex2tet</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;1to6&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">tet42tet10</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
            <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">background</span>
        <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">snap2surf</span><span class="p">:</span>
            <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">SnapGrid2Surf</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeVals</span><span class="p">,</span> <span class="n">snap</span><span class="o">=</span><span class="n">snap</span><span class="p">,</span> <span class="n">FixedNodes</span><span class="o">=</span><span class="n">background</span><span class="o">.</span><span class="n">SurfNodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">tet42tet10</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
            <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">TetCoords</span><span class="p">,</span> <span class="n">TetConn</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">MarchingTetrahedra</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeVals</span><span class="p">,</span> <span class="n">Type</span><span class="o">=</span><span class="s1">&#39;vol&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span> <span class="n">cleanup</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    

    <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
        <span class="n">tet</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">TetCoords</span><span class="p">,</span> <span class="n">TetConn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tet</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">(</span><span class="n">TetCoords</span><span class="p">,</span> <span class="n">TetConn</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">tet</span></div>


<div class="viewcode-block" id="SurfaceNodeOptimization">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.SurfaceNodeOptimization.html#mymesh.implicit.SurfaceNodeOptimization">[docs]</a>
<span class="k">def</span> <span class="nf">SurfaceNodeOptimization</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">iterate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">FixedNodes</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span> <span class="n">FreeNodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">FixEdges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">finite_diff_step</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">InPlace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">springs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optimize the placement of surface node to lie on the &quot;true&quot; surface. This</span>
<span class="sd">    This simultaneously moves nodes towards the isosurface and redistributes</span>
<span class="sd">    nodes more evenly, thus smoothing the mesh without shrinkage or destruction</span>
<span class="sd">    of features. This method is consists of using the Z-flow (and R-flow if </span>
<span class="sd">    smooth=True) from :cite:t:`Ohtake2001a`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : mesh.mesh</span>
<span class="sd">        Mesh object</span>
<span class="sd">    func : function or sympy-type function</span>
<span class="sd">        Implicit function describing the mesh surface. This should be the same</span>
<span class="sd">        function used to create the mesh.</span>
<span class="sd">    h : float</span>
<span class="sd">        Element size of the surface mesh</span>
<span class="sd">    iterate : int, optional</span>
<span class="sd">        Number of iterations to perform, by default 1</span>
<span class="sd">    FixedNodes : set, optional</span>
<span class="sd">        Nodes to hold in place during repositioning, by default set()</span>
<span class="sd">    FreeNodes : NoneType, set, or array_like</span>
<span class="sd">        Movable nodes, if None these will be the surface nodes. The any nodes in both </span>
<span class="sd">        FreeNodes and FixedNodes will be removed from FreeNodes. By default None.</span>
<span class="sd">    FixEdges : bool, optional</span>
<span class="sd">        Option to detect and hold in place exposed surface edges, by default False</span>
<span class="sd">    finite_diff_step : float, optional</span>
<span class="sd">        Small number used to calculate finite difference approximations to the </span>
<span class="sd">        gradient. Only used if the function is not convertible to a </span>
<span class="sd">        sympy-differentiable function, by default 1e-5.</span>
<span class="sd">    smooth : str, optional</span>
<span class="sd">        Option to perform smoothing. This can be either &#39;local&#39; for local </span>
<span class="sd">        Laplacian smoothing or &#39;tangential&#39; for tangential Laplacian smoothing, </span>
<span class="sd">        by default &#39;tangential&#39;. For any other option, smoothing will not be </span>
<span class="sd">        performed. Tangential smoothing differs from local in that nodes </span>
<span class="sd">        are only repositioned in the tangent plane (based on the normal vector</span>
<span class="sd">        obtain from the gradient). </span>
<span class="sd">    InPlace : bool, optional</span>
<span class="sd">        If False, will create a copy of the mesh, rather than altering node </span>
<span class="sd">        positions of the original mesh object &quot;in-place&quot;, by default False</span>
<span class="sd">    springs : bool, optional</span>
<span class="sd">        If True and the mesh is a volume mesh, internal nodes will be treated as </span>
<span class="sd">        if they are connected by springs (see :func:`~mymesh.improvement.NodeSpringSmoothing`)</span>
<span class="sd">        to reduce risk of element distortion or inversion, by default True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M : mesh.mesh</span>
<span class="sd">        Mesh with repositioned surface vertices</span>

<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="k">if</span> <span class="ow">not</span> <span class="n">InPlace</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">smooth</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">smooth</span> <span class="o">=</span> <span class="s1">&#39;tangential&#39;</span>
        
    <span class="c1"># Process nodes</span>
    <span class="k">if</span> <span class="n">FixEdges</span><span class="p">:</span>
        <span class="n">EdgeNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">surf2edges</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">EdgeNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">FreeNodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">FreeNodes</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">SurfNodes</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">FreeNodes</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">FreeNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">FreeNodes</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">FreeNodes</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">FreeNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">FreeNodes</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">FreeNodes</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for FreeNodes.&#39;</span><span class="p">)</span>
    <span class="n">FreeNodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">FreeNodes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">EdgeNodes</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">FixedNodes</span><span class="p">)))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">FreeNodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No free movable nodes.&#39;</span><span class="p">)</span>

    <span class="c1"># Process function</span>
    <span class="k">def</span> <span class="nf">DiracDelta</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
            
            <span class="n">Fx</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
            <span class="n">Fy</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span><span class="n">y</span><span class="p">)</span>
            <span class="n">Fz</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span><span class="n">z</span><span class="p">)</span>
            <span class="n">Grad</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">Fx</span><span class="p">,</span> <span class="n">Fy</span><span class="p">,</span> <span class="n">Fz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">gradF</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="n">Grad</span><span class="p">,[</span><span class="s1">&#39;numpy&#39;</span><span class="p">,{</span><span class="s1">&#39;DiracDelta&#39;</span><span class="p">:</span><span class="n">DiracDelta</span><span class="p">}])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">func</span>
            <span class="k">def</span> <span class="nf">gradF</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">):</span>
                <span class="n">gradx</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="o">+</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="o">-</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">))</span><span class="o">/</span><span class="n">finite_diff_step</span>
                <span class="n">grady</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="o">+</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="o">-</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">Z</span><span class="p">))</span><span class="o">/</span><span class="n">finite_diff_step</span>
                <span class="n">gradz</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="o">+</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="o">-</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">finite_diff_step</span>
                <span class="n">gradf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">gradx</span><span class="p">,</span><span class="n">grady</span><span class="p">,</span><span class="n">gradz</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">gradf</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>

        <span class="n">Fx</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
        <span class="n">Fy</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">Fz</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
        <span class="n">Grad</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">Fx</span><span class="p">,</span> <span class="n">Fy</span><span class="p">,</span> <span class="n">Fz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">gradF</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="n">Grad</span><span class="p">,[</span><span class="s1">&#39;numpy&#39;</span><span class="p">,{</span><span class="s1">&#39;DiracDelta&#39;</span><span class="p">:</span><span class="n">DiracDelta</span><span class="p">}])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;func must be a sympy function or callable function of three arguments (x,y,z).&#39;</span><span class="p">)</span>

    <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">),</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">];</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">gradF</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfNodeNeighbors</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfNodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">FreeNodes</span><span class="p">])</span>


    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterate</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">];</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="o">-</span> <span class="n">threshold</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">gradF</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">))</span>
        <span class="n">fg</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fg</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

        <span class="n">Zflow</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">fg</span>

        <span class="c1"># Rflow = np.zeros((len(NodeCoords),3))</span>
        <span class="k">if</span> <span class="n">smooth</span> <span class="o">==</span> <span class="s1">&#39;tangential&#39;</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="n">U</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lengths</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Q</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">gnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">gnorm</span><span class="p">[</span><span class="n">gnorm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">NodeNormals</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span><span class="o">/</span><span class="n">gnorm</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Rflow</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">U</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">NodeNormals</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">NodeNormals</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">smooth</span> <span class="o">==</span> <span class="s1">&#39;local&#39;</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="n">U</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lengths</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Q</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Rflow</span> <span class="o">=</span> <span class="n">U</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Rflow</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">springs</span> <span class="ow">and</span> <span class="n">M</span><span class="o">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s1">&#39;vol&#39;</span><span class="p">:</span>
            <span class="n">Forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="o">.</span><span class="n">NNode</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">Forces</span><span class="p">[</span><span class="n">FreeNodes</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zflow</span> <span class="o">+</span> <span class="n">Rflow</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">improvement</span><span class="o">.</span><span class="n">NodeSpringSmoothing</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Displacements</span><span class="o">=</span><span class="n">Forces</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">FixSurf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">FixedNodes</span><span class="o">=</span><span class="n">FixedNodes</span><span class="p">,</span> <span class="n">InPlace</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points</span> <span class="o">+</span> <span class="n">Zflow</span> <span class="o">+</span> <span class="n">Rflow</span>
            <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">FreeNodes</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span>
    <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">M</span></div>


<span class="c1"># Implicit Function Primitives</span>
<div class="viewcode-block" id="gyroid">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.gyroid.html#mymesh.implicit.gyroid">[docs]</a>
<span class="k">def</span> <span class="nf">gyroid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function approximation of the gyroid triply periodic minimal </span>
<span class="sd">    surface (TPMS). This function uses sympy functions (sp.cos, sp.sin) to </span>
<span class="sd">    enable symbolic differentiation. </span>
<span class="sd">    </span>
<span class="sd">    For efficient vectorized evaluation, use:</span>
<span class="sd">    x, y, z = sp.symbols(&#39;x y z&#39;, real=True)</span>
<span class="sd">    vector_func = sp.lambdify((x, y, z), func(x,y,z), &#39;numpy&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : scalar or np.ndarray</span>
<span class="sd">        x coordinate(s)</span>
<span class="sd">    y : scalar or np.ndarray</span>
<span class="sd">        y coordinate(s)</span>
<span class="sd">    z : scalar or np.ndarray</span>
<span class="sd">        z coordinate(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        implicit function evaluated with sympy</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.gyroid, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="lidinoid">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.lidinoid.html#mymesh.implicit.lidinoid">[docs]</a>
<span class="k">def</span> <span class="nf">lidinoid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function approximation of the lidinoid triply periodic minimal </span>
<span class="sd">    surface (TPMS). This function uses sympy functions (sp.cos, sp.sin) to </span>
<span class="sd">    enable symbolic differentiation. </span>
<span class="sd">    </span>
<span class="sd">    For efficient vectorized evaluation, use:</span>
<span class="sd">    x, y, z = sp.symbols(&#39;x y z&#39;, real=True)</span>
<span class="sd">    vector_func = sp.lambdify((x, y, z), func(x,y,z), &#39;numpy&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : scalar or np.ndarray</span>
<span class="sd">        x coordinate(s)</span>
<span class="sd">    y : scalar or np.ndarray</span>
<span class="sd">        y coordinate(s)</span>
<span class="sd">    z : scalar or np.ndarray</span>
<span class="sd">        z coordinate(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        implicit function evaluated with sympy</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.lidinoid, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Z</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Z</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.15</span>
    <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="primitive">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.primitive.html#mymesh.implicit.primitive">[docs]</a>
<span class="k">def</span> <span class="nf">primitive</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function approximation of the primitive (Schwarz P) triply periodic </span>
<span class="sd">    minimal surface (TPMS). This function uses sympy functions (sp.cos, sp.sin) </span>
<span class="sd">    to enable symbolic differentiation. </span>
<span class="sd">    </span>
<span class="sd">    For efficient vectorized evaluation, use:</span>
<span class="sd">    x, y, z = sp.symbols(&#39;x y z&#39;, real=True)</span>
<span class="sd">    vector_func = sp.lambdify((x, y, z), func(x,y,z), &#39;numpy&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : scalar or np.ndarray</span>
<span class="sd">        x coordinate(s)</span>
<span class="sd">    y : scalar or np.ndarray</span>
<span class="sd">        y coordinate(s)</span>
<span class="sd">    z : scalar or np.ndarray</span>
<span class="sd">        z coordinate(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        implicit function evaluated with sympy</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.primitive, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span></div>


<div class="viewcode-block" id="neovius">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.neovius.html#mymesh.implicit.neovius">[docs]</a>
<span class="k">def</span> <span class="nf">neovius</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function approximation of the neovius triply periodic minimal </span>
<span class="sd">    surface (TPMS). This function uses sympy functions (sp.cos, sp.sin) to </span>
<span class="sd">    enable symbolic differentiation. </span>
<span class="sd">    </span>
<span class="sd">    For efficient vectorized evaluation, use:</span>
<span class="sd">    x, y, z = sp.symbols(&#39;x y z&#39;, real=True)</span>
<span class="sd">    vector_func = sp.lambdify((x, y, z), func(x,y,z), &#39;numpy&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : scalar or np.ndarray</span>
<span class="sd">        x coordinate(s)</span>
<span class="sd">    y : scalar or np.ndarray</span>
<span class="sd">        y coordinate(s)</span>
<span class="sd">    z : scalar or np.ndarray</span>
<span class="sd">        z coordinate(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        implicit function evaluated with sympy</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.neovius, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">X</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span>
    <span class="k">return</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">))</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span></div>


<div class="viewcode-block" id="diamond">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.diamond.html#mymesh.implicit.diamond">[docs]</a>
<span class="k">def</span> <span class="nf">diamond</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function approximation of the diamond (Schwarz D) triply periodic </span>
<span class="sd">    minimal surface (TPMS). This function uses sympy functions (sp.cos, sp.sin) </span>
<span class="sd">    to enable symbolic differentiation. </span>
<span class="sd">    </span>
<span class="sd">    For efficient vectorized evaluation, use:</span>
<span class="sd">    x, y, z = sp.symbols(&#39;x y z&#39;, real=True)</span>
<span class="sd">    vector_func = sp.lambdify((x, y, z), func(x,y,z), &#39;numpy&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : scalar or np.ndarray</span>
<span class="sd">        x coordinate(s)</span>
<span class="sd">    y : scalar or np.ndarray</span>
<span class="sd">        y coordinate(s)</span>
<span class="sd">    z : scalar or np.ndarray</span>
<span class="sd">        z coordinate(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        implicit function evaluated with sympy</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.diamond, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span></div>


<div class="viewcode-block" id="cylinder">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.cylinder.html#mymesh.implicit.cylinder">[docs]</a>
<span class="k">def</span> <span class="nf">cylinder</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a cylinder.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : array_like</span>
<span class="sd">        2D vector specifying the x and y coordinates of the center of the </span>
<span class="sd">        cylindrical cross section</span>
<span class="sd">    radius : float</span>
<span class="sd">        Radius of the cylinder</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z)</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.cylinder([0,0,0], 1), [-1,1,-1,1,-1,1], 0.1)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">func</span></div>


<div class="viewcode-block" id="box">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.box.html#mymesh.implicit.box">[docs]</a>
<span class="k">def</span> <span class="nf">box</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">):</span>    
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a box.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : float</span>
<span class="sd">        x coordinate lower bound</span>
<span class="sd">    x2 : float</span>
<span class="sd">        x coordinate upper bound</span>
<span class="sd">    y1 : float</span>
<span class="sd">        y coordinate lower bound</span>
<span class="sd">    y2 : float</span>
<span class="sd">        y coordinate upper bound</span>
<span class="sd">    z1 : float</span>
<span class="sd">        z coordinate lower bound</span>
<span class="sd">    z2 : float</span>
<span class="sd">        z coordinate upper bound</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z)</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.box(.1,.9,.1,.9,.1,.9), [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="n">intersection</span><span class="p">(</span><span class="n">intersection</span><span class="p">(</span><span class="n">intersection</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="o">-</span><span class="n">x2</span><span class="p">),</span><span class="n">intersection</span><span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y</span><span class="p">,</span><span class="n">y</span><span class="o">-</span><span class="n">y2</span><span class="p">)),</span><span class="n">intersection</span><span class="p">(</span><span class="n">z1</span><span class="o">-</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="o">-</span><span class="n">z2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">func</span></div>


<span class="k">def</span> <span class="nf">plane</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">normal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of an arbitrary plane.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt : array_like</span>
<span class="sd">        Three element array_like, coordinates of a point on the plane.</span>
<span class="sd">    normal : array_like</span>
<span class="sd">        Three element array_like, normal vector of plane.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">pt</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">func</span>

<div class="viewcode-block" id="xplane">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.xplane.html#mymesh.implicit.xplane">[docs]</a>
<span class="k">def</span> <span class="nf">xplane</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a plane whose normal direction is along the x axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x0 : float</span>
<span class="sd">        Coordinate along the x axis of the plane. x0 = 0 corresponds to the </span>
<span class="sd">        yz plane.</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        Direction (1 or -1), or a scaling factor, by default 1. If n &gt; 0, the </span>
<span class="sd">        function will be negative when evaluated above x0.</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span></div>


<div class="viewcode-block" id="yplane">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.yplane.html#mymesh.implicit.yplane">[docs]</a>
<span class="k">def</span> <span class="nf">yplane</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a plane whose normal direction is along the y axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y0 : float</span>
<span class="sd">        Coordinate along the y axis of the plane. y0 = 0 corresponds to the </span>
<span class="sd">        xz plane.</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        Direction (1 or -1), or a scaling factor, by default 1. If n &gt; 0, the </span>
<span class="sd">        function will be negative when evaluated above y0.</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span></div>


<div class="viewcode-block" id="zplane">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.zplane.html#mymesh.implicit.zplane">[docs]</a>
<span class="k">def</span> <span class="nf">zplane</span><span class="p">(</span><span class="n">z0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a plane whose normal direction is along the z axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z0 : float</span>
<span class="sd">        Coordinate along the x axis of the plane. z0 = 0 corresponds to the </span>
<span class="sd">        xy plane.</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        Direction (1 or -1), or a scaling factor, by default 1. If n &gt; 0, the </span>
<span class="sd">        function will be negative when evaluated above z0.</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">z0</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span></div>


<div class="viewcode-block" id="sphere">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.sphere.html#mymesh.implicit.sphere">[docs]</a>
<span class="k">def</span> <span class="nf">sphere</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : array_like</span>
<span class="sd">        3D coordinates ([x, y, z]) of the center of the sphere.</span>
<span class="sd">    radius : float</span>
<span class="sd">        radius of the sphere.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z).</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.sphere([0,0,0],1), [-1,1,-1,1,-1,1], 0.1)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">func</span></div>


<div class="viewcode-block" id="torus">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.torus.html#mymesh.implicit.torus">[docs]</a>
<span class="k">def</span> <span class="nf">torus</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a torus oriented about the z-axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : array_like</span>
<span class="sd">        3D coordinates ([x, y, z]) of the center of the torus.</span>
<span class="sd">    R : float</span>
<span class="sd">        The major axis of the torus. This is the distance from the center of the </span>
<span class="sd">        torus to the center of the circular tube. </span>
<span class="sd">    r : float</span>
<span class="sd">        The minor axis of the torus. This is the radius of the circular tube. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z).</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.torus([0,0,0], 1, .25), [-1.25,1.25,-1.25,1.25,-.3,.3], 0.1)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="p">(((</span><span class="n">x</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">func</span></div>


<span class="c1"># Implicit Function Operators</span>
<div class="viewcode-block" id="offset">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.offset.html#mymesh.implicit.offset">[docs]</a>
<span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Offset function values by a prescribed amount. For a signed </span>
<span class="sd">    distance function, this offsets the isosurface by a specified distance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fval : scalar or np.ndarray</span>
<span class="sd">        Function value(s) to be offset</span>
<span class="sd">    value : scalar</span>
<span class="sd">        Offset value</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    offset_val : scalar or np.ndarray</span>
<span class="sd">        Offset value(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">offset_val</span> <span class="o">=</span> <span class="n">fval</span><span class="o">-</span><span class="n">value</span>
    <span class="k">return</span> <span class="n">offset_val</span></div>


<div class="viewcode-block" id="union">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.union.html#mymesh.implicit.union">[docs]</a>
<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean union of two values or sets of values. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMin` minimum is used to obtain a </span>
<span class="sd">    continuously differentiable output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fval1 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the first function</span>
<span class="sd">    fval2 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the second function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    union_val : scalar or np.ndarray</span>
<span class="sd">        Union of the two sets of values</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">union_val</span> <span class="o">=</span> <span class="n">rMin</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">union_val</span></div>


<div class="viewcode-block" id="diff">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.diff.html#mymesh.implicit.diff">[docs]</a>
<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean difference of two values or sets of values. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMax` maximum is used to obtain a </span>
<span class="sd">    continuously differentiable output. Note that this operation is not </span>
<span class="sd">    symmetric so the order of inputs matters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fval1 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the first function</span>
<span class="sd">    fval2 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the second function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diff_val : scalar or np.ndarray</span>
<span class="sd">        Difference of the two sets of values</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">diff_val</span> <span class="o">=</span> <span class="n">rMax</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="o">-</span><span class="n">fval2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">diff_val</span></div>


<span class="k">def</span> <span class="nf">diff_old</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">):</span>
    <span class="c1"># warnings.warn(&#39;This function will be removed in the future.&#39;)</span>
    <span class="k">return</span> <span class="n">rMin</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="o">-</span><span class="n">fval2</span><span class="p">)</span>
    
<div class="viewcode-block" id="intersection">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.intersection.html#mymesh.implicit.intersection">[docs]</a>
<span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean intersection of two values or sets of values. Negative values are </span>
<span class="sd">    assumed to be &quot;inside&quot;. An R-function :func:`rMax` maximum is used to </span>
<span class="sd">    obtain a continuously differentiable output. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fval1 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the first function</span>
<span class="sd">    fval2 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the second function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    intersection_val : scalar or np.ndarray</span>
<span class="sd">        Intersection of the two sets of values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intersection_val</span> <span class="o">=</span> <span class="n">rMax</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">intersection_val</span></div>


<div class="viewcode-block" id="thicken">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.thicken.html#mymesh.implicit.thicken">[docs]</a>
<span class="k">def</span> <span class="nf">thicken</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Thicken an isosurface by offsetting in both directions. The surface</span>
<span class="sd">    is offset in both directions by t/2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fval : scalar or np.ndarray</span>
<span class="sd">        Function value(s) to be offset</span>
<span class="sd">    t : scalar</span>
<span class="sd">        Thickness value. For a signed distance function, this will correspond</span>
<span class="sd">        to an actual thickness, for other implicit functions, the offset distance</span>
<span class="sd">        depends on the function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    thick : scalar or np.ndarray</span>
<span class="sd">        Thickened value(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">thick</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">offp</span><span class="p">,</span> <span class="n">offn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">thick</span></div>


<span class="k">def</span> <span class="nf">offsetf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Offset function by a prescribed amount. For a signed </span>
<span class="sd">    distance function, this offsets the isosurface by a specified distance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>
<span class="sd">    value : scalar</span>
<span class="sd">        Offset value</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    offset_fun : callable</span>
<span class="sd">        Offset funcion</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">offset_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">offset</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">offset_fun</span>

<div class="viewcode-block" id="unionf">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.unionf.html#mymesh.implicit.unionf">[docs]</a>
<span class="k">def</span> <span class="nf">unionf</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean union of two functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMin` minimum is used to obtain a </span>
<span class="sd">    continuously differentiable output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f1 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>
<span class="sd">    f2 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    union_fun : callable</span>
<span class="sd">        Union function</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">union_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">rMin</span><span class="p">(</span><span class="n">f1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="n">f2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">union_fun</span></div>


<div class="viewcode-block" id="difff">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.difff.html#mymesh.implicit.difff">[docs]</a>
<span class="k">def</span> <span class="nf">difff</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean difference of two functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMax` maximum is used to obtain a </span>
<span class="sd">    continuously differentiable output. Note that this operation is not </span>
<span class="sd">    symmetric so the order of inputs matters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f1 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>
<span class="sd">    f2 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diff_fun : callable</span>
<span class="sd">        Difference of the two functions</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">diff_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">rMax</span><span class="p">(</span><span class="n">f1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="o">-</span><span class="n">f2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">diff_fun</span></div>


<div class="viewcode-block" id="intersectionf">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.intersectionf.html#mymesh.implicit.intersectionf">[docs]</a>
<span class="k">def</span> <span class="nf">intersectionf</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean intersection of two functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMax` maximum is used to obtain a </span>
<span class="sd">    continuously differentiable output. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f1 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>
<span class="sd">    f2 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    intersection_fun : callable</span>
<span class="sd">        Intersection of the two functions</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">intersection_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">rMax</span><span class="p">(</span><span class="n">f1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="n">f2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">intersection_fun</span></div>


<div class="viewcode-block" id="thickenf">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.thickenf.html#mymesh.implicit.thickenf">[docs]</a>
<span class="k">def</span> <span class="nf">thickenf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Thicken an implicit function by offsetting in both directions. The surface</span>
<span class="sd">    is offset in both directions by t/2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>
<span class="sd">    t : scalar</span>
<span class="sd">        Thickness value. For a signed distance function, this will correspond</span>
<span class="sd">        to an actual thickness, for other implicit functions, the offset distance</span>
<span class="sd">        depends on the function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    thick_fun : callable</span>
<span class="sd">        Thickened function</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offsetf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offsetf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">thick_fun</span> <span class="o">=</span> <span class="n">difff</span><span class="p">(</span><span class="n">offp</span><span class="p">,</span> <span class="n">offn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">thick_fun</span></div>


<div class="viewcode-block" id="unions">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.unions.html#mymesh.implicit.unions">[docs]</a>
<span class="k">def</span> <span class="nf">unions</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="n">symfun2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean union of two symbolic functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMins` minimum is used to obtain a </span>
<span class="sd">    continuously differentiable output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    symfun1 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>
<span class="sd">    symfun2 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    union_sym : Scalar or np.ndarray</span>
<span class="sd">        Symbolic union function</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">union_sym</span> <span class="o">=</span> <span class="n">rMins</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="n">symfun2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">union_sym</span></div>


<div class="viewcode-block" id="diffs">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.diffs.html#mymesh.implicit.diffs">[docs]</a>
<span class="k">def</span> <span class="nf">diffs</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="n">symfun2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean difference of two symbolic functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMaxs` minimum is used to obtain a </span>
<span class="sd">    continuously differentiable output. Note that this operation is not </span>
<span class="sd">    symmetric so the order of inputs matters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    symfun1 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>
<span class="sd">    symfun2 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diff_sym : sympy function</span>
<span class="sd">        Symbolic difference function</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">diff_sym</span> <span class="o">=</span> <span class="n">rMaxs</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="o">-</span><span class="n">symfun2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">diff_sym</span></div>


<div class="viewcode-block" id="intersections">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.intersections.html#mymesh.implicit.intersections">[docs]</a>
<span class="k">def</span> <span class="nf">intersections</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="n">symfun2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean intersection of two symbolic functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMaxs` minimum is used to obtain a </span>
<span class="sd">    continuously differentiable output. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    symfun1 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>
<span class="sd">    symfun2 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diff_sym : sympy function</span>
<span class="sd">        Symbolic difference function</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">intersection_sym</span> <span class="o">=</span> <span class="n">rMaxs</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="n">symfun2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">intersection_sym</span></div>


<div class="viewcode-block" id="thickens">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.thickens.html#mymesh.implicit.thickens">[docs]</a>
<span class="k">def</span> <span class="nf">thickens</span><span class="p">(</span><span class="n">symfun</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">symfun</span><span class="p">,</span> <span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">symfun</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">thick</span> <span class="o">=</span> <span class="n">diffs</span><span class="p">(</span><span class="n">offp</span><span class="p">,</span> <span class="n">offn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">thick</span></div>


<div class="viewcode-block" id="rMax">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.rMax.html#mymesh.implicit.rMax">[docs]</a>
<span class="k">def</span> <span class="nf">rMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># R-Function :cite:p:`Shapiro1999` version of max(a,b) to yield a smoothly differentiable max - R0</span>
    <span class="c1"># Implicit Functions With Guaranteed Differential Properties - Shapiro &amp; Tsukanov</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">p</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="rMin">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.rMin.html#mymesh.implicit.rMin">[docs]</a>
<span class="k">def</span> <span class="nf">rMin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># R-Function :cite:p:`Shapiro1999` version of min(a,b) to yield a smoothly differentiable min - R0</span>
    <span class="c1"># Implicit Functions With Guaranteed Differential Properties - Shapiro &amp; Tsukanov</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">p</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">rMaxs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># R-Function version of max(a,b) to yield a smoothly differentiable max - R0</span>
    <span class="c1"># Implicit Functions With Guaranteed Differential Properties - Shapiro &amp; Tsukanov</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">p</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rMins</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># R-Function version of min(a,b) to yield a smoothly differentiable min - R0</span>
    <span class="c1"># Implicit Functions With Guaranteed Differential Properties - Shapiro &amp; Tsukanov</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">p</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

<div class="viewcode-block" id="grid2fun">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.grid2fun.html#mymesh.implicit.grid2fun">[docs]</a>
<span class="k">def</span> <span class="nf">grid2fun</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">,</span><span class="n">Vals</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a voxel grid mesh into a function that can be evaluated at any point within the bounds of the grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : List of Lists</span>
<span class="sd">        List of nodal coordinates for the voxel mesh</span>
<span class="sd">    VoxelConn : List of Lists</span>
<span class="sd">       Nodal connectivity list for the voxel mesh.</span>
<span class="sd">    Vals : list</span>
<span class="sd">        List of values at each node or at each element.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fun : function</span>
<span class="sd">        Interpolation function, takes arguments (x,y,z), to return an</span>
<span class="sd">        evaluation of the function at the specified point.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">):</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">Vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">VoxelConn</span><span class="p">):</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Vals must be the same length as either VoxelCoords or VoxelConn&#39;</span><span class="p">)</span>
    <span class="c1"># VoxelCoords = np.array(VoxelCoords)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Vals</span><span class="p">,[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">)])</span>
    
    <span class="n">V</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">V</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">RegularGridInterpolator</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fun</span></div>


<div class="viewcode-block" id="grid2grad">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.grid2grad.html#mymesh.implicit.grid2grad">[docs]</a>
<span class="k">def</span> <span class="nf">grid2grad</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">,</span><span class="n">NodeVals</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a voxel grid mesh into a function. The function can be evaluated at any point within the bounds of the grid to return the gradient of the function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : List of Lists</span>
<span class="sd">        List of nodal coordinates for the voxel mesh</span>
<span class="sd">    VoxelConn : List of Lists</span>
<span class="sd">       Nodal connectivity list for the voxel mesh.</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of values at each node.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frad : function</span>
<span class="sd">        Interpolation function, takes arguments (x,y,z), to return an</span>
<span class="sd">        evaluation of the function gradient at the specified point.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">VoxelCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">,[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">)])</span>
    <span class="c1"># Assumes (and requires) that all voxels are cubic and the same size</span>
    <span class="n">VoxelSize</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]))</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">VoxelSize</span><span class="p">)</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interpn</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>
    
    <span class="k">return</span> <span class="n">grad</span></div>


<span class="k">def</span> <span class="nf">FastMarchingMethod</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span> <span class="n">VoxelConn</span><span class="p">,</span> <span class="n">NodeVals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FastMarchingMethod based on J.A. Sethian. A Fast Marching Level Set Method</span>
<span class="sd">    for Monotonically Advancing Fronts, Proc. Natl. Acad. Sci., 93, 4, </span>
<span class="sd">    pp.1591--1595, 1996</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : list</span>
<span class="sd">        List of nodal coordinates for the voxel mesh.</span>
<span class="sd">    VoxelConn : list</span>
<span class="sd">        Nodal connectivity list for the voxel mesh.</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of value at each node.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T : list</span>
<span class="sd">        Lists of reinitialized node values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;FastMarchingMethod is not fully functional.&#39;</span><span class="p">)</span>

    <span class="c1"># 3D</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="c1"># For now this is only for obtaining a signed distance function, so F = 1 everywhere</span>
    <span class="n">F</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)</span>
    <span class="c1"># Get Neighbors</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">ElemType</span> <span class="o">=</span> <span class="s1">&#39;quad&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ElemType</span> <span class="o">=</span> <span class="s1">&#39;hex&#39;</span>
    <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span> <span class="n">VoxelConn</span><span class="p">,</span> <span class="n">ElemType</span><span class="o">=</span><span class="n">ElemType</span><span class="p">)</span>
    <span class="n">xNeighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">))]</span>
    <span class="n">yNeighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">))]</span>
    <span class="n">zNeighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">))]</span>
    <span class="c1"># Assumes (and requires) that all voxels are the same size</span>
    <span class="n">h</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])))</span>
    <span class="c1"># Initialize Labels - Accepted if on the surface, Narrow Band if an adjacent node has a different sign (i.e. cross the surface), otherwise Far</span>
    <span class="n">Accepted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">Narrow</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Accepted</span><span class="p">]</span>
    <span class="n">NarrowVals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Narrow</span><span class="p">:</span>
        <span class="n">crosses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]):</span>
                <span class="n">crosses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="mi">0</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">yNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]):</span>
                <span class="n">crosses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="mi">0</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">zNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]):</span>
                <span class="n">crosses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="mi">0</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
        <span class="c1"># NarrowVals.append(np.mean(crosses))</span>
        <span class="n">NarrowVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">crosses</span><span class="p">))</span>
    <span class="n">Far</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">Accepted</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">Narrow</span><span class="p">)))</span>
    <span class="c1"># Initialize Values (inf for Far, 0 for accepted)</span>
    <span class="n">infty</span> <span class="o">=</span> <span class="mf">1e16</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">infty</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NarrowVals</span><span class="p">)):</span>
        <span class="n">T</span><span class="p">[</span><span class="n">Narrow</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">NarrowVals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Accepted</span><span class="p">:</span>
        <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">Nar</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">NarrowVals</span><span class="p">,</span><span class="n">Narrow</span><span class="p">))],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Far</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nar</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nar</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">Nar</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">Far</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">Nar</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">))</span>
        <span class="n">Accepted</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="n">Nar</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">[</span><span class="n">pt</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Far</span><span class="p">:</span>
                <span class="n">Far</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">Nar</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">Nar</span><span class="p">,</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">)),</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Accepted</span><span class="p">:</span>
                <span class="c1"># Eikonal Update:</span>
                <span class="n">Tx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">T</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xNeighbors</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">Ty</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">T</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">yNeighbors</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">Tz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">T</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zNeighbors</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                
                <span class="n">discriminant</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">Tx</span><span class="p">,</span><span class="n">Ty</span><span class="p">,</span><span class="n">Tz</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">N</span><span class="o">*</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">Tx</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">Ty</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">Tz</span><span class="o">**</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">discriminant</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">N</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="n">Tx</span><span class="p">,</span><span class="n">Ty</span><span class="p">,</span><span class="n">Tz</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">N</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">discriminant</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="n">F</span> <span class="o">+</span> <span class="nb">min</span><span class="p">([</span><span class="n">Tx</span><span class="p">,</span><span class="n">Ty</span><span class="p">,</span><span class="n">Tz</span><span class="p">])</span>
                                
                <span class="n">Nar</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">Nar</span><span class="p">,</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">Nar</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">Nar</span><span class="p">,</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">)),</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n</span><span class="p">))</span>        
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">t</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">else</span> <span class="n">t</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">T</span>

<div class="viewcode-block" id="mesh2sdf">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.mesh2sdf.html#mymesh.implicit.mesh2sdf">[docs]</a>
<span class="k">def</span> <span class="nf">mesh2sdf</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nodes+centroids&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a signed distance field for a mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : mesh.mesh</span>
<span class="sd">        Mesh object that will be used to define the distance field.</span>
<span class="sd">    points : array_like</span>
<span class="sd">        Points at which the signed distance field will be evaluated.</span>
<span class="sd">    method : str</span>
<span class="sd">        Method to be used </span>
<span class="sd">        nodes </span>
<span class="sd">        nodes+centroids</span>
<span class="sd">        centroids</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of signed distance values evaluated at each node in the voxel grid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nodes&#39;</span><span class="p">:</span>
        <span class="n">Normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeNormals</span><span class="p">)</span>
        <span class="n">SurfNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfNodes</span><span class="p">)</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">SurfNodes</span> <span class="k">else</span> <span class="p">[</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;centroids&#39;</span><span class="p">:</span>
        <span class="n">Normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">ElemNormals</span><span class="p">)</span>
        <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">M</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span> <span class="c1">#np.array([np.mean(NodeCoords[elem],axis=0) for elem in M.SurfConn])</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nodes+centroids&#39;</span><span class="p">:</span>
        <span class="n">Normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeNormals</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">ElemNormals</span><span class="p">))</span>
        <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">SurfNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfNodes</span><span class="p">)</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">SurfNodes</span> <span class="k">else</span> <span class="p">[</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)],</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">M</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid method - use &quot;nodes&quot;, &quot;centroids&quot;, or &quot;nodes+centroids&quot;&#39;</span><span class="p">)</span>
    
    <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">Coords</span><span class="p">)</span>  
    <span class="n">Out</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">Out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">Out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">points</span> <span class="o">-</span> <span class="n">Coords</span><span class="p">[</span><span class="n">cs</span><span class="p">]</span>
    <span class="n">signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rs</span><span class="o">*</span><span class="n">Normals</span><span class="p">[</span><span class="n">cs</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="c1"># [np.sign(np.dot(rs[i],Normals[cs[i]])) for i in range(len(ds))]</span>
    <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">signs</span><span class="o">*</span><span class="n">ds</span>
    
    <span class="k">return</span> <span class="n">NodeVals</span></div>


<div class="viewcode-block" id="mesh2udf">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.mesh2udf.html#mymesh.implicit.mesh2udf">[docs]</a>
<span class="k">def</span> <span class="nf">mesh2udf</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates an unsigned distance field for a mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : mesh.mesh</span>
<span class="sd">        Mesh object that will be used to define the distance field.</span>
<span class="sd">    points : array_like</span>
<span class="sd">        Points at which the signed distance field will be evaluated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of signed distance values evaluated at each node in the voxel grid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">Coords</span><span class="p">)</span>  
    <span class="n">Out</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">Out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">NodeVals</span></div>


<span class="k">def</span> <span class="nf">DoubleDualResampling</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;DoubleDualResampling is not fully functional and may be unstable.&#39;</span><span class="p">)</span>

    <span class="c1"># Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277284. https://doi.org/10.1115/1.1559153</span>
    <span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">gradP</span> <span class="o">=</span> <span class="n">DualMeshOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span><span class="n">return_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">DualNeighbors</span><span class="p">,</span><span class="n">ElemConn</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">ElemType</span><span class="o">=</span><span class="s1">&#39;polygon&#39;</span><span class="p">)</span>
    <span class="n">NewNodeCoords</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">))]</span>
    <span class="n">gradPnorms</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradP</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradP</span><span class="p">))]</span>
    <span class="n">Normals</span> <span class="o">=</span> <span class="p">[</span><span class="n">gradP</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">gradPnorms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">if</span> <span class="n">gradPnorms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">utils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,[</span><span class="n">DualConn</span><span class="p">[</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]])[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)):</span>
        <span class="n">Ps</span> <span class="o">=</span> <span class="n">DualConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># Ns = [gradP[j]/gradPnorms[j] if gradPnorms[j] &gt; 0 else utils.CalcFaceNormal(DualCoords,[Ps])[0] for j in Ps]</span>
        <span class="n">ks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">Pj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ps</span><span class="p">):</span>
            <span class="n">NeighborPs</span> <span class="o">=</span> <span class="n">DualNeighbors</span><span class="p">[</span><span class="n">Pj</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span>
            <span class="c1"># NNPs =[gradP[k]/gradPnorms[k] for k in NeighborPs]</span>
            <span class="c1"># ks.append(sum([np.arccos(np.dot(Ns[j],NNPs[k]))/(np.linalg.norm(DualCoords[Pj])*np.linalg.norm(DualCoords[NeighborPs[k]]))  for k in range(len(NNPs))]))</span>
            
            <span class="n">ks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Normals</span><span class="p">[</span><span class="n">Pj</span><span class="p">],</span><span class="n">Normals</span><span class="p">[</span><span class="n">NeighborPs</span><span class="p">[</span><span class="n">k</span><span class="p">]]),</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">[</span><span class="n">Pj</span><span class="p">],</span><span class="n">DualCoords</span><span class="p">[</span><span class="n">NeighborPs</span><span class="p">[</span><span class="n">k</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NeighborPs</span><span class="p">))]))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;merp&#39;</span><span class="p">)</span>
        
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">ki</span> <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">]</span>
        
        <span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">DualCoords</span><span class="p">[</span><span class="n">Ps</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ps</span><span class="p">))])</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">NewNodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span>
    
<span class="k">def</span> <span class="nf">DualMeshOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">return_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277284. https://doi.org/10.1115/1.1559153</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;DualMeshOptimization is not fully functional and may be unstable.&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">GradF</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">g</span><span class="p">])</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">g</span><span class="p">])</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">z</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">g</span><span class="p">])</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">dF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
        <span class="n">dFq</span> <span class="o">=</span> <span class="p">[</span><span class="n">dF</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">dF</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">dF</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">dFq</span>
    <span class="k">def</span> <span class="nf">bisection</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">eps</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">fa</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">fa</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;Invalid bounds for bisection&#39;</span>
        
        <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">thinking</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">fc</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
            <span class="c1"># if fc == 0 or (np.linalg.norm(b-a)/2) &lt; tol:</span>
                <span class="c1"># merp = &#39;meep&#39;</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">fa</span><span class="p">):</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="n">fa</span> <span class="o">=</span> <span class="n">fc</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="n">fb</span> <span class="o">=</span> <span class="n">fc</span>                
        <span class="k">return</span> <span class="n">c</span>
    <span class="k">def</span> <span class="nf">secant</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">eps</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">fa</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">fa</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;Invalid bounds for secant method&#39;</span>
        <span class="n">origA</span><span class="p">,</span> <span class="n">origB</span><span class="p">,</span> <span class="n">origFa</span><span class="p">,</span> <span class="n">origFb</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">fb</span>
        <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">thinking</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">fb</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">fb</span><span class="o">-</span><span class="n">fa</span><span class="p">))</span>
            <span class="n">fc</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fc</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span><span class="n">c</span>
                <span class="n">fa</span><span class="p">,</span><span class="n">fb</span> <span class="o">=</span> <span class="n">fb</span><span class="p">,</span><span class="n">fc</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="ow">or</span> <span class="n">fa</span> <span class="o">==</span> <span class="n">fb</span><span class="p">:</span>
                <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">origA</span><span class="p">,</span> <span class="n">origB</span><span class="p">,</span> <span class="n">origFa</span><span class="p">,</span> <span class="n">origFb</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">])):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">origA</span><span class="p">,</span> <span class="n">origB</span><span class="p">,</span> <span class="n">origFa</span><span class="p">,</span> <span class="n">origFb</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">c</span>
    <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    
    <span class="c1"># _,ElemConn = utils.getNodeNeighbors(NodeCoords,NodeConn)</span>
    <span class="c1"># DualCoords,DualConn = converter.surf2dual(ArrayCoords,NodeConn,ElemConn=ElemConn)</span>
    
    <span class="c1"># Optimize dual mesh coordinates     </span>
    <span class="n">gradP</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">P</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">):</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">NodeConn</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
        <span class="n">edgelengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">edgelengths</span><span class="p">)</span>
        <span class="n">lamb</span> <span class="o">=</span> <span class="n">e</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">fP</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">P</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fP</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_grad</span><span class="p">:</span>
                <span class="n">gradP</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">GradF</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">lamb</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
                <span class="c1"># gradP[c] = gradF(*P)[0]</span>
            <span class="k">continue</span>
        
        <span class="n">Q</span> <span class="o">=</span> <span class="n">P</span>
        <span class="n">fQ</span> <span class="o">=</span> <span class="n">fP</span>

        <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">thinking</span><span class="p">:</span>
            <span class="n">dfQ</span> <span class="o">=</span> <span class="n">GradF</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">lamb</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
            <span class="c1"># dfQ = gradF(*Q)[0]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">dfQ</span><span class="p">,</span><span class="n">fQ</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">+</span> <span class="n">lamb</span><span class="o">*</span><span class="n">d</span>
            <span class="n">fR</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">R</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fQ</span><span class="o">*</span><span class="n">fR</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">P2</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">fQ</span><span class="p">,</span> <span class="n">fR</span><span class="p">)</span>
                <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">Q</span> <span class="o">=</span> <span class="n">R</span>
                <span class="n">fQ</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">Q</span><span class="p">)</span>
                <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">it</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">lamb</span> <span class="o">=</span> <span class="n">lamb</span><span class="o">/</span><span class="mi">2</span>
                <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
                    <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">P2</span> <span class="o">=</span> <span class="n">P</span>
                    <span class="c1"># raise Exception(&quot;Too many iterations - This probably shouldn&#39;t happen&quot;)</span>
        <span class="c1">#if np.linalg.norm(np.subtract(P2,P)) &lt; e:</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">P2</span>
        <span class="n">fS</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="o">*</span><span class="n">S</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fP</span><span class="o">*</span><span class="n">fS</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">P3</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">fP</span><span class="p">,</span> <span class="n">fS</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">P2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">P3</span><span class="p">)):</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">P2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">P3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">P2</span>
        <span class="c1"># P = P2</span>
        <span class="n">DualCoords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span>
        <span class="k">if</span> <span class="n">return_grad</span><span class="p">:</span> <span class="n">gradP</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">GradF</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">lamb</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
        <span class="c1"># if return_grad: gradP[c] = gradF(*P)[0]</span>
        
    <span class="k">if</span> <span class="n">return_grad</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span><span class="p">,</span> <span class="n">gradP</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span>
    
<span class="k">def</span> <span class="nf">AdaptiveSubdivision</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
    <span class="c1"># Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277284. https://doi.org/10.1115/1.1559153</span>
    <span class="k">def</span> <span class="nf">gradF</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">h</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">])</span>
        <span class="n">gradx</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="n">h</span>
        <span class="n">grady</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="n">h</span>
        <span class="n">gradz</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">h</span>
        <span class="n">gradf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">gradx</span><span class="p">,</span><span class="n">grady</span><span class="p">,</span><span class="n">gradz</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gradf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">gradf</span> <span class="o">=</span> <span class="n">gradf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">gradf</span>
    
    <span class="n">NewNodeCoords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">NewNodeConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getElemNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>

    <span class="c1">###</span>
    <span class="n">Points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cross</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">cross</span><span class="o">/</span><span class="n">norm</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">Area</span> <span class="o">=</span> <span class="n">norm</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">splitCentroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Points</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                          <span class="p">]),</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">splitCentroids2</span> <span class="o">=</span> <span class="n">splitCentroids</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">splitCentroids</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">gradFCi</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">splitCentroids2</span><span class="p">)</span>
    <span class="n">mCi</span> <span class="o">=</span> <span class="n">gradFCi</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradFCi</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">mCi2</span> <span class="o">=</span> <span class="n">mCi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">splitCentroids</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">en</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ElemNormals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">mCi2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">))])</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">en</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">id01</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
            <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">id12</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
            <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">id20</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
            <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">NewNodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">id01</span><span class="p">,</span><span class="n">id20</span><span class="p">],</span>
                <span class="p">[</span><span class="n">id01</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">id12</span><span class="p">],</span>
                <span class="p">[</span><span class="n">id20</span><span class="p">,</span><span class="n">id12</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">id01</span><span class="p">,</span><span class="n">id12</span><span class="p">,</span><span class="n">id20</span><span class="p">]</span>
                <span class="p">]</span>

    <span class="c1"># Check for neighbors of split elements</span>
    <span class="n">thinking</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;1-4&#39;</span>
    <span class="k">while</span> <span class="n">thinking</span><span class="p">:</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">NewNodeConn</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="c1"># Already subdivided</span>
                <span class="k">continue</span>
            <span class="n">nSplitNeighbors</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">SplitNeighbors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NewNodeConn</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeConn</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span> 
                    <span class="n">nSplitNeighbors</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">SplitNeighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;1-4&#39;</span> <span class="ow">and</span> <span class="n">nSplitNeighbors</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">changes</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">id01</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">id12</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">id20</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">NewNodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">id01</span><span class="p">,</span><span class="n">id20</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">id01</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">id12</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">id20</span><span class="p">,</span><span class="n">id12</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">id01</span><span class="p">,</span><span class="n">id12</span><span class="p">,</span><span class="n">id20</span><span class="p">]</span>
                    <span class="p">]</span>
                
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;1-2&#39;</span> <span class="ow">and</span> <span class="n">nSplitNeighbors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">changes</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">SplitNeighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="ow">and</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">SplitNeighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                    <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">NewNodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">idx</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                        <span class="p">]</span>
                <span class="k">elif</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">SplitNeighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="ow">and</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NodeConn</span><span class="p">[</span><span class="n">SplitNeighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                    <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">NewNodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">idx</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">)</span>
                    <span class="n">NewNodeCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="n">NewNodeCoords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">NewNodeConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">idx</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">idx</span><span class="p">]</span>
                        <span class="p">]</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;1-4&#39;</span> <span class="ow">and</span> <span class="n">changes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># After all necessary 1-4 splits are completed, perform 1-2 splits</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;1-2&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;1-2&#39;</span> <span class="ow">and</span> <span class="n">changes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">thinking</span> <span class="o">=</span> <span class="kc">False</span>
            
    <span class="n">NewNodeConn</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NewNodeConn</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">NewNodeConn</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span>
    <span class="n">NewNodeCoords</span><span class="p">,</span><span class="n">NewNodeConn</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">NewNodeCoords</span><span class="p">,</span><span class="n">NewNodeConn</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">NewNodeCoords</span><span class="p">,</span><span class="n">NewNodeConn</span>
     
<span class="k">def</span> <span class="nf">DualPrimalOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">nIter</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277284. https://doi.org/10.1115/1.1559153</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;DualPrimalOptimization is not fully functional and may be unstable.&#39;</span><span class="p">)</span>
       
    <span class="k">def</span> <span class="nf">PrimalMeshOptimization</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">gradP</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">DualConn</span><span class="p">),</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">DualCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">)</span>
        <span class="n">DualNeighbors</span><span class="p">,</span><span class="n">ElemConn</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">ElemType</span><span class="o">=</span><span class="s1">&#39;polygon&#39;</span><span class="p">)</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
        <span class="n">gradPnorms</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradP</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradP</span><span class="p">))]</span>
        <span class="n">TransCoords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">Pis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">DualConn</span><span class="p">):</span>
            
            <span class="c1"># Transfrom Coordinates to local system centered on the centroid</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="c1"># Normal vector TODO: gradP[i] could = 0 at sharp features, in this case, need to use something else (maybe the element normal of the primal element corresponding to the dual node)</span>
            <span class="c1"># Ns = [np.divide(gradP[i],gradPnorms[i]) for i in Pis]</span>
            <span class="n">Ns</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">gradP</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">gradPnorms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">if</span> <span class="n">gradPnorms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">utils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,[</span><span class="n">DualConn</span><span class="p">[</span><span class="n">ElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]])[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Pis</span><span class="p">]</span>
            
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">DualCoords</span><span class="p">[</span><span class="n">Pis</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">*</span><span class="mi">2</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)]),</span> 
                         <span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)]),</span>
                         <span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)])])</span>
            
            <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">TransCoords</span><span class="p">[</span><span class="n">Pis</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)]),</span> 
                 <span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">TransCoords</span><span class="p">[</span><span class="n">Pis</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)]),</span>
                 <span class="nb">sum</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">TransCoords</span><span class="p">[</span><span class="n">Pis</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">N</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ns</span><span class="p">)])]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">rcond</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">tau</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="c1"># Reset TransCoords</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">TransCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ArrayCoords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    
    <span class="n">OptCoords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="n">OptConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">3</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIter</span><span class="p">):</span>
        <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">surf2dual</span><span class="p">(</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">sort</span><span class="o">=</span><span class="s1">&#39;ccw&#39;</span><span class="p">)</span>
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_Dual.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
        <span class="n">OptCoords</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">DoubleDualResampling</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_PrimalResampled.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
        <span class="n">DualCoords</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_Dual2.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
        <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span><span class="p">,</span> <span class="n">gradP</span> <span class="o">=</span> <span class="n">DualMeshOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span><span class="n">return_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_DualOpt.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
        <span class="n">OptCoords</span> <span class="o">=</span> <span class="n">PrimalMeshOptimization</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">gradP</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_PrimalOpt.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
        <span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span> <span class="o">=</span> <span class="n">AdaptiveSubdivision</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
        <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_PrimalOptSub.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">tau</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span><span class="o">/</span><span class="mi">10</span>
    <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">surf2dual</span><span class="p">(</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">sort</span><span class="o">=</span><span class="s1">&#39;ccw&#39;</span><span class="p">)</span>
    <span class="n">OptCoords</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">DoubleDualResampling</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
    <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_PrimalResampled.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
    <span class="n">DualCoords</span><span class="p">,</span> <span class="n">DualConn</span><span class="p">,</span> <span class="n">gradP</span> <span class="o">=</span> <span class="n">DualMeshOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">,</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span><span class="n">return_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
    <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_DualOpt.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">)</span>
    <span class="n">OptCoords</span> <span class="o">=</span> <span class="n">PrimalMeshOptimization</span><span class="p">(</span><span class="n">DualCoords</span><span class="p">,</span><span class="n">DualConn</span><span class="p">,</span><span class="n">gradP</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">writeVTK</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">_PrimalOpt.vtk&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">OptCoords</span><span class="p">,</span><span class="n">OptConn</span>

<span class="k">def</span> <span class="nf">SurfFlowOptimization</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">ZRIter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">NZRIter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">NZIter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">Subdivision</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">FixedNodes</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span> <span class="n">gradF</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    <span class="n">C</span> <span class="o">=</span> <span class="mf">0.1</span>     <span class="c1"># Positive Constant</span>
    <span class="n">FreeNodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">FixedNodes</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">gradF</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">gradF</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">hdiff</span> <span class="o">=</span> <span class="mf">1e-6</span>    <span class="c1"># Finite Diff Step Size</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">])</span>
            <span class="n">gradx</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">hdiff</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">hdiff</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="n">hdiff</span>
            <span class="n">grady</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">hdiff</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">hdiff</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="n">hdiff</span>
            <span class="n">gradz</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">hdiff</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sdf</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">hdiff</span>
            <span class="n">gradf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">gradx</span><span class="p">,</span><span class="n">grady</span><span class="p">,</span><span class="n">gradz</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gradf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">gradf</span> <span class="o">=</span> <span class="n">gradf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">gradf</span>
    <span class="k">def</span> <span class="nf">NFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">gradC</span> <span class="o">=</span> <span class="o">-</span><span class="n">gradF</span><span class="p">(</span><span class="n">Centroids</span><span class="p">)</span>
        <span class="n">gradCnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gradCnorm</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradC</span><span class="p">),</span><span class="mi">1</span><span class="p">)))</span>
        
        <span class="c1"># This is a slower but more straightforward version of what is done below</span>
        <span class="c1"># A = np.array([sum([Area[e] for e in ElemConn[i]]) for i in range(len(NodeCoords))])</span>
        <span class="c1"># tau = 1/(1000*max(A))</span>
        <span class="c1"># N1 = tau*np.array([1/sum(Area[T] for T in ElemConn[i]) * sum([Area[T]*np.dot((Centroids[T]-P),m[T])*m[T] for T in ElemConn[i]]) for i,P in enumerate(NodeCoords)])</span>

        <span class="c1"># Converting the ragged ElemConn array to a padded rectangular array (R) for significant speed improvements</span>
        <span class="n">Area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Area</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">m</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">Centroids2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Centroids</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">Area2</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">tf</span><span class="o">*</span><span class="mf">.75</span> <span class="c1"># 1/(100*max(A))</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m2</span><span class="p">[</span><span class="n">R</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">Centroids2</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">-</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">m2</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Area2</span><span class="p">[</span><span class="n">R</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">C</span>
        <span class="k">return</span> <span class="n">N</span>
    <span class="k">def</span> <span class="nf">N2Flow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">):</span>
        
        <span class="c1"># Orthocenter coordinates: https://en.wikipedia.org/wiki/Triangle_center#Position_vectors</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">Points</span> <span class="o">=</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">wA</span> <span class="o">=</span> <span class="n">a</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">wB</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">wC</span> <span class="o">=</span> <span class="n">c</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># Orthocenters</span>
        <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">wA</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">wB</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wC</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">wA</span> <span class="o">+</span> <span class="n">wB</span> <span class="o">+</span> <span class="n">wC</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">H2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">H</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
        <span class="c1"># </span>
        <span class="n">lens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ElemConn</span><span class="p">]</span>
        <span class="n">maxlens</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Mask0</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">Masknan</span> <span class="o">=</span> <span class="n">Mask0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">Masknan</span><span class="p">[</span><span class="n">Mask0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="n">PH</span> <span class="o">=</span> <span class="p">(</span><span class="n">H2</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">-</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:])</span><span class="o">*</span><span class="n">Mask0</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">PHnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">PH</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">PH</span><span class="o">/</span><span class="n">PHnorm</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span>

        <span class="c1"># For each point, gives the node connectivity of each incident element</span>
        <span class="n">IncidentNodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)[</span><span class="n">R</span><span class="p">]</span><span class="o">*</span><span class="n">Masknan</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="c1">## TODO: This needs a speedup</span>
        <span class="n">OppositeEdges</span> <span class="o">=</span> <span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="o">==</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">else</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">IncidentNodes</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">IncidentNodes</span><span class="p">))]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Mask0</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">##</span>
        <span class="n">OppositeLength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">OppositeEdges</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">NodeCoords</span><span class="p">[</span><span class="n">OppositeEdges</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">TriAntiGradient</span> <span class="o">=</span> <span class="n">e</span><span class="o">*</span><span class="n">OppositeLength</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">PointAntiGradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">TriAntiGradient</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="k">for</span> <span class="n">E</span> <span class="ow">in</span> <span class="n">ElemConn</span><span class="p">])</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">degree</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span> <span class="o">*</span> <span class="n">PointAntiGradient</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">tic</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">N</span>
    <span class="k">def</span> <span class="nf">ZFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">fP</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">gradP</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="c1"># A = np.array([sum([Area[T] for T in ElemConn[i]]) for i in range(len(NodeCoords))])</span>
        <span class="n">Area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Area</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Area2</span><span class="p">[</span><span class="n">R</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># tau = 1/(500*max(A))</span>
        <span class="c1"># Z = np.divide(-2*(tau*A)[:,None]*(fP[:,None]*gradP),np.linalg.norm(fP[:,None]*gradP,axis=1)[:,None],where=(fP!=0)[:,None])</span>
        <span class="c1"># tau = tf*1/(100*max(A*np.linalg.norm(fP[:,None]*gradP,axis=1)))</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">tf</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fP</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">gradP</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">A</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">fP</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">gradP</span>
        <span class="k">return</span> <span class="n">Z</span>
    <span class="k">def</span> <span class="nf">Z2Flow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">):</span>
        <span class="n">fC</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="n">Centroids</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Centroids</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">Centroids</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">gradC</span> <span class="o">=</span> <span class="o">-</span><span class="n">gradF</span><span class="p">(</span><span class="n">Centroids</span><span class="p">)</span>
        <span class="n">Area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Area</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">fC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fC</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gradC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">gradC</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Area2</span><span class="p">[</span><span class="n">R</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Area2</span><span class="p">[</span><span class="n">R</span><span class="p">][:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">gradC</span><span class="p">[</span><span class="n">R</span><span class="p">]</span><span class="o">*</span><span class="n">fC</span><span class="p">[</span><span class="n">R</span><span class="p">][:,:,</span><span class="kc">None</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span>
        <span class="k">return</span> <span class="n">Z</span>
    <span class="k">def</span> <span class="nf">RFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">):</span>
        <span class="c1">### Old slow version ###</span>
        <span class="c1">#     U = [1/len(N)*sum([np.subtract(NodeCoords[n],NodeCoords[i]) for n in N]) for i,N in enumerate(NodeNeighbors)]</span>
        <span class="c1">#     R = C*np.array([U[i] - np.dot(U[i],NodeNormals[i])*NodeNormals[i] for i in range(len(NodeCoords))])</span>
        <span class="c1">###</span>
        <span class="n">lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">NodeNeighbors</span><span class="p">])</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">NodeNeighbors</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ArrayCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">NodeCoords</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">ArrayCoords</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="n">U</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lens</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Q</span> <span class="o">-</span> <span class="n">ArrayCoords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">U</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">NodeNormals</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">NodeNormals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">R</span>
    <span class="k">def</span> <span class="nf">NZRFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">NFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">ZFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">RFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">)</span>
        <span class="n">NZR</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="n">Z</span> <span class="o">+</span> <span class="n">R</span>
        <span class="k">return</span> <span class="n">NZR</span>
    <span class="k">def</span> <span class="nf">ZRFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">ZFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">RFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">)</span>
        <span class="n">ZR</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">+</span> <span class="n">R</span>
        <span class="k">return</span> <span class="n">ZR</span>
    <span class="k">def</span> <span class="nf">NZFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span> <span class="n">tf</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">NFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">ZFlow</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)</span>
        <span class="n">NZ</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="n">Z</span>
        <span class="k">return</span> <span class="n">NZ</span>
    <span class="k">def</span> <span class="nf">Flip</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">ElemNormals</span><span class="p">,</span> <span class="n">ElemNeighbors</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
        <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">NewConn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
        <span class="n">gradC</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">Centroids</span><span class="p">)</span>
        <span class="n">gradCnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gradCnorm</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradC</span><span class="p">),</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">NormalError</span> <span class="o">=</span> <span class="n">Area</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ElemNormals</span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="n">T</span><span class="p">]))</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ElemNormals</span><span class="p">))])</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">NormalError</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
            <span class="n">restart</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">while</span> <span class="n">restart</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># This condition checks if the flip will be legal</span>
                        <span class="k">continue</span>

                    <span class="n">Newi</span><span class="p">,</span><span class="n">Newj</span> <span class="o">=</span> <span class="n">improvement</span><span class="o">.</span><span class="n">FlipEdge</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NewConn</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                    <span class="p">[</span><span class="n">Ci</span><span class="p">,</span><span class="n">Cj</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Newi</span><span class="p">,</span><span class="n">Newj</span><span class="p">]))</span>
                    <span class="n">gradC</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Ci</span><span class="p">,</span><span class="n">Cj</span><span class="p">]))</span>
                    <span class="n">gradCnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">mi</span> <span class="o">=</span> <span class="n">gradC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">gradCnorm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">mj</span> <span class="o">=</span> <span class="n">gradC</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">gradCnorm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">[</span><span class="n">Ni</span><span class="p">,</span><span class="n">Nj</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Newi</span><span class="p">,</span><span class="n">Newj</span><span class="p">]))</span>
                    
                    <span class="n">Ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newi</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newi</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newi</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newi</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span><span class="o">/</span><span class="mi">2</span>
                    <span class="n">Aj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newj</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newj</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newj</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">-</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">Newj</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span><span class="o">/</span><span class="mi">2</span>
                    <span class="n">Ei</span> <span class="o">=</span> <span class="n">Ai</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ni</span><span class="p">,</span><span class="n">mi</span><span class="p">))</span>
                    <span class="n">Ej</span> <span class="o">=</span> <span class="n">Aj</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Nj</span><span class="p">,</span><span class="n">mj</span><span class="p">))</span>
                    <span class="c1"># Ei = np.arccos(np.dot(Ni,mi))</span>
                    <span class="c1"># Ej = np.arccos(np.dot(Nj,mj))</span>
                    <span class="n">OldError</span> <span class="o">=</span> <span class="n">NormalError</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">NormalError</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">NewError</span> <span class="o">=</span> <span class="n">Ei</span> <span class="o">+</span> <span class="n">Ej</span>
                    <span class="k">if</span> <span class="n">NewError</span> <span class="o">&lt;</span> <span class="n">OldError</span><span class="p">:</span>
                        <span class="n">NormalError</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ei</span><span class="p">;</span> <span class="n">NormalError</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ej</span>
                        <span class="n">NewConn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Newi</span><span class="p">;</span> <span class="n">NewConn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Newj</span>
                        
                        <span class="n">ENi</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">ENj</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">Si</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">Newi</span><span class="p">);</span> <span class="n">Sj</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">Newj</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Si</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="n">ENi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sj</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">NewConn</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="n">ENj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                        <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENi</span><span class="p">;</span> <span class="n">ElemNeighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENj</span>
                        <span class="n">restart</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">restart</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">NewConn</span><span class="p">,</span> <span class="n">ElemNeighbors</span>
    <span class="k">def</span> <span class="nf">Error</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">ElemNormals</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">):</span>
        <span class="n">fP</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">gradP</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">gradPnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradP</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">gradC</span> <span class="o">=</span> <span class="n">gradF</span><span class="p">(</span><span class="n">Centroids</span><span class="p">)</span>
        <span class="n">gradCnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">gradC</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gradCnorm</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradC</span><span class="p">),</span><span class="mi">1</span><span class="p">)))</span>

        <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Area</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">ElemConn</span><span class="p">,</span><span class="n">fillval</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">area</span><span class="p">[</span><span class="n">R</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">VertexError</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">Area</span><span class="p">))</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">((</span><span class="n">fP</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">gradPnorm</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">A</span><span class="p">)</span>
        <span class="n">NormalError</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">Area</span><span class="p">))</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Area</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ElemNormals</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">VertexError</span><span class="p">,</span> <span class="n">NormalError</span>

    <span class="c1"># edges = converter.surf2edges(NodeCoords,NodeConn)</span>
    <span class="c1"># if len(edges) &gt; 0: warnings.warn(&#39;Input mesh should be closed and contain no exposed edges.&#39;)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># mesh.mesh(NodeCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>

    <span class="k">if</span> <span class="n">Subdivision</span><span class="p">:</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">AdaptiveSubdivision</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
    <span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">DeleteDuplicateNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
    <span class="c1"># mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>

    <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span> 
    <span class="n">ElemConn</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getElemConnectivity</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getElemNeighbors</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
    <span class="c1"># NodeConn, ElemNeighbors = improvement.ValenceImprovementFlips(NodeCoords,NodeConn,NodeNeighbors,ElemNeighbors)</span>
    <span class="c1"># vE = [];    nE = []   </span>
    <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">Face2NodeNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">ElemNormals</span><span class="p">))</span>
    
    <span class="n">tfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">ZRIter</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ZRIter</span><span class="p">):</span>
        <span class="n">tf</span> <span class="o">=</span> <span class="n">tfs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">Points</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
        <span class="n">Area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>   
        <span class="n">Centroids</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
        <span class="c1"># v,n = Error(NewCoords, ElemConn, ElemNormals, Area, Centroids); vE.append(v); nE.append(n)</span>
        <span class="n">NewCoords</span><span class="p">[</span><span class="n">FreeNodes</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ZRFlow</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span> <span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span>
        <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">Face2NodeNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">ElemNormals</span><span class="p">))</span>
        <span class="c1"># mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NZRIter</span><span class="p">):</span>
        <span class="n">Points</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
        <span class="n">Area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>   
        <span class="n">Centroids</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
        <span class="c1"># v,n = Error(NewCoords, ElemConn, ElemNormals, Area, Centroids); vE.append(v); nE.append(n)</span>
        <span class="n">NewCoords</span><span class="p">[</span><span class="n">FreeNodes</span><span class="p">]</span> <span class="o">+=</span> <span class="n">NZRFlow</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeNormals</span><span class="p">,</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span>
        <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
        <span class="n">NodeNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">Face2NodeNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">ElemNormals</span><span class="p">))</span>
        <span class="c1"># mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>
    <span class="k">if</span> <span class="n">NZIter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">Subdivision</span><span class="p">:</span> <span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">AdaptiveSubdivision</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">NewCoords</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
        <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">)</span>
        <span class="n">NodeNeighbors</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>    
        <span class="n">ElemConn</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getElemConnectivity</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>    
        <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getElemNeighbors</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
        <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
        <span class="n">tfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">NZIter</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NZIter</span><span class="p">):</span>
        <span class="n">tf</span> <span class="o">=</span> <span class="n">tfs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">Points</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
        <span class="n">Area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>   
        <span class="n">Centroids</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>

        <span class="c1"># v,n = Error(NewCoords, ElemConn, ElemNormals, Area, Centroids)</span>
        <span class="c1"># vE.append(v); nE.append(n)</span>

        <span class="n">NewCoords</span><span class="p">[</span><span class="n">FreeNodes</span><span class="p">]</span> <span class="o">+=</span> <span class="n">NZFlow</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="p">[],</span> <span class="n">NodeNeighbors</span><span class="p">,</span> <span class="n">ElemConn</span><span class="p">,</span> <span class="n">Area</span><span class="p">,</span> <span class="n">Centroids</span><span class="p">,</span><span class="n">tf</span><span class="o">=</span><span class="n">tf</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span>
        
        <span class="n">NewElemNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">))</span>

        <span class="c1">### Check for near-intersections ###</span>
        <span class="c1"># Angles:</span>
        <span class="n">Points</span> <span class="o">=</span> <span class="n">NewCoords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)]</span>
        <span class="n">v01</span> <span class="o">=</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span> <span class="n">l01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v01</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">v12</span> <span class="o">=</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">];</span> <span class="n">l12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v12</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">v20</span> <span class="o">=</span> <span class="n">Points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">Points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">];</span> <span class="n">l20</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v20</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v01</span><span class="o">*-</span><span class="n">v20</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">l01</span><span class="o">*</span><span class="n">l20</span><span class="p">))</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v12</span><span class="o">*-</span><span class="n">v01</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">l12</span><span class="o">*</span><span class="n">l01</span><span class="p">))</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v20</span><span class="o">*-</span><span class="n">v12</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">l20</span><span class="o">*</span><span class="n">l12</span><span class="p">))</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Dihedrals:</span>
        <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">quality</span><span class="o">.</span><span class="n">SurfDihedralAngles</span><span class="p">(</span><span class="n">NewElemNormals</span><span class="p">,</span><span class="n">ElemNeighbors</span><span class="p">)</span>
        <span class="c1"># Normal Flipping:</span>
        <span class="n">NormDot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">NewElemNormals</span> <span class="o">*</span> <span class="n">ElemNormals</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">Risk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">angles</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dihedrals</span> <span class="o">&gt;</span> <span class="mi">175</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">NormDot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">Intersected</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">NZIter</span><span class="o">-</span><span class="mi">5</span><span class="p">:</span>
            <span class="c1"># NodeConn, ElemNeighbors = Flip(NewCoords,NodeConn,ElemNormals,ElemNeighbors,Area,Centroids)</span>
            <span class="n">IntersectionPairs</span> <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">SurfSelfIntersection</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">)</span>
            <span class="n">Intersected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">IntersectionPairs</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Risk</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">Intersected</span><span class="p">):</span>
            <span class="c1"># print(&#39;possible intersection&#39;)</span>
            <span class="n">ArrayConn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)</span>
            <span class="n">AtRiskElems</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Risk</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">Intersected</span>
            <span class="n">NeighborhoodElems</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ArrayConn</span><span class="p">[</span><span class="n">AtRiskElems</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ElemConn</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">PatchConn</span> <span class="o">=</span> <span class="n">ArrayConn</span><span class="p">[</span><span class="n">NeighborhoodElems</span><span class="p">]</span> 
            <span class="n">BoundaryEdges</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">surf2edges</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">PatchConn</span><span class="p">)</span>
            <span class="n">FixedNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">BoundaryEdges</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">])</span>
            <span class="n">NewCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">improvement</span><span class="o">.</span><span class="n">LocalLaplacianSmoothing</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">PatchConn</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">FixedNodes</span><span class="o">=</span><span class="n">FixedNodes</span><span class="p">))</span>

            <span class="c1"># NodeConn = improvement.AngleReductionFlips(NewCoords,NodeConn,NodeNeighbors)</span>
            <span class="n">NodeNeighbors</span><span class="p">,</span><span class="n">ElemConn</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getNodeNeighbors</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>    
            <span class="n">ElemNeighbors</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getElemNeighbors</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span><span class="n">NodeConn</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
            <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">CalcFaceNormal</span><span class="p">(</span><span class="n">NewCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ElemNormals</span> <span class="o">=</span> <span class="n">NewElemNormals</span>
        <span class="c1"># mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>
    <span class="c1"># px.line(y=vE).show()</span>
    <span class="c1"># px.line(y=nE).show()</span>
    <span class="k">return</span> <span class="n">NewCoords</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">NodeConn</span>





</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2023, Timothy O. Josephson.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.0.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>