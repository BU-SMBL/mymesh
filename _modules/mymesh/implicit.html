
<!DOCTYPE html>


<html lang="en" data-content_root="../../" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mymesh.implicit &#8212; MyMesh vdev Manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/mymesh.css?v=152078be" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=3ce10a4d"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=4ea706d9"></script>
    <script src="../../_static/thebelab-helper.js"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/mymesh/implicit';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="dev" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
    
    <img src="../../_static/mymesh_logo.png" class="logo__image only-light" alt="MyMesh vdev Manual - Home"/>
    <img src="../../_static/mymesh_logo.png" class="logo__image only-dark pst-js-only" alt="MyMesh vdev Manual - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../guide.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../theory.html">
    Theory Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../dev.html">
    Development
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/BU-SMBL/mymesh" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../guide.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../theory.html">
    Theory Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../dev.html">
    Development
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/BU-SMBL/mymesh" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">mymesh.implicit</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for mymesh.implicit</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Created on Fri Jan 14 17:43:57 2022</span>
<span class="c1"># @author: toj</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Implicit function meshing tools</span>

<span class="sd">An implicit function f(x,y,z) describes a surface in 3D where the surface is</span>
<span class="sd">located on the f(x,y,z) = 0 isosurface. The default convention used in this</span>
<span class="sd">module is that values less than zero are considered &quot;inside&quot; the surface,</span>
<span class="sd">and values above zero are considered &quot;outside&quot;. </span>


<span class="sd">.. currentmodule:: mymesh.implicit</span>


<span class="sd">Mesh Generation</span>
<span class="sd">===============</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    VoxelMesh</span>
<span class="sd">    SurfaceMesh</span>
<span class="sd">    TetMesh</span>
<span class="sd">    SurfaceNodeOptimization</span>

<span class="sd">Implicit Functions</span>
<span class="sd">==================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    gyroid</span>
<span class="sd">    lidinoid</span>
<span class="sd">    primitive</span>
<span class="sd">    neovius</span>
<span class="sd">    diamond</span>
<span class="sd">    cylinder</span>
<span class="sd">    box</span>
<span class="sd">    xplane</span>
<span class="sd">    yplane</span>
<span class="sd">    zplane</span>
<span class="sd">    sphere</span>
<span class="sd">    torus</span>

<span class="sd">Implicit Function Operators</span>
<span class="sd">===========================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    offset</span>
<span class="sd">    union</span>
<span class="sd">    diff</span>
<span class="sd">    thicken</span>
<span class="sd">    intersection</span>
<span class="sd">    unionf</span>
<span class="sd">    difff</span>
<span class="sd">    intersectionf</span>
<span class="sd">    thickenf</span>
<span class="sd">    unions</span>
<span class="sd">    diffs</span>
<span class="sd">    intersections</span>
<span class="sd">    thickens</span>
<span class="sd">    rMax</span>
<span class="sd">    rMin</span>

<span class="sd">Other Implicit Mesh Utilities</span>
<span class="sd">=============================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: submodules/</span>

<span class="sd">    mesh2sdf</span>
<span class="sd">    mesh2udf</span>
<span class="sd">    grid2fun</span>
<span class="sd">    grid2grad</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># %%</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">sparse</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span><span class="o">,</span><span class="w"> </span><span class="nn">os</span><span class="o">,</span><span class="w"> </span><span class="nn">time</span><span class="o">,</span><span class="w"> </span><span class="nn">copy</span><span class="o">,</span><span class="w"> </span><span class="nn">warnings</span><span class="o">,</span><span class="w"> </span><span class="nn">bisect</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">utils</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">contour</span><span class="p">,</span> <span class="n">quality</span><span class="p">,</span> <span class="n">improvement</span><span class="p">,</span> <span class="n">rays</span><span class="p">,</span> <span class="n">octree</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">primitives</span>

<span class="c1"># Mesh generators</span>
<span class="k">def</span><span class="w"> </span><span class="nf">PlanarMesh</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">Type</span><span class="o">=</span><span class="s1">&#39;surf&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a surface mesh of an implicit function </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function that describes the geometry of the object to be meshed. The function should be of the form v = f(x,y,z,*args,**kwargs) where x, y, and z are 1D numpy arrays of x, y and z coordinates and v is a 1D numpy array of function values. For method=&#39;mc&#39;, x, y, and z will be 3D coordinate arrays and v must be 3D as well. Additional arguments and keyword arguments may be passed through args and kwargs.</span>
<span class="sd">    bounds : array_like</span>
<span class="sd">        4 element array, list, or tuple with the minimum and maximum bounds in each direction that the function will be evaluated. This should be formatted as: [xmin, xmax, ymin, ymax]</span>
<span class="sd">    h : scalar, tuple</span>
<span class="sd">        Element side length. Can be specified as a single scalar value, or a three element tuple (or array_like).</span>
<span class="sd">    threshold : scalar</span>
<span class="sd">        Isovalue threshold to use for keeping/removing elements, by default 0.</span>
<span class="sd">    threshold_direction : signed integer</span>
<span class="sd">        If threshold_direction is negative (default), values less than or equal to the threshold will be considered &quot;inside&quot; the mesh and the opposite if threshold_direction is positive, by default -1.</span>
<span class="sd">    interpolation : str, optional</span>
<span class="sd">        Method of interpolation used for placing the vertices on the approximated isosurface. This can be &#39;midpoint&#39;, &#39;linear&#39;, or &#39;cubic&#39;, by default &#39;linear&#39;. </span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Tuple of additional positional arguments for func, by default ().</span>
<span class="sd">    kwargs : dict, optional</span>
<span class="sd">        Dictionary of additional keyword arguments for func, by default {}.</span>
<span class="sd">    Type : str, optional</span>
<span class="sd">        Mesh type, either &#39;surf&#39; for a triangular surface or</span>
<span class="sd">        &#39;line&#39; for a boundary mesh.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M : mymesh.mesh</span>
<span class="sd">        Mesh object containing the mesh.</span>

<span class="sd">        .. note:: Due to the ability to unpack the mesh object to NodeCoords and NodeConn, the NodeCoords and NodeConn array can be returned directly (instead of the mesh object) by running: ``NodeCoords, NodeConn = implicit.PlanarMesh(...)``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.gyroid, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">threshold_direction</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">X</span><span class="p">,</span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">Type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;surf&#39;</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;triangle&#39;</span>
    <span class="k">elif</span> <span class="n">Type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;line&#39;</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;edge&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid Type.&#39;</span><span class="p">)</span>
    <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">MarchingSquaresImage</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)</span>
    <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">M</span>

<div class="viewcode-block" id="VoxelMesh">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.VoxelMesh.html#mymesh.implicit.VoxelMesh">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">VoxelMesh</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate voxel mesh of an implicit function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function that describes the geometry of the object to be meshed. The function should be of the form v = f(x,y,z,*args,**kwargs) where x, y, and z are 1D numpy arrays of x, y and z coordinates and v is a 1D numpy array of function values. Additional arguments and keyword arguments may be passed through args and kwargs.</span>
<span class="sd">    bounds : array_like</span>
<span class="sd">        6 element array, list, or tuple with the minimum and maximum bounds in each direction that the function will be evaluated. This should be formatted as: [xmin, xmax, ymin, ymax, zmin, zmax]</span>
<span class="sd">    h : scalar, tuple</span>
<span class="sd">        Element side length. Can be specified as a single scalar value, or a three element tuple (or array_like).</span>
<span class="sd">    threshold : scalar</span>
<span class="sd">        Isovalue threshold to use for keeping/removing elements, by default 0.</span>
<span class="sd">    threshold_direction : signed integer</span>
<span class="sd">        If threshold_direction is negative (default), values less than or equal to the threshold will be considered &quot;inside&quot; the mesh and the opposite if threshold_direction is positive, by default -1.</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        Mode for determining which elements are kept, by default &#39;any&#39;.</span>
<span class="sd">        Voxels will be kept if:</span>
<span class="sd">        &#39;any&#39; - if any node of a voxel is inside the surface, </span>
<span class="sd">        &#39;all&#39; - if all nodes of a voxel are inside the surface, </span>
<span class="sd">        &#39;centroid&#39; - if the centroid of the voxel is inside the surface. Centroids performs additional evaluation of the function, which could slow mesh generation for expensive to evaluate functions,</span>
<span class="sd">        &#39;boundary&#39; - if the voxel contains values above and below the threshold,</span>
<span class="sd">        &#39;notrim&#39; - all voxels are kept</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Tuple of additional positional arguments for func, by default ().</span>
<span class="sd">    kwargs : dict, optional</span>
<span class="sd">        Dictionary of additional keyword arguments for func, by default {}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    voxel : mymesh.mesh</span>
<span class="sd">        Mesh object containing the voxel mesh. The values of the function at each node are stored in voxel.NodeData[&#39;func&#39;]</span>

<span class="sd">        .. note:: Due to the ability to unpack the mesh object to NodeCoords and NodeConn, the NodeCoords and NodeConn array can be returned directly (instead of the mesh object) by running: ``NodeCoords, NodeConn = implicit.VoxelMesh(...)``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        voxel = implicit.VoxelMesh(implicit.gyroid, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        voxel.plot(bgcolor=&#39;w&#39;, scalars=voxel.NodeData[&#39;func&#39;])</span>

<span class="sd">    &quot;&quot;&quot;</span>        
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>

    <span class="c1"># If func is a sympy-based function, convert it to numpy</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">GridConn</span> <span class="o">=</span> <span class="n">primitives</span><span class="o">.</span><span class="n">Grid</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">exact_h</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">Values</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">threshold_direction</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">NodeVals</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">Values</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">threshold</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">Values</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
            <span class="n">voxel</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">voxel</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">()</span>
        <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">return</span> <span class="n">voxel</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;notrim&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;centroid&#39;</span><span class="p">:</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">GridConn</span><span class="p">)</span>
            <span class="n">Inside</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">centroids</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">centroids</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">centroids</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">threshold</span>
            <span class="n">VoxelConn</span> <span class="o">=</span> <span class="n">GridConn</span><span class="p">[</span><span class="n">Inside</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Inside</span> <span class="o">=</span> <span class="n">NodeVals</span> <span class="o">&lt;=</span> <span class="n">threshold</span>
            <span class="n">ElemInsides</span> <span class="o">=</span> <span class="n">Inside</span><span class="p">[</span><span class="n">GridConn</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;any&#39;</span><span class="p">:</span>
                <span class="n">VoxelConn</span> <span class="o">=</span> <span class="n">GridConn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ElemInsides</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="n">VoxelConn</span> <span class="o">=</span> <span class="n">GridConn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ElemInsides</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span>
                <span class="n">VoxelConn</span> <span class="o">=</span> <span class="n">GridConn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ElemInsides</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ElemInsides</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;mode must be &quot;any&quot;, &quot;all&quot;, &quot;centroid&quot;, &quot;boundary&quot;, or &quot;notrim&quot;.&#39;</span><span class="p">)</span>

        <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">OriginalIds</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">RemoveNodes</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">)</span>
        <span class="n">Values</span> <span class="o">=</span> <span class="n">Values</span><span class="p">[</span><span class="n">OriginalIds</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>   
        <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">GridConn</span>
    
    <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
    <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Values</span>

    <span class="k">return</span> <span class="n">voxel</span></div>


<div class="viewcode-block" id="SurfaceMesh">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.SurfaceMesh.html#mymesh.implicit.SurfaceMesh">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">SurfaceMesh</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mc&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">mixed_elements</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">snap2surf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a surface mesh of an implicit function </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function that describes the geometry of the object to be meshed. The function should be of the form v = f(x,y,z,*args,**kwargs) where x, y, and z are 1D numpy arrays of x, y and z coordinates and v is a 1D numpy array of function values. For method=&#39;mc&#39;, x, y, and z will be 3D coordinate arrays and v must be 3D as well. Additional arguments and keyword arguments may be passed through args and kwargs.</span>
<span class="sd">    bounds : array_like</span>
<span class="sd">        6 element array, list, or tuple with the minimum and maximum bounds in each direction that the function will be evaluated. This should be formatted as: [xmin, xmax, ymin, ymax, zmin, zmax]</span>
<span class="sd">    h : scalar, tuple</span>
<span class="sd">        Element side length. Can be specified as a single scalar value, or a three element tuple (or array_like).</span>
<span class="sd">    threshold : scalar</span>
<span class="sd">        Isovalue threshold to use for keeping/removing elements, by default 0.</span>
<span class="sd">    threshold_direction : signed integer</span>
<span class="sd">        If threshold_direction is negative (default), values less than or equal to the threshold will be considered &quot;inside&quot; the mesh and the opposite if threshold_direction is positive, by default -1.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Surface triangulation method, by default &#39;mc&#39;.</span>
<span class="sd">        &#39;mc&#39; : Marching cubes (see contour.MarchingCubesImage) (default)</span>

<span class="sd">        &#39;mc33&#39; : Marching cubes 33 (see contour.MarchingCubes)</span>

<span class="sd">        &#39;mt&#39; : Marching tetrahedra (see contour.MarchingTetrahedra)</span>
<span class="sd">    interpolation : str, optional</span>
<span class="sd">        Method of interpolation used for placing the vertices on the approximated isosurface. This can be &#39;midpoint&#39;, &#39;linear&#39;, or &#39;cubic&#39;, by default &#39;linear&#39;. If &#39;cubic&#39; is selected, method is overridden to be &#39;mc&#39;. </span>
<span class="sd">    mixed_elements : bool, optional</span>
<span class="sd">        If marching tetrahedra is used, setting mixed_elements to True will allow</span>
<span class="sd">        for a surface mesh with a combination of quads and tris, by default False.</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Tuple of additional positional arguments for func, by default ().</span>
<span class="sd">    kwargs : dict, optional</span>
<span class="sd">        Dictionary of additional keyword arguments for func, by default {}.</span>
<span class="sd">    snap2surf : bool or float, optional</span>
<span class="sd">        Option to use :func:`~mymesh.contour.SnapGrid2Surf` which moves points</span>
<span class="sd">        of the background mesh to lie on the surface. If specified as a float </span>
<span class="sd">        in the range [0, 0.5], sets the snapping parameter which indicates</span>
<span class="sd">        the relative distance within which a point is snapped (0 = no snapping,</span>
<span class="sd">        0.5 = all possible points are snapped). If True, default snapping</span>
<span class="sd">        parameter of 0.2 is used. Snapping isn&#39;t compatible with method == &#39;mc&#39; </span>
<span class="sd">        or interpolation==&#39;cubic&#39;, if either of these options are selected,</span>
<span class="sd">        no snapping will occur, regardless of the snap2surf input. By default, </span>
<span class="sd">        True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    surface : mymesh.mesh</span>
<span class="sd">        Mesh object containing the surface mesh.</span>

<span class="sd">        .. note:: Due to the ability to unpack the mesh object to NodeCoords and NodeConn, the NodeCoords and NodeConn array can be returned directly (instead of the mesh object) by running: ``NodeCoords, NodeConn = implicit.SurfaceMesh(...)``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.gyroid, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">threshold_direction</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">snap2surf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">snap</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snap2surf</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">assert</span> <span class="n">snap2surf</span> <span class="o">&lt;=</span> <span class="mf">0.5</span> <span class="ow">and</span> <span class="n">snap2surf</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Snapping parameter must be in the range [0,0.5]&#39;</span>
        <span class="n">snap</span> <span class="o">=</span> <span class="n">snap2surf</span>
        <span class="n">snap2surf</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mc&#39;</span> <span class="ow">or</span> <span class="n">interpolation</span><span class="o">==</span><span class="s1">&#39;cubic&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;mc&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Using cubic interpolation overrides contour method to be marching cubes (&quot;mc&quot;).&#39;</span><span class="p">)</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="n">zs</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">MarchingCubesImage</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;original&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span><span class="n">VertexValues</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">SurfCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">SurfCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">SurfCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mc33&#39;</span><span class="p">:</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">vector_func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=</span><span class="n">threshold_direction</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;notrim&#39;</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">snap2surf</span><span class="p">:</span>
            <span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">SnapGrid2Surf</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">],</span> <span class="n">snap</span><span class="o">=</span><span class="n">snap</span><span class="p">)</span>
        <span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">MarchingCubes</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;33&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span><span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mt&#39;</span><span class="p">:</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">vector_func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;notrim&#39;</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">snap2surf</span><span class="p">:</span>
            <span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">SnapGrid2Surf</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">],</span> <span class="n">snap</span><span class="o">=</span><span class="n">snap</span><span class="p">)</span>
        <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">hex2tet</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;1to6&#39;</span><span class="p">)</span>
        <span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">MarchingTetrahedra</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">],</span> <span class="n">Type</span><span class="o">=</span><span class="s1">&#39;surf&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">,</span> <span class="n">mixed_elements</span><span class="o">=</span><span class="n">mixed_elements</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
        <span class="n">surface</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">surface</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">,</span> <span class="n">SurfConn</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">surface</span></div>


<div class="viewcode-block" id="TetMesh">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.TetMesh.html#mymesh.implicit.TetMesh">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">TetMesh</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">background</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">snap2surf</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a tetrahedral mesh of an implicit function </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function that describes the geometry of the object to be meshed. The function should be of the form v = f(x,y,z,*args,**kwargs) where x, y, and z are 1D numpy arrays of x, y and z coordinates and v is a 1D numpy array of function values. For method=&#39;mc&#39;, x, y, and z will be 3D coordinate arrays and v must be 3D as well. Additional arguments and keyword arguments may be passed through args and kwargs.</span>
<span class="sd">    bounds : array_like</span>
<span class="sd">        6 element array, list, or tuple with the minimum and maximum bounds in each direction that the function will be evaluated. This should be formatted as: [xmin, xmax, ymin, ymax, zmin, zmax]</span>
<span class="sd">    h : scalar, tuple</span>
<span class="sd">        Element side length. Can be specified as a single scalar value, or a three element tuple (or array_like).</span>
<span class="sd">    threshold : scalar</span>
<span class="sd">        Isovalue threshold to use for keeping/removing elements, by default 0.</span>
<span class="sd">    threshold_direction : signed integer</span>
<span class="sd">        If threshold_direction is negative (default), values less than or equal to the threshold will be considered &quot;inside&quot; the mesh and the opposite if threshold_direction is positive, by default -1.</span>
<span class="sd">    interpolation : str, optional</span>
<span class="sd">        Method of interpolation used for placing the vertices on the approximated </span>
<span class="sd">        isosurface. This can be &#39;midpoint&#39;, &#39;linear&#39;, or &#39;quadratic&#39;, by default</span>
<span class="sd">        &#39;linear&#39;. </span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Tuple of additional positional arguments for func, by default ().</span>
<span class="sd">    kwargs : dict, optional</span>
<span class="sd">        Dictionary of additional keyword arguments for func, by default {}.</span>
<span class="sd">    background : None or mymesh.mesh, optional</span>
<span class="sd">        Background tetrahedral mesh to use for evaluating the function and performing</span>
<span class="sd">        marching tetrahedra. If a mesh is provide, bounds and h will be ignored. </span>
<span class="sd">        If None is provided, a uniform tetrahedral grid will be used, by default None.</span>
<span class="sd">    snap2surf : bool or float, optional</span>
<span class="sd">        Option to use :func:`~mymesh.contour.SnapGrid2Surf` which moves points</span>
<span class="sd">        of the background mesh to lie on the surface. If specified as a float </span>
<span class="sd">        in the range [0, 0.5], sets the snapping parameter which indicates</span>
<span class="sd">        the relative distance within which a point is snapped (0 = no snapping,</span>
<span class="sd">        0.5 = all possible points are snapped). If True, default snapping</span>
<span class="sd">        parameter of 0.2 is used. By default, True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tet : mymesh.mesh</span>
<span class="sd">        Mesh object containing the tetrahedral mesh.</span>

<span class="sd">        .. note:: Due to the ability to unpack the mesh object to NodeCoords and NodeConn, the NodeCoords and NodeConn array can be returned directly (instead of the mesh object) by running: ``NodeCoords, NodeConn = implicit.TetMesh(...)``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        tet = implicit.TetMesh(implicit.gyroid, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        tet.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vector_func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">threshold_direction</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="kc">False</span>
        
    <span class="k">if</span> <span class="n">snap2surf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">snap</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">snap2surf</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">assert</span> <span class="n">snap2surf</span> <span class="o">&lt;=</span> <span class="mf">0.5</span> <span class="ow">and</span> <span class="n">snap2surf</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Snapping parameter must be in the range [0,0.5]&#39;</span>
        <span class="n">snap</span> <span class="o">=</span> <span class="n">snap2surf</span>
        <span class="n">snap2surf</span> <span class="o">=</span> <span class="kc">True</span>
    

    <span class="k">if</span> <span class="n">background</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">VoxelMesh</span><span class="p">(</span><span class="n">vector_func</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">threshold_direction</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">snap2surf</span><span class="p">:</span>
            <span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">SnapGrid2Surf</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">],</span> <span class="n">snap</span><span class="o">=</span><span class="n">snap</span><span class="p">)</span><span class="c1">#, FixedNodes = voxel.SurfNodes)</span>
        <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">hex2tet</span><span class="p">(</span><span class="n">voxel</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;1to6&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">tet42tet10</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
            <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">voxel</span><span class="o">.</span><span class="n">NodeData</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">background</span>
        <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">snap2surf</span><span class="p">:</span>
            <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">SnapGrid2Surf</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeVals</span><span class="p">,</span> <span class="n">snap</span><span class="o">=</span><span class="n">snap</span><span class="p">,</span> <span class="n">FixedNodes</span><span class="o">=</span><span class="n">background</span><span class="o">.</span><span class="n">SurfNodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">NodeConn</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">tet42tet10</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">)</span>
            <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">vector_func</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">NodeCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">TetCoords</span><span class="p">,</span> <span class="n">TetConn</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">MarchingTetrahedra</span><span class="p">(</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">NodeConn</span><span class="p">,</span> <span class="n">NodeVals</span><span class="p">,</span> <span class="n">Type</span><span class="o">=</span><span class="s1">&#39;vol&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span> <span class="n">cleanup</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    

    <span class="k">if</span> <span class="s1">&#39;mesh&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
        <span class="n">tet</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">TetCoords</span><span class="p">,</span> <span class="n">TetConn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tet</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">(</span><span class="n">TetCoords</span><span class="p">,</span> <span class="n">TetConn</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">tet</span></div>


<div class="viewcode-block" id="SurfaceNodeOptimization">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.SurfaceNodeOptimization.html#mymesh.implicit.SurfaceNodeOptimization">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">SurfaceNodeOptimization</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">iterate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">FixedNodes</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span> <span class="n">FreeNodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">FixEdges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">finite_diff_step</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">InPlace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">springs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optimize the placement of surface node to lie on the &quot;true&quot; surface. This</span>
<span class="sd">    This simultaneously moves nodes towards the isosurface and redistributes</span>
<span class="sd">    nodes more evenly, thus smoothing the mesh without shrinkage or destruction</span>
<span class="sd">    of features. This method is consists of using the Z-flow (and R-flow if </span>
<span class="sd">    smooth=True) from :cite:t:`Ohtake2001a`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : mesh.mesh</span>
<span class="sd">        Mesh object</span>
<span class="sd">    func : function or sympy-type function</span>
<span class="sd">        Implicit function describing the mesh surface. This should be the same</span>
<span class="sd">        function used to create the mesh.</span>
<span class="sd">    h : float</span>
<span class="sd">        Element size of the surface mesh</span>
<span class="sd">    iterate : int, optional</span>
<span class="sd">        Number of iterations to perform, by default 1</span>
<span class="sd">    FixedNodes : set, optional</span>
<span class="sd">        Nodes to hold in place during repositioning, by default set()</span>
<span class="sd">    FreeNodes : NoneType, set, or array_like</span>
<span class="sd">        Movable nodes, if None these will be the surface nodes. The any nodes in both </span>
<span class="sd">        FreeNodes and FixedNodes will be removed from FreeNodes. By default None.</span>
<span class="sd">    FixEdges : bool, optional</span>
<span class="sd">        Option to detect and hold in place exposed surface edges, by default False</span>
<span class="sd">    finite_diff_step : float, optional</span>
<span class="sd">        Small number used to calculate finite difference approximations to the </span>
<span class="sd">        gradient. Only used if the function is not convertible to a </span>
<span class="sd">        sympy-differentiable function, by default 1e-5.</span>
<span class="sd">    smooth : str, optional</span>
<span class="sd">        Option to perform smoothing. This can be either &#39;local&#39; for local </span>
<span class="sd">        Laplacian smoothing or &#39;tangential&#39; for tangential Laplacian smoothing, </span>
<span class="sd">        by default &#39;tangential&#39;. For any other option, smoothing will not be </span>
<span class="sd">        performed. Tangential smoothing differs from local in that nodes </span>
<span class="sd">        are only repositioned in the tangent plane (based on the normal vector</span>
<span class="sd">        obtain from the gradient). </span>
<span class="sd">    InPlace : bool, optional</span>
<span class="sd">        If False, will create a copy of the mesh, rather than altering node </span>
<span class="sd">        positions of the original mesh object &quot;in-place&quot;, by default False</span>
<span class="sd">    springs : bool, optional</span>
<span class="sd">        If True and the mesh is a volume mesh, internal nodes will be treated as </span>
<span class="sd">        if they are connected by springs (see :func:`~mymesh.improvement.NodeSpringSmoothing`)</span>
<span class="sd">        to reduce risk of element distortion or inversion, by default True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M : mesh.mesh</span>
<span class="sd">        Mesh with repositioned surface vertices</span>

<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="k">if</span> <span class="ow">not</span> <span class="n">InPlace</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">smooth</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">smooth</span> <span class="o">=</span> <span class="s1">&#39;tangential&#39;</span>
        
    <span class="c1"># Process nodes</span>
    <span class="k">if</span> <span class="n">FixEdges</span><span class="p">:</span>
        <span class="n">EdgeNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">surf2edges</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">EdgeNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">FreeNodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">FreeNodes</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">SurfNodes</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">FreeNodes</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">FreeNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">FreeNodes</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">FreeNodes</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">FreeNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">FreeNodes</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">FreeNodes</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid input for FreeNodes.&#39;</span><span class="p">)</span>
    <span class="n">FreeNodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">FreeNodes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">EdgeNodes</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">FixedNodes</span><span class="p">)))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">FreeNodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No free movable nodes.&#39;</span><span class="p">)</span>

    <span class="c1"># Process function</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">DiracDelta</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
            
            <span class="n">Fx</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
            <span class="n">Fy</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span><span class="n">y</span><span class="p">)</span>
            <span class="n">Fz</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span><span class="n">z</span><span class="p">)</span>
            <span class="n">Grad</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">Fx</span><span class="p">,</span> <span class="n">Fy</span><span class="p">,</span> <span class="n">Fz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">gradF</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="n">Grad</span><span class="p">,[</span><span class="s1">&#39;numpy&#39;</span><span class="p">,{</span><span class="s1">&#39;DiracDelta&#39;</span><span class="p">:</span><span class="n">DiracDelta</span><span class="p">}])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">func</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">gradF</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">):</span>
                <span class="n">gradx</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="o">+</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="o">-</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">))</span><span class="o">/</span><span class="n">finite_diff_step</span>
                <span class="n">grady</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="o">+</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="o">-</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">Z</span><span class="p">))</span><span class="o">/</span><span class="n">finite_diff_step</span>
                <span class="n">gradz</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="o">+</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="o">-</span><span class="n">finite_diff_step</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">finite_diff_step</span>
                <span class="n">gradf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">gradx</span><span class="p">,</span><span class="n">grady</span><span class="p">,</span><span class="n">gradz</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">gradf</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>

        <span class="n">Fx</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
        <span class="n">Fy</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">Fz</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
        <span class="n">Grad</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">Fx</span><span class="p">,</span> <span class="n">Fy</span><span class="p">,</span> <span class="n">Fz</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">gradF</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="n">Grad</span><span class="p">,[</span><span class="s1">&#39;numpy&#39;</span><span class="p">,{</span><span class="s1">&#39;DiracDelta&#39;</span><span class="p">:</span><span class="n">DiracDelta</span><span class="p">}])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;func must be a sympy function or callable function of three arguments (x,y,z).&#39;</span><span class="p">)</span>

    <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">),</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">];</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">gradF</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">PadRagged</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfNodeNeighbors</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfNodeNeighbors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">FreeNodes</span><span class="p">])</span>


    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterate</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">];</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span> <span class="o">-</span> <span class="n">threshold</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">gradF</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">))</span>
        <span class="n">fg</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fg</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

        <span class="n">Zflow</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">fg</span>

        <span class="c1"># Rflow = np.zeros((len(NodeCoords),3))</span>
        <span class="k">if</span> <span class="n">smooth</span> <span class="o">==</span> <span class="s1">&#39;tangential&#39;</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="n">U</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lengths</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Q</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">gnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">gnorm</span><span class="p">[</span><span class="n">gnorm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">NodeNormals</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span><span class="o">/</span><span class="n">gnorm</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Rflow</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">U</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="n">NodeNormals</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">NodeNormals</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">smooth</span> <span class="o">==</span> <span class="s1">&#39;local&#39;</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="n">U</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lengths</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Q</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Rflow</span> <span class="o">=</span> <span class="n">U</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Rflow</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">springs</span> <span class="ow">and</span> <span class="n">M</span><span class="o">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s1">&#39;vol&#39;</span><span class="p">:</span>
            <span class="n">Forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="o">.</span><span class="n">NNode</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">Forces</span><span class="p">[</span><span class="n">FreeNodes</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zflow</span> <span class="o">+</span> <span class="n">Rflow</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">improvement</span><span class="o">.</span><span class="n">NodeSpringSmoothing</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Displacements</span><span class="o">=</span><span class="n">Forces</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">FixSurf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">FixedNodes</span><span class="o">=</span><span class="n">FixedNodes</span><span class="p">,</span> <span class="n">InPlace</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)[</span><span class="n">FreeNodes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points</span> <span class="o">+</span> <span class="n">Zflow</span> <span class="o">+</span> <span class="n">Rflow</span>
            <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">FreeNodes</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span>
    <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">M</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">SurfaceReconstruction</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">decimate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;compact&#39;</span><span class="p">,</span><span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">decimate</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">nodeset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfNodes</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfNodes</span><span class="p">)</span><span class="o">*</span><span class="n">decimate</span><span class="p">),</span><span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nodeset</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">SurfNodes</span>
    <span class="n">SurfCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)[</span><span class="n">nodeset</span><span class="p">]</span> <span class="c1"># won&#39;t work for mixed-element surfaces</span>
    <span class="n">SurfNormals</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeNormals</span><span class="p">[</span><span class="n">nodeset</span><span class="p">]</span>

    <span class="c1"># Get offset distance based on edge lengths</span>
    <span class="n">SurfEdgeLengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">M</span><span class="o">.</span><span class="n">Surface</span><span class="o">.</span><span class="n">Edges</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]]</span> <span class="o">-</span> <span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">[</span><span class="n">M</span><span class="o">.</span><span class="n">Surface</span><span class="o">.</span><span class="n">Edges</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">MeanEdge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">SurfEdgeLengths</span><span class="p">)</span>
    <span class="n">OffsetDistance</span> <span class="o">=</span>  <span class="mi">1</span><span class="o">*</span><span class="n">MeanEdge</span> <span class="c1"># np.percentile(SurfEdgeLengths, 10)</span>
    <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">SupportRadius</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">MeanEdge</span><span class="o">/</span><span class="n">decimate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">SupportRadius</span> <span class="o">=</span> <span class="n">R</span>    

    <span class="n">PosOffset</span> <span class="o">=</span> <span class="n">SurfCoords</span> <span class="o">+</span> <span class="n">OffsetDistance</span><span class="o">*</span><span class="n">SurfNormals</span>
    <span class="n">NegOffset</span> <span class="o">=</span> <span class="n">SurfCoords</span> <span class="o">-</span> <span class="n">OffsetDistance</span><span class="o">*</span><span class="n">SurfNormals</span>
    <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">SurfCoords</span><span class="p">,</span> <span class="n">PosOffset</span><span class="p">,</span> <span class="n">NegOffset</span><span class="p">])</span>

    <span class="n">gaussian</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">SupportRadius</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">biharmonic</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span> <span class="p">:</span> <span class="n">r</span>
    <span class="n">triharmonic</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span> <span class="p">:</span> <span class="n">r</span><span class="o">**</span><span class="mi">3</span>
    <span class="n">compact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">SupportRadius</span><span class="o">-</span><span class="n">r</span><span class="p">))</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">r</span> <span class="o">+</span> <span class="n">SupportRadius</span><span class="p">)</span>

    <span class="n">rbf</span> <span class="o">=</span> <span class="n">compact</span>
    <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;rbf&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;compact&#39;</span><span class="p">:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">Coords</span><span class="p">)</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">Coords</span><span class="p">,</span> <span class="n">SupportRadius</span><span class="p">)</span>
        <span class="n">nneighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">]</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Coords</span><span class="p">)),</span> <span class="n">nneighbors</span><span class="p">)</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">compact</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Coords</span><span class="p">[</span><span class="n">rows</span><span class="p">]</span> <span class="o">-</span> <span class="n">Coords</span><span class="p">[</span><span class="n">cols</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">vals</span><span class="p">,(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Coords</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Coords</span><span class="p">)))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">OffsetDistance</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">PosOffset</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="n">OffsetDistance</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">NegOffset</span><span class="p">))])[:,</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">Lambda</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]),</span> <span class="n">SupportRadius</span><span class="p">)</span>
            <span class="n">uneighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unqiue</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>

            <span class="n">rbf_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Lambda</span><span class="o">*</span><span class="n">rbf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">Coords</span><span class="p">[</span><span class="n">uneighbors</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">Coords</span><span class="p">[</span><span class="n">uneighbors</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">Coords</span><span class="p">[</span><span class="n">uneighbors</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)),</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">f</span> <span class="o">=</span> <span class="n">rbf_sum</span>
            <span class="k">return</span> <span class="n">f</span> 

    <span class="k">else</span><span class="p">:</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">rbf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Coords</span> <span class="o">-</span> <span class="n">Coords</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># p(x,y,z) = c1 + c2*x + c3*y + c4*z</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Coords</span><span class="p">)),</span> <span class="n">Coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">Coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]])</span>
        <span class="n">Mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">A</span><span class="p">,</span> <span class="n">P</span><span class="p">],[</span><span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))]])</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SurfCoords</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">OffsetDistance</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">PosOffset</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="n">OffsetDistance</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">NegOffset</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)])[:,</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">sol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Mat</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">Lambda</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

            <span class="n">rbf_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Lambda</span><span class="o">*</span><span class="n">rbf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">Coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">Coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">Coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)),</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">f</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">cs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">cs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">rbf_sum</span>
            <span class="k">return</span> <span class="n">f</span> 

    <span class="k">return</span> <span class="n">func</span>

<span class="c1"># Implicit Function Primitives</span>
<div class="viewcode-block" id="gyroid">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.gyroid.html#mymesh.implicit.gyroid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gyroid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function approximation of the gyroid triply periodic minimal </span>
<span class="sd">    surface (TPMS). This function uses sympy functions (sp.cos, sp.sin) to </span>
<span class="sd">    enable symbolic differentiation. </span>
<span class="sd">    </span>
<span class="sd">    For efficient vectorized evaluation, use:</span>
<span class="sd">    x, y, z = sp.symbols(&#39;x y z&#39;, real=True)</span>
<span class="sd">    vector_func = sp.lambdify((x, y, z), func(x,y,z), &#39;numpy&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : scalar or np.ndarray</span>
<span class="sd">        x coordinate(s)</span>
<span class="sd">    y : scalar or np.ndarray</span>
<span class="sd">        y coordinate(s)</span>
<span class="sd">    z : scalar or np.ndarray</span>
<span class="sd">        z coordinate(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        implicit function evaluated with sympy</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.gyroid, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="lidinoid">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.lidinoid.html#mymesh.implicit.lidinoid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">lidinoid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function approximation of the lidinoid triply periodic minimal </span>
<span class="sd">    surface (TPMS). This function uses sympy functions (sp.cos, sp.sin) to </span>
<span class="sd">    enable symbolic differentiation. </span>
<span class="sd">    </span>
<span class="sd">    For efficient vectorized evaluation, use:</span>
<span class="sd">    x, y, z = sp.symbols(&#39;x y z&#39;, real=True)</span>
<span class="sd">    vector_func = sp.lambdify((x, y, z), func(x,y,z), &#39;numpy&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : scalar or np.ndarray</span>
<span class="sd">        x coordinate(s)</span>
<span class="sd">    y : scalar or np.ndarray</span>
<span class="sd">        y coordinate(s)</span>
<span class="sd">    z : scalar or np.ndarray</span>
<span class="sd">        z coordinate(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        implicit function evaluated with sympy</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.lidinoid, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Z</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Z</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.15</span>
    <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="primitive">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.primitive.html#mymesh.implicit.primitive">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">primitive</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function approximation of the primitive (Schwarz P) triply periodic </span>
<span class="sd">    minimal surface (TPMS). This function uses sympy functions (sp.cos, sp.sin) </span>
<span class="sd">    to enable symbolic differentiation. </span>
<span class="sd">    </span>
<span class="sd">    For efficient vectorized evaluation, use:</span>
<span class="sd">    x, y, z = sp.symbols(&#39;x y z&#39;, real=True)</span>
<span class="sd">    vector_func = sp.lambdify((x, y, z), func(x,y,z), &#39;numpy&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : scalar or np.ndarray</span>
<span class="sd">        x coordinate(s)</span>
<span class="sd">    y : scalar or np.ndarray</span>
<span class="sd">        y coordinate(s)</span>
<span class="sd">    z : scalar or np.ndarray</span>
<span class="sd">        z coordinate(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        implicit function evaluated with sympy</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.primitive, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span></div>


<div class="viewcode-block" id="neovius">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.neovius.html#mymesh.implicit.neovius">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">neovius</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function approximation of the neovius triply periodic minimal </span>
<span class="sd">    surface (TPMS). This function uses sympy functions (sp.cos, sp.sin) to </span>
<span class="sd">    enable symbolic differentiation. </span>
<span class="sd">    </span>
<span class="sd">    For efficient vectorized evaluation, use:</span>
<span class="sd">    x, y, z = sp.symbols(&#39;x y z&#39;, real=True)</span>
<span class="sd">    vector_func = sp.lambdify((x, y, z), func(x,y,z), &#39;numpy&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : scalar or np.ndarray</span>
<span class="sd">        x coordinate(s)</span>
<span class="sd">    y : scalar or np.ndarray</span>
<span class="sd">        y coordinate(s)</span>
<span class="sd">    z : scalar or np.ndarray</span>
<span class="sd">        z coordinate(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        implicit function evaluated with sympy</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.neovius, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">X</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span>
    <span class="k">return</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">))</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span></div>


<div class="viewcode-block" id="diamond">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.diamond.html#mymesh.implicit.diamond">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">diamond</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function approximation of the diamond (Schwarz D) triply periodic </span>
<span class="sd">    minimal surface (TPMS). This function uses sympy functions (sp.cos, sp.sin) </span>
<span class="sd">    to enable symbolic differentiation. </span>
<span class="sd">    </span>
<span class="sd">    For efficient vectorized evaluation, use:</span>
<span class="sd">    x, y, z = sp.symbols(&#39;x y z&#39;, real=True)</span>
<span class="sd">    vector_func = sp.lambdify((x, y, z), func(x,y,z), &#39;numpy&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : scalar or np.ndarray</span>
<span class="sd">        x coordinate(s)</span>
<span class="sd">    y : scalar or np.ndarray</span>
<span class="sd">        y coordinate(s)</span>
<span class="sd">    z : scalar or np.ndarray</span>
<span class="sd">        z coordinate(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : sympy expression</span>
<span class="sd">        implicit function evaluated with sympy</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.diamond, [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="p">)</span></div>


<div class="viewcode-block" id="cylinder">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.cylinder.html#mymesh.implicit.cylinder">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cylinder</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a cylinder.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : array_like</span>
<span class="sd">        2D vector specifying the x and y coordinates of the center of the </span>
<span class="sd">        cylindrical cross section</span>
<span class="sd">    radius : float</span>
<span class="sd">        Radius of the cylinder</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z)</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.cylinder([0,0,0], 1), [-1,1,-1,1,-1,1], 0.1)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">func</span></div>


<div class="viewcode-block" id="box">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.box.html#mymesh.implicit.box">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">box</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">):</span>    
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a box.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : float</span>
<span class="sd">        x coordinate lower bound</span>
<span class="sd">    x2 : float</span>
<span class="sd">        x coordinate upper bound</span>
<span class="sd">    y1 : float</span>
<span class="sd">        y coordinate lower bound</span>
<span class="sd">    y2 : float</span>
<span class="sd">        y coordinate upper bound</span>
<span class="sd">    z1 : float</span>
<span class="sd">        z coordinate lower bound</span>
<span class="sd">    z2 : float</span>
<span class="sd">        z coordinate upper bound</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z)</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.box(.1,.9,.1,.9,.1,.9), [0,1,0,1,0,1], 0.05)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="n">intersection</span><span class="p">(</span><span class="n">intersection</span><span class="p">(</span><span class="n">intersection</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="o">-</span><span class="n">x2</span><span class="p">),</span><span class="n">intersection</span><span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y</span><span class="p">,</span><span class="n">y</span><span class="o">-</span><span class="n">y2</span><span class="p">)),</span><span class="n">intersection</span><span class="p">(</span><span class="n">z1</span><span class="o">-</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="o">-</span><span class="n">z2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">func</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">plane</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">normal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of an arbitrary plane.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pt : array_like</span>
<span class="sd">        Three element array_like, coordinates of a point on the plane.</span>
<span class="sd">    normal : array_like</span>
<span class="sd">        Three element array_like, normal vector of plane.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">pt</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">func</span>

<div class="viewcode-block" id="xplane">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.xplane.html#mymesh.implicit.xplane">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">xplane</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a plane whose normal direction is along the x axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x0 : float</span>
<span class="sd">        Coordinate along the x axis of the plane. x0 = 0 corresponds to the </span>
<span class="sd">        yz plane.</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        Direction (1 or -1), or a scaling factor, by default 1. If n &gt; 0, the </span>
<span class="sd">        function will be negative when evaluated above x0.</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span></div>


<div class="viewcode-block" id="yplane">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.yplane.html#mymesh.implicit.yplane">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">yplane</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a plane whose normal direction is along the y axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y0 : float</span>
<span class="sd">        Coordinate along the y axis of the plane. y0 = 0 corresponds to the </span>
<span class="sd">        xz plane.</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        Direction (1 or -1), or a scaling factor, by default 1. If n &gt; 0, the </span>
<span class="sd">        function will be negative when evaluated above y0.</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span></div>


<div class="viewcode-block" id="zplane">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.zplane.html#mymesh.implicit.zplane">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">zplane</span><span class="p">(</span><span class="n">z0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a plane whose normal direction is along the z axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z0 : float</span>
<span class="sd">        Coordinate along the x axis of the plane. z0 = 0 corresponds to the </span>
<span class="sd">        xy plane.</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        Direction (1 or -1), or a scaling factor, by default 1. If n &gt; 0, the </span>
<span class="sd">        function will be negative when evaluated above z0.</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">z0</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span></div>


<div class="viewcode-block" id="sphere">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.sphere.html#mymesh.implicit.sphere">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sphere</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : array_like</span>
<span class="sd">        3D coordinates ([x, y, z]) of the center of the sphere.</span>
<span class="sd">    radius : float</span>
<span class="sd">        radius of the sphere.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z).</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.sphere([0,0,0],1), [-1,1,-1,1,-1,1], 0.1)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">func</span></div>


<div class="viewcode-block" id="torus">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.torus.html#mymesh.implicit.torus">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">torus</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implicit function of a torus oriented about the z-axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : array_like</span>
<span class="sd">        3D coordinates ([x, y, z]) of the center of the torus.</span>
<span class="sd">    R : float</span>
<span class="sd">        The major axis of the torus. This is the distance from the center of the </span>
<span class="sd">        torus to the center of the circular tube. </span>
<span class="sd">    r : float</span>
<span class="sd">        The minor axis of the torus. This is the radius of the circular tube. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    func : function</span>
<span class="sd">        Implicit function of three parameters (x, y, z).</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>

<span class="sd">        surface = implicit.SurfaceMesh(implicit.torus([0,0,0], 1, .25), [-1.25,1.25,-1.25,1.25,-.3,.3], 0.1)</span>
<span class="sd">        surface.plot(bgcolor=&#39;w&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="p">(((</span><span class="n">x</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">func</span></div>


<span class="c1"># Implicit Function Operators</span>
<div class="viewcode-block" id="offset">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.offset.html#mymesh.implicit.offset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">offset</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Offset function values by a prescribed amount. For a signed </span>
<span class="sd">    distance function, this offsets the isosurface by a specified distance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fval : scalar or np.ndarray</span>
<span class="sd">        Function value(s) to be offset</span>
<span class="sd">    value : scalar</span>
<span class="sd">        Offset value</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    offset_val : scalar or np.ndarray</span>
<span class="sd">        Offset value(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">offset_val</span> <span class="o">=</span> <span class="n">fval</span><span class="o">-</span><span class="n">value</span>
    <span class="k">return</span> <span class="n">offset_val</span></div>


<div class="viewcode-block" id="union">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.union.html#mymesh.implicit.union">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean union of two values or sets of values. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMin` minimum is used to obtain a </span>
<span class="sd">    continuously differentiable output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fval1 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the first function</span>
<span class="sd">    fval2 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the second function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    union_val : scalar or np.ndarray</span>
<span class="sd">        Union of the two sets of values</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">union_val</span> <span class="o">=</span> <span class="n">rMin</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">union_val</span></div>


<div class="viewcode-block" id="diff">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.diff.html#mymesh.implicit.diff">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">diff</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean difference of two values or sets of values. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMax` maximum is used to obtain a </span>
<span class="sd">    continuously differentiable output. Note that this operation is not </span>
<span class="sd">    symmetric so the order of inputs matters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fval1 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the first function</span>
<span class="sd">    fval2 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the second function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diff_val : scalar or np.ndarray</span>
<span class="sd">        Difference of the two sets of values</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">diff_val</span> <span class="o">=</span> <span class="n">rMax</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="o">-</span><span class="n">fval2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">diff_val</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">diff_old</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">):</span>
    <span class="c1"># warnings.warn(&#39;This function will be removed in the future.&#39;)</span>
    <span class="k">return</span> <span class="n">rMin</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="o">-</span><span class="n">fval2</span><span class="p">)</span>
    
<div class="viewcode-block" id="intersection">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.intersection.html#mymesh.implicit.intersection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">intersection</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean intersection of two values or sets of values. Negative values are </span>
<span class="sd">    assumed to be &quot;inside&quot;. An R-function :func:`rMax` maximum is used to </span>
<span class="sd">    obtain a continuously differentiable output. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fval1 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the first function</span>
<span class="sd">    fval2 : scalar or np.ndarray</span>
<span class="sd">        Value(s) of the second function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    intersection_val : scalar or np.ndarray</span>
<span class="sd">        Intersection of the two sets of values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intersection_val</span> <span class="o">=</span> <span class="n">rMax</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span><span class="n">fval2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">intersection_val</span></div>


<div class="viewcode-block" id="thicken">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.thicken.html#mymesh.implicit.thicken">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">thicken</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Thicken an isosurface by offsetting in both directions. The surface</span>
<span class="sd">    is offset in both directions by t/2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fval : scalar or np.ndarray</span>
<span class="sd">        Function value(s) to be offset</span>
<span class="sd">    t : scalar</span>
<span class="sd">        Thickness value. For a signed distance function, this will correspond</span>
<span class="sd">        to an actual thickness, for other implicit functions, the offset distance</span>
<span class="sd">        depends on the function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    thick : scalar or np.ndarray</span>
<span class="sd">        Thickened value(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">thick</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">offp</span><span class="p">,</span> <span class="n">offn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">thick</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">offsetf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Offset function by a prescribed amount. For a signed </span>
<span class="sd">    distance function, this offsets the isosurface by a specified distance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>
<span class="sd">    value : scalar</span>
<span class="sd">        Offset value</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    offset_fun : callable</span>
<span class="sd">        Offset funcion</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">offset_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">offset</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">offset_fun</span>

<div class="viewcode-block" id="unionf">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.unionf.html#mymesh.implicit.unionf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unionf</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean union of two functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMin` minimum is used to obtain a </span>
<span class="sd">    continuously differentiable output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f1 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>
<span class="sd">    f2 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    union_fun : callable</span>
<span class="sd">        Union function</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">union_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">rMin</span><span class="p">(</span><span class="n">f1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="n">f2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">union_fun</span></div>


<div class="viewcode-block" id="difff">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.difff.html#mymesh.implicit.difff">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">difff</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean difference of two functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMax` maximum is used to obtain a </span>
<span class="sd">    continuously differentiable output. Note that this operation is not </span>
<span class="sd">    symmetric so the order of inputs matters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f1 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>
<span class="sd">    f2 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diff_fun : callable</span>
<span class="sd">        Difference of the two functions</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">diff_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">rMax</span><span class="p">(</span><span class="n">f1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="o">-</span><span class="n">f2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">diff_fun</span></div>


<div class="viewcode-block" id="intersectionf">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.intersectionf.html#mymesh.implicit.intersectionf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">intersectionf</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean intersection of two functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMax` maximum is used to obtain a </span>
<span class="sd">    continuously differentiable output. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f1 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>
<span class="sd">    f2 : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    intersection_fun : callable</span>
<span class="sd">        Intersection of the two functions</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">intersection_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">rMax</span><span class="p">(</span><span class="n">f1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="n">f2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">intersection_fun</span></div>


<div class="viewcode-block" id="thickenf">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.thickenf.html#mymesh.implicit.thickenf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">thickenf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Thicken an implicit function by offsetting in both directions. The surface</span>
<span class="sd">    is offset in both directions by t/2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : callable</span>
<span class="sd">        Callable function of three variables (x, y, z). Function should be able</span>
<span class="sd">        to handle either scalar or vector inputs.</span>
<span class="sd">    t : scalar</span>
<span class="sd">        Thickness value. For a signed distance function, this will correspond</span>
<span class="sd">        to an actual thickness, for other implicit functions, the offset distance</span>
<span class="sd">        depends on the function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    thick_fun : callable</span>
<span class="sd">        Thickened function</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offsetf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offsetf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">thick_fun</span> <span class="o">=</span> <span class="n">difff</span><span class="p">(</span><span class="n">offp</span><span class="p">,</span> <span class="n">offn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">thick_fun</span></div>


<div class="viewcode-block" id="unions">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.unions.html#mymesh.implicit.unions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unions</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="n">symfun2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean union of two symbolic functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMins` minimum is used to obtain a </span>
<span class="sd">    continuously differentiable output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    symfun1 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>
<span class="sd">    symfun2 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    union_sym : Scalar or np.ndarray</span>
<span class="sd">        Symbolic union function</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">union_sym</span> <span class="o">=</span> <span class="n">rMins</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="n">symfun2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">union_sym</span></div>


<div class="viewcode-block" id="diffs">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.diffs.html#mymesh.implicit.diffs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">diffs</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="n">symfun2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean difference of two symbolic functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMaxs` minimum is used to obtain a </span>
<span class="sd">    continuously differentiable output. Note that this operation is not </span>
<span class="sd">    symmetric so the order of inputs matters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    symfun1 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>
<span class="sd">    symfun2 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diff_sym : sympy function</span>
<span class="sd">        Symbolic difference function</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">diff_sym</span> <span class="o">=</span> <span class="n">rMaxs</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="o">-</span><span class="n">symfun2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">diff_sym</span></div>


<div class="viewcode-block" id="intersections">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.intersections.html#mymesh.implicit.intersections">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">intersections</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="n">symfun2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean intersection of two symbolic functions. Negative values are assumed</span>
<span class="sd">    to be &quot;inside&quot;. An R-function :func:`rMaxs` minimum is used to obtain a </span>
<span class="sd">    continuously differentiable output. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    symfun1 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>
<span class="sd">    symfun2 : sympy function</span>
<span class="sd">        Symbolic sympy function of three variables (x, y, z). </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diff_sym : sympy function</span>
<span class="sd">        Symbolic difference function</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">intersection_sym</span> <span class="o">=</span> <span class="n">rMaxs</span><span class="p">(</span><span class="n">symfun1</span><span class="p">,</span><span class="n">symfun2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">intersection_sym</span></div>


<div class="viewcode-block" id="thickens">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.thickens.html#mymesh.implicit.thickens">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">thickens</span><span class="p">(</span><span class="n">symfun</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">offp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">symfun</span><span class="p">,</span> <span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">offn</span> <span class="o">=</span> <span class="n">offset</span><span class="p">(</span><span class="n">symfun</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">thick</span> <span class="o">=</span> <span class="n">diffs</span><span class="p">(</span><span class="n">offp</span><span class="p">,</span> <span class="n">offn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">thick</span></div>


<div class="viewcode-block" id="rMax">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.rMax.html#mymesh.implicit.rMax">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># R-Function :cite:p:`Shapiro1999` version of max(a,b) to yield a smoothly differentiable max - R0</span>
    <span class="c1"># Implicit Functions With Guaranteed Differential Properties - Shapiro &amp; Tsukanov</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">p</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="rMin">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.rMin.html#mymesh.implicit.rMin">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rMin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># R-Function :cite:p:`Shapiro1999` version of min(a,b) to yield a smoothly differentiable min - R0</span>
    <span class="c1"># Implicit Functions With Guaranteed Differential Properties - Shapiro &amp; Tsukanov</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">p</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">rMaxs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># R-Function version of max(a,b) to yield a smoothly differentiable max - R0</span>
    <span class="c1"># Implicit Functions With Guaranteed Differential Properties - Shapiro &amp; Tsukanov</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">p</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">rMins</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># R-Function version of min(a,b) to yield a smoothly differentiable min - R0</span>
    <span class="c1"># Implicit Functions With Guaranteed Differential Properties - Shapiro &amp; Tsukanov</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">p</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

<div class="viewcode-block" id="grid2fun">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.grid2fun.html#mymesh.implicit.grid2fun">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">grid2fun</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">,</span><span class="n">Vals</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a voxel grid mesh into a function that can be evaluated at any point within the bounds of the grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : List of Lists</span>
<span class="sd">        List of nodal coordinates for the voxel mesh</span>
<span class="sd">    VoxelConn : List of Lists</span>
<span class="sd">       Nodal connectivity list for the voxel mesh.</span>
<span class="sd">    Vals : list</span>
<span class="sd">        List of values at each node or at each element.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fun : function</span>
<span class="sd">        Interpolation function, takes arguments (x,y,z), to return an</span>
<span class="sd">        evaluation of the function at the specified point.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">):</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">Vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">VoxelConn</span><span class="p">):</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Vals must be the same length as either VoxelCoords or VoxelConn&#39;</span><span class="p">)</span>
    <span class="c1"># VoxelCoords = np.array(VoxelCoords)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Vals</span><span class="p">,[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">)])</span>
    
    <span class="n">V</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">V</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">RegularGridInterpolator</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fun</span></div>


<div class="viewcode-block" id="grid2grad">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.grid2grad.html#mymesh.implicit.grid2grad">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">grid2grad</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">,</span><span class="n">VoxelConn</span><span class="p">,</span><span class="n">NodeVals</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a voxel grid mesh into a function. The function can be evaluated at any point within the bounds of the grid to return the gradient of the function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VoxelCoords : List of Lists</span>
<span class="sd">        List of nodal coordinates for the voxel mesh</span>
<span class="sd">    VoxelConn : List of Lists</span>
<span class="sd">       Nodal connectivity list for the voxel mesh.</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of values at each node.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frad : function</span>
<span class="sd">        Interpolation function, takes arguments (x,y,z), to return an</span>
<span class="sd">        evaluation of the function gradient at the specified point.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">VoxelCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">NodeVals</span><span class="p">,[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">)])</span>
    <span class="c1"># Assumes (and requires) that all voxels are cubic and the same size</span>
    <span class="n">VoxelSize</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">VoxelCoords</span><span class="p">[</span><span class="n">VoxelConn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]))</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">VoxelSize</span><span class="p">)</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interpn</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>
    
    <span class="k">return</span> <span class="n">grad</span></div>


<div class="viewcode-block" id="mesh2sdf">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.mesh2sdf.html#mymesh.implicit.mesh2sdf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mesh2sdf</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nodes+centroids&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a signed distance field for a mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : mesh.mesh</span>
<span class="sd">        Mesh object that will be used to define the distance field.</span>
<span class="sd">    points : array_like</span>
<span class="sd">        Points at which the signed distance field will be evaluated.</span>
<span class="sd">    method : str</span>
<span class="sd">        Method to be used </span>
<span class="sd">        nodes </span>
<span class="sd">        nodes+centroids</span>
<span class="sd">        centroids</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of signed distance values evaluated at each node in the voxel grid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nodes&#39;</span><span class="p">:</span>
        <span class="n">Normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeNormals</span><span class="p">)</span>
        <span class="n">SurfNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfNodes</span><span class="p">)</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">SurfNodes</span> <span class="k">else</span> <span class="p">[</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;centroids&#39;</span><span class="p">:</span>
        <span class="n">Normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">ElemNormals</span><span class="p">)</span>
        <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">M</span><span class="o">.</span><span class="n">NodeConn</span><span class="p">)</span> <span class="c1">#np.array([np.mean(NodeCoords[elem],axis=0) for elem in M.SurfConn])</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nodes+centroids&#39;</span><span class="p">:</span>
        <span class="n">Normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeNormals</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">ElemNormals</span><span class="p">))</span>
        <span class="n">NodeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>
        <span class="n">SurfNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">SurfNodes</span><span class="p">)</span>
        <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">SurfNodes</span> <span class="k">else</span> <span class="p">[</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">32</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)],</span> <span class="n">utils</span><span class="o">.</span><span class="n">Centroids</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">,</span><span class="n">M</span><span class="o">.</span><span class="n">SurfConn</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid method - use &quot;nodes&quot;, &quot;centroids&quot;, or &quot;nodes+centroids&quot;&#39;</span><span class="p">)</span>
    
    <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">Coords</span><span class="p">)</span>  
    <span class="n">Out</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">Out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">Out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">points</span> <span class="o">-</span> <span class="n">Coords</span><span class="p">[</span><span class="n">cs</span><span class="p">]</span>
    <span class="n">signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rs</span><span class="o">*</span><span class="n">Normals</span><span class="p">[</span><span class="n">cs</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="c1"># [np.sign(np.dot(rs[i],Normals[cs[i]])) for i in range(len(ds))]</span>
    <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">signs</span><span class="o">*</span><span class="n">ds</span>
    
    <span class="k">return</span> <span class="n">NodeVals</span></div>


<div class="viewcode-block" id="mesh2udf">
<a class="viewcode-back" href="../../generated/submodules/mymesh.implicit.mesh2udf.html#mymesh.implicit.mesh2udf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mesh2udf</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates an unsigned distance field for a mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : mesh.mesh</span>
<span class="sd">        Mesh object that will be used to define the distance field.</span>
<span class="sd">    points : array_like</span>
<span class="sd">        Points at which the signed distance field will be evaluated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NodeVals : list</span>
<span class="sd">        List of signed distance values evaluated at each node in the voxel grid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">NodeCoords</span><span class="p">)</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">Coords</span><span class="p">)</span>  
    <span class="n">Out</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">NodeVals</span> <span class="o">=</span> <span class="n">Out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">NodeVals</span></div>


<span class="c1"># def FastMarchingMethod(VoxelCoords, VoxelConn, NodeVals):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     FastMarchingMethod based on J.A. Sethian. A Fast Marching Level Set Method</span>
<span class="c1">#     for Monotonically Advancing Fronts, Proc. Natl. Acad. Sci., 93, 4, </span>
<span class="c1">#     pp.1591--1595, 1996</span>

<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     VoxelCoords : list</span>
<span class="c1">#         List of nodal coordinates for the voxel mesh.</span>
<span class="c1">#     VoxelConn : list</span>
<span class="c1">#         Nodal connectivity list for the voxel mesh.</span>
<span class="c1">#     NodeVals : list</span>
<span class="c1">#         List of value at each node.</span>

<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     T : list</span>
<span class="c1">#         Lists of reinitialized node values.</span>

<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     warnings.warn(&#39;FastMarchingMethod is not fully functional.&#39;)</span>

<span class="c1">#     # 3D</span>
<span class="c1">#     N = 3</span>
<span class="c1">#     # For now this is only for obtaining a signed distance function, so F = 1 everywhere</span>
<span class="c1">#     F = 1</span>
<span class="c1">#     NodeVals = np.array(NodeVals)</span>
<span class="c1">#     # Get Neighbors</span>
<span class="c1">#     if len(VoxelConn[0]) == 4:</span>
<span class="c1">#         ElemType = &#39;quad&#39;</span>
<span class="c1">#     else:</span>
<span class="c1">#         ElemType = &#39;hex&#39;</span>
<span class="c1">#     NodeNeighbors = utils.getNodeNeighbors(VoxelCoords, VoxelConn, ElemType=ElemType)</span>
<span class="c1">#     xNeighbors = [[n for n in NodeNeighbors[i] if (VoxelCoords[n][1] == VoxelCoords[i][1]) and (VoxelCoords[n][2] == VoxelCoords[i][2])] for i in range(len(NodeNeighbors))]</span>
<span class="c1">#     yNeighbors = [[n for n in NodeNeighbors[i] if (VoxelCoords[n][0] == VoxelCoords[i][0]) and (VoxelCoords[n][2] == VoxelCoords[i][2])] for i in range(len(NodeNeighbors))]</span>
<span class="c1">#     zNeighbors = [[n for n in NodeNeighbors[i] if (VoxelCoords[n][0] == VoxelCoords[i][0]) and (VoxelCoords[n][1] == VoxelCoords[i][1])] for i in range(len(NodeNeighbors))]</span>
<span class="c1">#     # Assumes (and requires) that all voxels are the same size</span>
<span class="c1">#     h = abs(sum(np.array(VoxelCoords[VoxelConn[0][0]]) - np.array(VoxelCoords[VoxelConn[0][1]])))</span>
<span class="c1">#     # Initialize Labels - Accepted if on the surface, Narrow Band if an adjacent node has a different sign (i.e. cross the surface), otherwise Far</span>
<span class="c1">#     Accepted = set([i for i,v in enumerate(NodeVals) if v == 0])</span>
<span class="c1">#     Narrow = [i for i,v in enumerate(NodeVals) if any(np.sign(NodeVals[NodeNeighbors[i]]) != np.sign(v)) and i not in Accepted]</span>
<span class="c1">#     NarrowVals = []</span>
<span class="c1">#     for i in Narrow:</span>
<span class="c1">#         crosses = []</span>
<span class="c1">#         for n in xNeighbors[i]:</span>
<span class="c1">#             if np.sign(NodeVals[i]) != np.sign(NodeVals[n]):</span>
<span class="c1">#                 crosses.append(np.sign(NodeVals[i])*np.abs((0-NodeVals[i])*(VoxelCoords[n][0]-VoxelCoords[i][0])/(NodeVals[n]-NodeVals[i])))</span>
<span class="c1">#         for n in yNeighbors[i]:</span>
<span class="c1">#             if np.sign(NodeVals[i]) != np.sign(NodeVals[n]):</span>
<span class="c1">#                 crosses.append(np.sign(NodeVals[i])*np.abs((0-NodeVals[i])*(VoxelCoords[n][1]-VoxelCoords[i][1])/(NodeVals[n]-NodeVals[i])))</span>
<span class="c1">#         for n in zNeighbors[i]:</span>
<span class="c1">#             if np.sign(NodeVals[i]) != np.sign(NodeVals[n]):</span>
<span class="c1">#                 crosses.append(np.sign(NodeVals[i])*np.abs((0-NodeVals[i])*(VoxelCoords[n][2]-VoxelCoords[i][2])/(NodeVals[n]-NodeVals[i])))</span>
<span class="c1">#         # NarrowVals.append(np.mean(crosses))</span>
<span class="c1">#         NarrowVals.append(min(crosses))</span>
<span class="c1">#     Far = set(range(len(NodeVals))).difference(Accepted.union(set(Narrow)))</span>
<span class="c1">#     # Initialize Values (inf for Far, 0 for accepted)</span>
<span class="c1">#     infty = 1e16 * max(NodeVals)</span>
<span class="c1">#     T = infty*np.ones(len(NodeVals))</span>
<span class="c1">#     for i in range(len(NarrowVals)):</span>
<span class="c1">#         T[Narrow[i]] = NarrowVals[i]</span>
<span class="c1">#     for i in Accepted:</span>
<span class="c1">#         T[i] = 0</span>
    
<span class="c1">#     Nar = sorted([t for i,t in enumerate(zip(NarrowVals,Narrow))], key=lambda x: x[0])</span>
<span class="c1">#     while len(Far) + len(Nar) &gt; 0:</span>
<span class="c1">#         if len(Nar) &gt; 0:</span>
<span class="c1">#             pt = Nar[0][1]</span>
<span class="c1">#         else:</span>
<span class="c1">#             n = Far.pop()</span>
<span class="c1">#             Nar.append((T[n],n))</span>
<span class="c1">#         Accepted.add(pt)</span>
<span class="c1">#         Nar.pop(0)</span>
<span class="c1">#         for n in NodeNeighbors[pt]:</span>
<span class="c1">#             if n in Far:</span>
<span class="c1">#                 Far.remove(n)</span>
<span class="c1">#                 Nar.insert(bisect.bisect_left(Nar, (T[n],n)), (T[n],n))</span>
<span class="c1">#             if n not in Accepted:</span>
<span class="c1">#                 # Eikonal Update:</span>
<span class="c1">#                 Tx = min([T[x] for x in xNeighbors[n]]+[0])</span>
<span class="c1">#                 Ty = min([T[y] for y in yNeighbors[n]]+[0])</span>
<span class="c1">#                 Tz = min([T[z] for z in zNeighbors[n]]+[0])</span>
                
<span class="c1">#                 discriminant = sum([Tx,Ty,Tz])**2 - N*(sum([Tx**2,Ty**2,Tz**2]) - h**2/F**2)</span>
<span class="c1">#                 if discriminant &gt; 0:</span>
<span class="c1">#                     t = 1/N * sum([Tx,Ty,Tz]) + 1/N * np.sqrt(discriminant)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     t = h/F + min([Tx,Ty,Tz])</span>
                                
<span class="c1">#                 Nar.pop(bisect.bisect_left(Nar, (T[n],n)))</span>
<span class="c1">#                 if t &lt; T[n]: T[n] = t</span>
<span class="c1">#                 Nar.insert(bisect.bisect_left(Nar, (T[n],n)), (T[n],n))        </span>
<span class="c1">#     T = [-1*t if np.sign(t) != np.sign(NodeVals[i]) else t for i,t in enumerate(T)]</span>
<span class="c1">#     return T</span>
<span class="c1"># def DoubleDualResampling(sdf,NodeCoords,NodeConn,DualCoords,DualConn,eps=1e-3,c=2):</span>
<span class="c1">#     warnings.warn(&#39;DoubleDualResampling is not fully functional and may be unstable.&#39;)</span>

<span class="c1">#     # Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277–284. https://doi.org/10.1115/1.1559153</span>
<span class="c1">#     DualCoords,DualConn,gradP = DualMeshOptimization(sdf,NodeCoords,NodeConn,DualCoords,DualConn,eps=eps,return_grad=True)</span>
<span class="c1">#     DualNeighbors,ElemConn = utils.getNodeNeighbors(DualCoords,DualConn,ElemType=&#39;polygon&#39;)</span>
<span class="c1">#     NewNodeCoords = [[] for i in range(len(NodeCoords))]</span>
<span class="c1">#     gradPnorms = [np.linalg.norm(gradP[i]) for i in range(len(gradP))]</span>
<span class="c1">#     Normals = [gradP[j]/gradPnorms[j] if gradPnorms[j] &gt; 0 else utils.CalcFaceNormal(DualCoords,[DualConn[ElemConn[j][0]]])[0] for j in range(len(DualCoords))]</span>
<span class="c1">#     for i in range(len(NodeCoords)):</span>
<span class="c1">#         Ps = DualConn[i]</span>
<span class="c1">#         # Ns = [gradP[j]/gradPnorms[j] if gradPnorms[j] &gt; 0 else utils.CalcFaceNormal(DualCoords,[Ps])[0] for j in Ps]</span>
<span class="c1">#         ks = []</span>
<span class="c1">#         for j,Pj in enumerate(Ps):</span>
<span class="c1">#             NeighborPs = DualNeighbors[Pj][:3]</span>
<span class="c1">#             # NNPs =[gradP[k]/gradPnorms[k] for k in NeighborPs]</span>
<span class="c1">#             # ks.append(sum([np.arccos(np.dot(Ns[j],NNPs[k]))/(np.linalg.norm(DualCoords[Pj])*np.linalg.norm(DualCoords[NeighborPs[k]]))  for k in range(len(NNPs))]))</span>
            
<span class="c1">#             ks.append(sum([np.arccos(min(np.dot(Normals[Pj],Normals[NeighborPs[k]]),1))/np.linalg.norm(np.subtract(DualCoords[Pj],DualCoords[NeighborPs[k]])) for k in range(len(NeighborPs))]))</span>
<span class="c1">#             if np.isnan(ks[-1]):</span>
<span class="c1">#                 print(&#39;merp&#39;)</span>
        
<span class="c1">#         weights = [1+c*ki for ki in ks]</span>
        
<span class="c1">#         NewNodeCoords[i] = sum([np.multiply(weights[j],DualCoords[Ps[j]]) for j in range(len(Ps))])/sum(weights).tolist()</span>
<span class="c1">#     return NewNodeCoords, NodeConn</span>
    
<span class="c1"># def DualMeshOptimization(sdf,NodeCoords,NodeConn,DualCoords,DualConn,eps=1e-3,return_grad=False):</span>
<span class="c1">#     # Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277–284. https://doi.org/10.1115/1.1559153</span>
<span class="c1">#     warnings.warn(&#39;DualMeshOptimization is not fully functional and may be unstable.&#39;)</span>
    
<span class="c1">#     def GradF(q,h):</span>
<span class="c1">#         g = [-1,0,1]</span>
<span class="c1">#         X = np.array([q[0]+h*x for x in g for y in g for z in g])</span>
<span class="c1">#         Y = np.array([q[1]+h*y for x in g for y in g for z in g])</span>
<span class="c1">#         Z = np.array([q[2]+h*z for x in g for y in g for z in g])</span>
<span class="c1">#         F = sdf(X,Y,Z).reshape([3,3,3])</span>
<span class="c1">#         dF = np.gradient(F,h)</span>
<span class="c1">#         dFq = [dF[0][1,1,1],dF[1][1,1,1],dF[2][1,1,1]]</span>
<span class="c1">#         return dFq</span>
<span class="c1">#     def bisection(sdf, a, b, fa, fb, tol=eps):</span>
<span class="c1">#         assert (fa &lt; 0 and fb &gt; 0) or (fa &gt; 0 and fb &lt; 0), &#39;Invalid bounds for bisection&#39;</span>
        
<span class="c1">#         thinking = True</span>
<span class="c1">#         while thinking:</span>
<span class="c1">#             c = np.mean([a,b],axis=0)</span>
<span class="c1">#             fc = sdf(*c)</span>
<span class="c1">#             # if fc == 0 or (np.linalg.norm(b-a)/2) &lt; tol:</span>
<span class="c1">#                 # merp = &#39;meep&#39;</span>
<span class="c1">#             if abs(fc) &lt; tol:</span>
<span class="c1">#                 thinking = False</span>
<span class="c1">#             else:</span>
<span class="c1">#                 if np.sign(fc) == np.sign(fa):</span>
<span class="c1">#                     a = c</span>
<span class="c1">#                     fa = fc</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     b = c</span>
<span class="c1">#                     fb = fc                </span>
<span class="c1">#         return c</span>
<span class="c1">#     def secant(sdf, a, b, fa, fb, tol=eps):</span>
<span class="c1">#         assert (fa &lt; 0 and fb &gt; 0) or (fa &gt; 0 and fb &lt; 0), &#39;Invalid bounds for secant method&#39;</span>
<span class="c1">#         origA, origB, origFa, origFb = a, b, fa, fb</span>
<span class="c1">#         thinking = True</span>
<span class="c1">#         k = 0</span>
<span class="c1">#         while thinking:</span>
<span class="c1">#             k += 1</span>
<span class="c1">#             c = np.subtract(b,fb*(np.subtract(b,a))/(fb-fa))</span>
<span class="c1">#             fc = sdf(*c)</span>
<span class="c1">#             if fc == 0 or abs(fc) &lt; tol:</span>
<span class="c1">#                 thinking = False</span>
<span class="c1">#             else:</span>
<span class="c1">#                 a,b = b,c</span>
<span class="c1">#                 fa,fb = fb,fc</span>
<span class="c1">#             if k &gt; 50 or fa == fb:</span>
<span class="c1">#                 thinking = False</span>
<span class="c1">#                 c = bisection(sdf, origA, origB, origFa, origFb, tol=tol)</span>
        
<span class="c1">#         if not ((a[0] &lt;= c[0] &lt;= b[0] or a[0] &gt;= c[0] &gt;= b[0]) and (a[1] &lt;= c[1] &lt;= b[1] or a[1] &gt;= c[1] &gt;= b[1] ) and (a[2] &lt;= c[2] &lt;= b[2] or a[2] &gt;= c[2] &gt;= b[2])):</span>
<span class="c1">#             c = bisection(sdf, origA, origB, origFa, origFb, tol=tol)</span>
            
<span class="c1">#         return c</span>
<span class="c1">#     ArrayCoords = np.array(NodeCoords)</span>
    
<span class="c1">#     # _,ElemConn = utils.getNodeNeighbors(NodeCoords,NodeConn)</span>
<span class="c1">#     # DualCoords,DualConn = converter.surf2dual(ArrayCoords,NodeConn,ElemConn=ElemConn)</span>
    
<span class="c1">#     # Optimize dual mesh coordinates     </span>
<span class="c1">#     gradP = [[] for i in range(len(DualCoords))]</span>
<span class="c1">#     for c,P in enumerate(DualCoords):</span>
<span class="c1">#         pts = ArrayCoords[NodeConn[c]]</span>
<span class="c1">#         edgelengths = [np.linalg.norm(pts[1]-pts[0]),np.linalg.norm(pts[2]-pts[1]),np.linalg.norm(pts[0]-pts[2])]</span>
<span class="c1">#         e = np.mean(edgelengths)</span>
<span class="c1">#         lamb = e/2</span>
<span class="c1">#         fP = sdf(*P)</span>
<span class="c1">#         if abs(fP) &lt; eps:</span>
<span class="c1">#             if return_grad:</span>
<span class="c1">#                 gradP[c] = GradF(P,lamb/1000)</span>
<span class="c1">#                 # gradP[c] = gradF(*P)[0]</span>
<span class="c1">#             continue</span>
        
<span class="c1">#         Q = P</span>
<span class="c1">#         fQ = fP</span>

<span class="c1">#         it = 0</span>
<span class="c1">#         thinking = True</span>
<span class="c1">#         while thinking:</span>
<span class="c1">#             dfQ = GradF(Q,lamb/1000)</span>
<span class="c1">#             # dfQ = gradF(*Q)[0]</span>
<span class="c1">#             d = -np.multiply(dfQ,fQ)</span>
<span class="c1">#             d = d/np.linalg.norm(d)</span>
<span class="c1">#             R = Q + lamb*d</span>
<span class="c1">#             fR = sdf(*R)</span>
<span class="c1">#             if fQ*fR &lt; 0:</span>
<span class="c1">#                 P2 = bisection(sdf, Q, R, fQ, fR)</span>
<span class="c1">#                 thinking = False</span>
<span class="c1">#             else: </span>
<span class="c1">#                 Q = R</span>
<span class="c1">#                 fQ = sdf(*Q)</span>
<span class="c1">#                 it += 1</span>
<span class="c1">#                 if it == 3:</span>
<span class="c1">#                     lamb = lamb/2</span>
<span class="c1">#                 if it &gt; 500:</span>
<span class="c1">#                     thinking = False</span>
<span class="c1">#                     P2 = P</span>
<span class="c1">#                     # raise Exception(&quot;Too many iterations - This probably shouldn&#39;t happen&quot;)</span>
<span class="c1">#         #if np.linalg.norm(np.subtract(P2,P)) &lt; e:</span>

<span class="c1">#         S = P-2*P2</span>
<span class="c1">#         fS = sdf(*S)</span>
<span class="c1">#         if fP*fS &lt; 0:</span>
<span class="c1">#             P3 = bisection(sdf, P, S, fP, fS)</span>
<span class="c1">#             if np.linalg.norm(np.subtract(P,P2)) &lt; np.linalg.norm(np.subtract(P,P3)):</span>
<span class="c1">#                 P = P2</span>
<span class="c1">#             else:</span>
<span class="c1">#                 P = P3</span>
<span class="c1">#         else:</span>
<span class="c1">#             P = P2</span>
<span class="c1">#         # P = P2</span>
<span class="c1">#         DualCoords[c] = P</span>
<span class="c1">#         if return_grad: gradP[c] = GradF(P,lamb/10)</span>
<span class="c1">#         # if return_grad: gradP[c] = gradF(*P)[0]</span>
        
<span class="c1">#     if return_grad:</span>
<span class="c1">#         return DualCoords, DualConn, gradP</span>
<span class="c1">#     else:</span>
<span class="c1">#         return DualCoords, DualConn</span>
    
<span class="c1"># def AdaptiveSubdivision(sdf,NodeCoords,NodeConn,threshold=1e-3):</span>
<span class="c1">#     # Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277–284. https://doi.org/10.1115/1.1559153</span>
<span class="c1">#     def gradF(q,h=1e-6):</span>
<span class="c1">#         if type(q) is list: q = np.array(q)</span>
<span class="c1">#         if len(q.shape)==1: q = np.array([q])</span>
<span class="c1">#         gradx = (sdf(q[:,0]+h/2,q[:,1],q[:,2]) - sdf(q[:,0]-h/2,q[:,1],q[:,2]))/h</span>
<span class="c1">#         grady = (sdf(q[:,0],q[:,1]+h/2,q[:,2]) - sdf(q[:,0],q[:,1]-h/2,q[:,2]))/h</span>
<span class="c1">#         gradz = (sdf(q[:,0],q[:,1],q[:,2]+h/2) - sdf(q[:,0],q[:,1],q[:,2]-h/2))/h</span>
<span class="c1">#         gradf = np.vstack((gradx,grady,gradz)).T</span>
<span class="c1">#         if len(gradf) == 1: gradf = gradf[0]</span>
<span class="c1">#         return gradf</span>
    
<span class="c1">#     NewNodeCoords = copy.copy(NodeCoords)</span>
<span class="c1">#     NewNodeConn = copy.copy(NodeConn)</span>
<span class="c1">#     ElemNeighbors = utils.getElemNeighbors(NodeCoords, NodeConn, mode=&#39;edge&#39;)</span>

<span class="c1">#     ###</span>
<span class="c1">#     Points = np.array(NodeCoords)[np.array(NodeConn)]</span>
<span class="c1">#     cross = np.cross(Points[:,1]-Points[:,0],Points[:,2]-Points[:,0])</span>
<span class="c1">#     norm = np.linalg.norm(cross,axis=1)</span>
<span class="c1">#     ElemNormals = cross/norm[:,None]</span>
<span class="c1">#     Area = norm/2</span>
<span class="c1">#     splitCentroids = np.swapaxes(np.array([np.mean(Points,axis=1),</span>
<span class="c1">#                           np.mean([Points[:,0], np.mean([Points[:,0], Points[:,1]],axis=0), np.mean([Points[:,0], Points[:,2]],axis=0)],axis=0),</span>
<span class="c1">#                           np.mean([Points[:,1], np.mean([Points[:,0], Points[:,1]],axis=0), np.mean([Points[:,1], Points[:,2]],axis=0)],axis=0),</span>
<span class="c1">#                           np.mean([Points[:,2], np.mean([Points[:,2], Points[:,1]],axis=0), np.mean([Points[:,0], Points[:,2]],axis=0)],axis=0),</span>
<span class="c1">#                           ]),0,1)</span>
<span class="c1">#     splitCentroids2 = splitCentroids.reshape((len(splitCentroids)*4,3))</span>
<span class="c1">#     gradFCi = gradF(splitCentroids2)</span>
<span class="c1">#     mCi = gradFCi/np.linalg.norm(gradFCi,axis=1)[:,None]</span>
<span class="c1">#     mCi2 = mCi.reshape(splitCentroids.shape)</span>
<span class="c1">#     en = np.array([Area[i]*sum(1-np.abs(np.dot(ElemNormals[i],mCi2[i].T))) for i in range(len(NodeConn))])</span>
<span class="c1">#     for i,elem in enumerate(NodeConn):</span>
<span class="c1">#         if en[i] &gt; threshold:</span>
<span class="c1">#             id01 = len(NewNodeCoords)</span>
<span class="c1">#             NewNodeCoords.append(np.mean([NewNodeCoords[elem[0]],NewNodeCoords[elem[1]]],axis=0).tolist())</span>
<span class="c1">#             id12 = len(NewNodeCoords)</span>
<span class="c1">#             NewNodeCoords.append(np.mean([NewNodeCoords[elem[1]],NewNodeCoords[elem[2]]],axis=0).tolist())</span>
<span class="c1">#             id20 = len(NewNodeCoords)</span>
<span class="c1">#             NewNodeCoords.append(np.mean([NewNodeCoords[elem[2]],NewNodeCoords[elem[0]]],axis=0).tolist())</span>
<span class="c1">#             NewNodeConn[i] = [</span>
<span class="c1">#                 [elem[0],id01,id20],</span>
<span class="c1">#                 [id01,elem[1],id12],</span>
<span class="c1">#                 [id20,id12,elem[2]],</span>
<span class="c1">#                 [id01,id12,id20]</span>
<span class="c1">#                 ]</span>

<span class="c1">#     # Check for neighbors of split elements</span>
<span class="c1">#     thinking = True</span>
<span class="c1">#     mode = &#39;1-4&#39;</span>
<span class="c1">#     while thinking:</span>
<span class="c1">#         changes = 0</span>
<span class="c1">#         for i,elem in enumerate(NewNodeConn):</span>
<span class="c1">#             if type(elem[0]) is list:</span>
<span class="c1">#                 # Already subdivided</span>
<span class="c1">#                 continue</span>
<span class="c1">#             nSplitNeighbors = 0</span>
<span class="c1">#             SplitNeighbors = []</span>
<span class="c1">#             for n in ElemNeighbors[i]:</span>
<span class="c1">#                 if type(NewNodeConn[n][0]) is list and len(NewNodeConn[n]) &gt; 2: </span>
<span class="c1">#                     nSplitNeighbors += 1</span>
<span class="c1">#                     SplitNeighbors.append(n)</span>
<span class="c1">#             if mode == &#39;1-4&#39; and nSplitNeighbors &gt; 1:</span>
<span class="c1">#                 changes += 1</span>
<span class="c1">#                 id01 = len(NewNodeCoords)</span>
<span class="c1">#                 NewNodeCoords.append(np.mean([NewNodeCoords[elem[0]],NewNodeCoords[elem[1]]],axis=0).tolist())</span>
<span class="c1">#                 id12 = len(NewNodeCoords)</span>
<span class="c1">#                 NewNodeCoords.append(np.mean([NewNodeCoords[elem[1]],NewNodeCoords[elem[2]]],axis=0).tolist())</span>
<span class="c1">#                 id20 = len(NewNodeCoords)</span>
<span class="c1">#                 NewNodeCoords.append(np.mean([NewNodeCoords[elem[2]],NewNodeCoords[elem[0]]],axis=0).tolist())</span>
<span class="c1">#                 NewNodeConn[i] = [</span>
<span class="c1">#                     [elem[0],id01,id20],</span>
<span class="c1">#                     [id01,elem[1],id12],</span>
<span class="c1">#                     [id20,id12,elem[2]],</span>
<span class="c1">#                     [id01,id12,id20]</span>
<span class="c1">#                     ]</span>
                
<span class="c1">#             elif mode == &#39;1-2&#39; and nSplitNeighbors == 1:</span>
<span class="c1">#                 changes += 1</span>
<span class="c1">#                 if elem[0] in NodeConn[SplitNeighbors[0]] and elem[1] in NodeConn[SplitNeighbors[0]]:</span>
<span class="c1">#                     idx = len(NewNodeCoords)</span>
<span class="c1">#                     NewNodeCoords.append(np.mean([NewNodeCoords[elem[0]],NewNodeCoords[elem[1]]],axis=0).tolist())</span>
<span class="c1">#                     NewNodeConn[i] = [</span>
<span class="c1">#                         [elem[0],idx,elem[2]],</span>
<span class="c1">#                         [idx,elem[1],elem[2]]</span>
<span class="c1">#                         ]</span>
<span class="c1">#                 elif elem[1] in NodeConn[SplitNeighbors[0]] and elem[2] in NodeConn[SplitNeighbors[0]]:</span>
<span class="c1">#                     idx = len(NewNodeCoords)</span>
<span class="c1">#                     NewNodeCoords.append(np.mean([NewNodeCoords[elem[1]],NewNodeCoords[elem[2]]],axis=0).tolist())</span>
<span class="c1">#                     NewNodeConn[i] = [</span>
<span class="c1">#                         [elem[1],idx,elem[0]],</span>
<span class="c1">#                         [idx,elem[2],elem[0]]</span>
<span class="c1">#                         ]</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     idx = len(NewNodeCoords)</span>
<span class="c1">#                     NewNodeCoords.append(np.mean([NewNodeCoords[elem[2]],NewNodeCoords[elem[0]]],axis=0).tolist())</span>
<span class="c1">#                     NewNodeConn[i] = [</span>
<span class="c1">#                         [elem[0],elem[1],idx],</span>
<span class="c1">#                         [elem[1],elem[2],idx]</span>
<span class="c1">#                         ]</span>
<span class="c1">#         if mode == &#39;1-4&#39; and changes == 0:</span>
<span class="c1">#             # After all necessary 1-4 splits are completed, perform 1-2 splits</span>
<span class="c1">#             mode = &#39;1-2&#39;</span>
<span class="c1">#         elif mode == &#39;1-2&#39; and changes == 0:</span>
<span class="c1">#             thinking = False</span>
            
<span class="c1">#     NewNodeConn = [elem for elem in NewNodeConn if (type(elem[0]) != list)] + [e for elem in NewNodeConn if (type(elem[0]) == list) for e in elem]</span>
<span class="c1">#     NewNodeCoords,NewNodeConn = utils.DeleteDuplicateNodes(NewNodeCoords,NewNodeConn)</span>
            
<span class="c1">#     return NewNodeCoords,NewNodeConn</span>
     
<span class="c1"># def DualPrimalOptimization(sdf,NodeCoords,NodeConn,eps=1e-3,nIter=2):</span>
<span class="c1">#     # Ohtake, Y., and Belyaev, A. G. (March 26, 2003). &quot;Dual-Primal Mesh Optimization for Polygonized Implicit Surfaces With Sharp Features .&quot; ASME. J. Comput. Inf. Sci. Eng. December 2002; 2(4): 277–284. https://doi.org/10.1115/1.1559153</span>
<span class="c1">#     warnings.warn(&#39;DualPrimalOptimization is not fully functional and may be unstable.&#39;)</span>
       
<span class="c1">#     def PrimalMeshOptimization(DualCoords,DualConn,gradP,tau=10**3):</span>
<span class="c1">#         ArrayCoords = np.zeros([len(DualConn),3])</span>
<span class="c1">#         DualCoords = np.array(DualCoords)</span>
<span class="c1">#         DualNeighbors,ElemConn = utils.getNodeNeighbors(DualCoords,DualConn,ElemType=&#39;polygon&#39;)</span>
<span class="c1">#         centroids = utils.Centroids(DualCoords,DualConn)</span>
<span class="c1">#         gradPnorms = [np.linalg.norm(gradP[i]) for i in range(len(gradP))]</span>
<span class="c1">#         TransCoords = copy.copy(DualCoords)</span>
<span class="c1">#         for j,Pis in enumerate(DualConn):</span>
            
<span class="c1">#             # Transfrom Coordinates to local system centered on the centroid</span>
<span class="c1">#             TransCoords[:,0] -= centroids[j][0]</span>
<span class="c1">#             TransCoords[:,1] -= centroids[j][1]</span>
<span class="c1">#             TransCoords[:,2] -= centroids[j][2]</span>
            
<span class="c1">#             # Normal vector TODO: gradP[i] could = 0 at sharp features, in this case, need to use something else (maybe the element normal of the primal element corresponding to the dual node)</span>
<span class="c1">#             # Ns = [np.divide(gradP[i],gradPnorms[i]) for i in Pis]</span>
<span class="c1">#             Ns = [np.divide(gradP[i],gradPnorms[i]) if gradPnorms[i] &gt; 0 else utils.CalcFaceNormal(DualCoords,[DualConn[ElemConn[i][0]]])[0] for i in Pis]</span>
            
<span class="c1">#             r = np.linalg.norm(centroids[j]-DualCoords[Pis[0]])*2</span>
<span class="c1">#             A = np.diag([sum([N[0]**2 for i,N in enumerate(Ns)]), </span>
<span class="c1">#                          sum([N[1]**2 for i,N in enumerate(Ns)]),</span>
<span class="c1">#                          sum([N[2]**2 for i,N in enumerate(Ns)])])</span>
            
<span class="c1">#             b = [sum([N[0]**2*TransCoords[Pis[i]][0] for i,N in enumerate(Ns)]), </span>
<span class="c1">#                  sum([N[1]**2*TransCoords[Pis[i]][1] for i,N in enumerate(Ns)]),</span>
<span class="c1">#                  sum([N[2]**2*TransCoords[Pis[i]][2] for i,N in enumerate(Ns)])]</span>
<span class="c1">#             x = np.linalg.lstsq(A,b,rcond=1/tau)[0]</span>
<span class="c1">#             ArrayCoords[j] = x + centroids[j]</span>
<span class="c1">#             # Reset TransCoords</span>
<span class="c1">#             TransCoords[:,0] += centroids[j][0]</span>
<span class="c1">#             TransCoords[:,1] += centroids[j][1]</span>
<span class="c1">#             TransCoords[:,2] += centroids[j][2]</span>
<span class="c1">#         return ArrayCoords.tolist()</span>
    
<span class="c1">#     OptCoords = copy.copy(NodeCoords)</span>
<span class="c1">#     OptConn = copy.copy(NodeConn)</span>
<span class="c1">#     k = 0</span>
<span class="c1">#     tau = 10**3</span>
<span class="c1">#     for it in range(nIter):</span>
<span class="c1">#         DualCoords, DualConn = converter.surf2dual(OptCoords,OptConn,sort=&#39;ccw&#39;)</span>
<span class="c1">#         writeVTK(&#39;{:d}_Dual.vtk&#39;.format(k),DualCoords,DualConn)</span>
<span class="c1">#         OptCoords,_ = DoubleDualResampling(sdf,OptCoords,OptConn,DualCoords,DualConn)</span>
<span class="c1">#         writeVTK(&#39;{:d}_PrimalResampled.vtk&#39;.format(k),OptCoords,OptConn)</span>
<span class="c1">#         DualCoords = utils.Centroids(OptCoords,OptConn)</span>
<span class="c1">#         writeVTK(&#39;{:d}_Dual2.vtk&#39;.format(k),DualCoords,DualConn)</span>
<span class="c1">#         DualCoords, DualConn, gradP = DualMeshOptimization(sdf,OptCoords,OptConn,DualCoords,DualConn,eps=eps,return_grad=True) </span>
<span class="c1">#         writeVTK(&#39;{:d}_DualOpt.vtk&#39;.format(k),DualCoords,DualConn)</span>
<span class="c1">#         OptCoords = PrimalMeshOptimization(DualCoords,DualConn,gradP,tau=tau)</span>
<span class="c1">#         writeVTK(&#39;{:d}_PrimalOpt.vtk&#39;.format(k),OptCoords,OptConn)</span>
<span class="c1">#         OptCoords,OptConn = AdaptiveSubdivision(sdf,OptCoords,OptConn)</span>
<span class="c1">#         writeVTK(&#39;{:d}_PrimalOptSub.vtk&#39;.format(k),OptCoords,OptConn)</span>
<span class="c1">#         k += 1</span>
<span class="c1">#         if k &gt; 1 and tau &gt; 10:</span>
<span class="c1">#             tau = tau/10</span>
<span class="c1">#     DualCoords, DualConn = converter.surf2dual(OptCoords,OptConn,sort=&#39;ccw&#39;)</span>
<span class="c1">#     OptCoords,_ = DoubleDualResampling(sdf,OptCoords,OptConn,DualCoords,DualConn)</span>
<span class="c1">#     writeVTK(&#39;{:d}_PrimalResampled.vtk&#39;.format(k),OptCoords,OptConn)</span>
<span class="c1">#     DualCoords, DualConn, gradP = DualMeshOptimization(sdf,OptCoords,OptConn,DualCoords,DualConn,eps=eps,return_grad=True) </span>
<span class="c1">#     writeVTK(&#39;{:d}_DualOpt.vtk&#39;.format(k),DualCoords,DualConn)</span>
<span class="c1">#     OptCoords = PrimalMeshOptimization(DualCoords,DualConn,gradP,tau=tau)</span>
<span class="c1">#     writeVTK(&#39;{:d}_PrimalOpt.vtk&#39;.format(k),OptCoords,OptConn)</span>
<span class="c1">#     return OptCoords,OptConn</span>

<span class="c1"># def SurfFlowOptimization(sdf,NodeCoords,NodeConn,h,ZRIter=50,NZRIter=50,NZIter=50,Subdivision=True,FixedNodes=set(), gradF=None):</span>
    
<span class="c1">#     C = 0.1     # Positive Constant</span>
<span class="c1">#     FreeNodes = list(set(range(len(NodeCoords))).difference(FixedNodes))</span>
<span class="c1">#     if gradF is None:</span>
<span class="c1">#         def gradF(q):</span>
<span class="c1">#             hdiff = 1e-6    # Finite Diff Step Size</span>
<span class="c1">#             if type(q) is list: q = np.array(q)</span>
<span class="c1">#             if len(q.shape)==1: q = np.array([q])</span>
<span class="c1">#             gradx = (sdf(q[:,0]+hdiff/2,q[:,1],q[:,2]) - sdf(q[:,0]-hdiff/2,q[:,1],q[:,2]))/hdiff</span>
<span class="c1">#             grady = (sdf(q[:,0],q[:,1]+hdiff/2,q[:,2]) - sdf(q[:,0],q[:,1]-hdiff/2,q[:,2]))/hdiff</span>
<span class="c1">#             gradz = (sdf(q[:,0],q[:,1],q[:,2]+hdiff/2) - sdf(q[:,0],q[:,1],q[:,2]-h/2))/hdiff</span>
<span class="c1">#             gradf = np.vstack((gradx,grady,gradz)).T</span>
<span class="c1">#             if len(gradf) == 1: gradf = gradf[0]</span>
<span class="c1">#             return gradf</span>
<span class="c1">#     def NFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids,tf=1):</span>
<span class="c1">#         gradC = -gradF(Centroids)</span>
<span class="c1">#         gradCnorm = np.linalg.norm(gradC,axis=1)</span>
<span class="c1">#         m = np.divide(gradC,np.reshape(gradCnorm,(len(gradC),1)))</span>
        
<span class="c1">#         # This is a slower but more straightforward version of what is done below</span>
<span class="c1">#         # A = np.array([sum([Area[e] for e in ElemConn[i]]) for i in range(len(NodeCoords))])</span>
<span class="c1">#         # tau = 1/(1000*max(A))</span>
<span class="c1">#         # N1 = tau*np.array([1/sum(Area[T] for T in ElemConn[i]) * sum([Area[T]*np.dot((Centroids[T]-P),m[T])*m[T] for T in ElemConn[i]]) for i,P in enumerate(NodeCoords)])</span>

<span class="c1">#         # Converting the ragged ElemConn array to a padded rectangular array (R) for significant speed improvements</span>
<span class="c1">#         Area2 = np.append(Area,0)</span>
<span class="c1">#         m2 = np.vstack([m,[0,0,0]])</span>
<span class="c1">#         Centroids2 = np.vstack([Centroids,[0,0,0]])</span>
<span class="c1">#         R = utils.PadRagged(ElemConn,fillval=-1)</span>
<span class="c1">#         a = Area2[R]</span>
<span class="c1">#         A = np.sum(a,axis=1)</span>
<span class="c1">#         tau = tf*.75 # 1/(100*max(A))</span>
<span class="c1">#         v = np.sum(m2[R]*(Centroids2[R] - NodeCoords[:,None,:]),axis=2)[:,:,None]*m2[R]</span>
<span class="c1">#         C = np.sum(a[:,:,None]*v,axis=1)</span>
<span class="c1">#         N = (tau/np.sum(Area2[R],axis=1))[:,None]*C</span>
<span class="c1">#         return N</span>
<span class="c1">#     def N2Flow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids):</span>
        
<span class="c1">#         # Orthocenter coordinates: https://en.wikipedia.org/wiki/Triangle_center#Position_vectors</span>
<span class="c1">#         tic = time.time()</span>
<span class="c1">#         Points = NodeCoords[np.array(NodeConn)]</span>
<span class="c1">#         a = np.linalg.norm(Points[:,1]-Points[:,2],axis=1)</span>
<span class="c1">#         b = np.linalg.norm(Points[:,2]-Points[:,0],axis=1)</span>
<span class="c1">#         c = np.linalg.norm(Points[:,1]-Points[:,0],axis=1)</span>
<span class="c1">#         wA = a**4 - (b**2 - c**2)**2</span>
<span class="c1">#         wB = b**4 - (c**2 - a**2)**2</span>
<span class="c1">#         wC = c**4 - (a**2 - b**2)**2</span>
<span class="c1">#         # Orthocenters</span>
<span class="c1">#         H = (wA[:,None]*Points[:,0] + wB[:,None]*Points[:,1] + wC[:,None]*Points[:,2])/(wA + wB + wC)[:,None]</span>
<span class="c1">#         H2 = np.vstack([H,[0,0,0]])</span>
<span class="c1">#         # </span>
<span class="c1">#         lens = [len(e) for e in ElemConn]</span>
<span class="c1">#         maxlens = max(lens)</span>
<span class="c1">#         R = utils.PadRagged(ElemConn,fillval=-1)</span>
<span class="c1">#         Mask0 = (R&gt;=0).astype(int)</span>
<span class="c1">#         Masknan = Mask0.astype(float)</span>
<span class="c1">#         Masknan[Mask0 == 0] = np.nan</span>
        
<span class="c1">#         PH = (H2[R] - NodeCoords[:,None,:])*Mask0[:,:,None]</span>
<span class="c1">#         PHnorm = np.linalg.norm(PH,axis=2)</span>
<span class="c1">#         e = PH/PHnorm[:,:,None]</span>

<span class="c1">#         # For each point, gives the node connectivity of each incident element</span>
<span class="c1">#         IncidentNodes = np.array(NodeConn)[R]*Masknan[:,:,None]</span>
<span class="c1">#         ## TODO: This needs a speedup</span>
<span class="c1">#         OppositeEdges = (((np.array([[np.delete(x,x==i) if i in x else [np.nan,np.nan] for x in IncidentNodes[i]] for i in range(len(IncidentNodes))])).astype(int)+1)*Mask0[:,:,None]-1)</span>
<span class="c1">#         ##</span>
<span class="c1">#         OppositeLength = np.linalg.norm(NodeCoords[OppositeEdges[:,:,0]] - NodeCoords[OppositeEdges[:,:,1]],axis=2)</span>

<span class="c1">#         TriAntiGradient = e*OppositeLength[:,:,None]/2</span>
<span class="c1">#         PointAntiGradient = np.nansum(TriAntiGradient,axis=1)</span>
<span class="c1">#         degree = np.array([len(E) for E in ElemConn])</span>
<span class="c1">#         N = 1/(5*degree[:,None]) * PointAntiGradient</span>
<span class="c1">#         print(time.time()-tic)</span>
<span class="c1">#         return N</span>
<span class="c1">#     def ZFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids,tf=1):</span>
<span class="c1">#         fP = sdf(NodeCoords[:,0],NodeCoords[:,1],NodeCoords[:,2])</span>
<span class="c1">#         gradP = gradF(NodeCoords)</span>
<span class="c1">#         # A = np.array([sum([Area[T] for T in ElemConn[i]]) for i in range(len(NodeCoords))])</span>
<span class="c1">#         Area2 = np.append(Area,0)</span>
<span class="c1">#         R = utils.PadRagged(ElemConn,fillval=-1)</span>
<span class="c1">#         A = np.sum(Area2[R],axis=1)</span>

<span class="c1">#         # tau = 1/(500*max(A))</span>
<span class="c1">#         # Z = np.divide(-2*(tau*A)[:,None]*(fP[:,None]*gradP),np.linalg.norm(fP[:,None]*gradP,axis=1)[:,None],where=(fP!=0)[:,None])</span>
<span class="c1">#         # tau = tf*1/(100*max(A*np.linalg.norm(fP[:,None]*gradP,axis=1)))</span>
<span class="c1">#         tau = tf*h/(100*max(np.linalg.norm(fP[:,None]*gradP,axis=1)))</span>
<span class="c1">#         Z = -2*tau*A[:,None]*fP[:,None]*gradP</span>
<span class="c1">#         return Z</span>
<span class="c1">#     def Z2Flow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids):</span>
<span class="c1">#         fC = sdf(Centroids[:,0],Centroids[:,1],Centroids[:,2])</span>
<span class="c1">#         gradC = -gradF(Centroids)</span>
<span class="c1">#         Area2 = np.append(Area,0)</span>
<span class="c1">#         fC = np.append(fC,0)</span>
<span class="c1">#         gradC = np.vstack([gradC,[0,0,0]])</span>
<span class="c1">#         R = utils.PadRagged(ElemConn,fillval=-1)</span>
<span class="c1">#         A = np.sum(Area2[R],axis=1)</span>
<span class="c1">#         tau = 1/(100*max(A))</span>
<span class="c1">#         Z = 2*tau*np.sum(Area2[R][:,:,None]*gradC[R]*fC[R][:,:,None],axis=1)/3</span>
<span class="c1">#         return Z</span>
<span class="c1">#     def RFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids):</span>
<span class="c1">#         ### Old slow version ###</span>
<span class="c1">#         #     U = [1/len(N)*sum([np.subtract(NodeCoords[n],NodeCoords[i]) for n in N]) for i,N in enumerate(NodeNeighbors)]</span>
<span class="c1">#         #     R = C*np.array([U[i] - np.dot(U[i],NodeNormals[i])*NodeNormals[i] for i in range(len(NodeCoords))])</span>
<span class="c1">#         ###</span>
<span class="c1">#         lens = np.array([len(n) for n in NodeNeighbors])</span>
<span class="c1">#         r = utils.PadRagged(NodeNeighbors,fillval=-1)</span>
<span class="c1">#         ArrayCoords = np.vstack([NodeCoords,[np.nan,np.nan,np.nan]])</span>
<span class="c1">#         Q = ArrayCoords[r]</span>
<span class="c1">#         U = (1/lens)[:,None] * np.nansum(Q - ArrayCoords[:-1,None,:],axis=1)</span>
<span class="c1">#         R = C*(U - np.sum(U*NodeNormals,axis=1)[:,None]*NodeNormals)</span>
<span class="c1">#         return R</span>
<span class="c1">#     def NZRFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids,tf=1):</span>
<span class="c1">#         N = NFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids,tf=tf)</span>
<span class="c1">#         Z = ZFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids,tf=tf)</span>
<span class="c1">#         R = RFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids)</span>
<span class="c1">#         NZR = N + Z + R</span>
<span class="c1">#         return NZR</span>
<span class="c1">#     def ZRFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids,tf=1):</span>
<span class="c1">#         Z = ZFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids,tf=tf)</span>
<span class="c1">#         R = RFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids)</span>
<span class="c1">#         ZR = Z + R</span>
<span class="c1">#         return ZR</span>
<span class="c1">#     def NZFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids, tf=1):</span>
<span class="c1">#         N = NFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids,tf=tf)</span>
<span class="c1">#         Z = ZFlow(NodeCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids,tf=tf)</span>
<span class="c1">#         NZ = N + Z</span>
<span class="c1">#         return NZ</span>
<span class="c1">#     def Flip(NodeCoords, NodeConn, ElemNormals, ElemNeighbors, Area, Centroids,threshold=1e-4):</span>
<span class="c1">#         NodeCoords = np.array(NodeCoords)</span>
<span class="c1">#         NewConn = copy.copy(NodeConn)</span>
<span class="c1">#         gradC = gradF(Centroids)</span>
<span class="c1">#         gradCnorm = np.linalg.norm(gradC,axis=1)</span>
<span class="c1">#         m = np.divide(gradC,np.reshape(gradCnorm,(len(gradC),1)))</span>
<span class="c1">#         NormalError = Area*np.array([(1-np.dot(ElemNormals[T],m[T])) for T in range(len(ElemNormals))])</span>
<span class="c1">#         todo = np.where(NormalError &gt; threshold)[0]</span>
<span class="c1">#         for i in todo:</span>
<span class="c1">#             restart = True</span>
<span class="c1">#             while restart:</span>
<span class="c1">#                 for j in ElemNeighbors[i]:</span>
<span class="c1">#                     tic = time.time()</span>
<span class="c1">#                     if len(set(ElemNeighbors[i]).intersection(ElemNeighbors[j])) &gt; 0:</span>
<span class="c1">#                         # This condition checks if the flip will be legal</span>
<span class="c1">#                         continue</span>

<span class="c1">#                     Newi,Newj = improvement.FlipEdge(NodeCoords,NewConn,i,j)</span>
<span class="c1">#                     [Ci,Cj] = utils.Centroids(NodeCoords,np.array([Newi,Newj]))</span>
<span class="c1">#                     gradC = gradF(np.vstack([Ci,Cj]))</span>
<span class="c1">#                     gradCnorm = np.linalg.norm(gradC,axis=1)</span>
<span class="c1">#                     mi = gradC[0]/gradCnorm[0]</span>
<span class="c1">#                     mj = gradC[1]/gradCnorm[1]</span>
<span class="c1">#                     [Ni,Nj] = utils.CalcFaceNormal(NodeCoords,np.array([Newi,Newj]))</span>
                    
<span class="c1">#                     Ai = np.linalg.norm(np.cross(NodeCoords[Newi[1]]-NodeCoords[Newi[0]],NodeCoords[Newi[2]]-NodeCoords[Newi[0]]))/2</span>
<span class="c1">#                     Aj = np.linalg.norm(np.cross(NodeCoords[Newj[1]]-NodeCoords[Newj[0]],NodeCoords[Newj[2]]-NodeCoords[Newj[0]]))/2</span>
<span class="c1">#                     Ei = Ai*(1-np.dot(Ni,mi))</span>
<span class="c1">#                     Ej = Aj*(1-np.dot(Nj,mj))</span>
<span class="c1">#                     # Ei = np.arccos(np.dot(Ni,mi))</span>
<span class="c1">#                     # Ej = np.arccos(np.dot(Nj,mj))</span>
<span class="c1">#                     OldError = NormalError[i] + NormalError[j]</span>
<span class="c1">#                     NewError = Ei + Ej</span>
<span class="c1">#                     if NewError &lt; OldError:</span>
<span class="c1">#                         NormalError[i] = Ei; NormalError[j] = Ej</span>
<span class="c1">#                         NewConn[i] = Newi; NewConn[j] = Newj</span>
                        
<span class="c1">#                         ENi = []; ENj = []</span>
<span class="c1">#                         Si = set(Newi); Sj = set(Newj)</span>
<span class="c1">#                         for k in np.unique(ElemNeighbors[i] + ElemNeighbors[j]):</span>
<span class="c1">#                             if i in ElemNeighbors[k]: ElemNeighbors[k].remove(i)</span>
<span class="c1">#                             if j in ElemNeighbors[k]: ElemNeighbors[k].remove(j)</span>
<span class="c1">#                             if len(Si.intersection(NewConn[k])) == 2:</span>
<span class="c1">#                                 ENi.append(k)</span>
<span class="c1">#                                 ElemNeighbors[k].append(i)</span>
<span class="c1">#                             if len(Sj.intersection(NewConn[k])) == 2:</span>
<span class="c1">#                                 ENj.append(k)</span>
<span class="c1">#                                 ElemNeighbors[k].append(j)</span>

<span class="c1">#                         ElemNeighbors[i] = ENi; ElemNeighbors[j] = ENj</span>
<span class="c1">#                         restart = True</span>
<span class="c1">#                         break</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         restart = False</span>
<span class="c1">#         return NewConn, ElemNeighbors</span>
<span class="c1">#     def Error(NodeCoords, ElemConn, ElemNormals, Area, Centroids):</span>
<span class="c1">#         fP = sdf(NodeCoords[:,0],NodeCoords[:,1],NodeCoords[:,2])</span>
<span class="c1">#         gradP = gradF(NodeCoords)</span>
<span class="c1">#         gradPnorm = np.linalg.norm(gradP,axis=1)</span>
<span class="c1">#         gradC = gradF(Centroids)</span>
<span class="c1">#         gradCnorm = np.linalg.norm(gradC,axis=1)</span>
<span class="c1">#         m = np.divide(gradC,np.reshape(gradCnorm,(len(gradC),1)))</span>

<span class="c1">#         area = np.append(Area,0)</span>
<span class="c1">#         R = utils.PadRagged(ElemConn,fillval=-1)</span>
<span class="c1">#         A = np.sum(area[R],axis=1)</span>

<span class="c1">#         VertexError = 1/(3*sum(Area)) * sum((fP**2/gradPnorm**2)*A)</span>
<span class="c1">#         NormalError = 1/(sum(Area)) * sum(Area*(1-np.sum(ElemNormals*m,axis=1)))</span>

<span class="c1">#         return VertexError, NormalError</span>

<span class="c1">#     # edges = converter.surf2edges(NodeCoords,NodeConn)</span>
<span class="c1">#     # if len(edges) &gt; 0: warnings.warn(&#39;Input mesh should be closed and contain no exposed edges.&#39;)</span>
<span class="c1">#     k = 0</span>
<span class="c1">#     # mesh.mesh(NodeCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>

<span class="c1">#     if Subdivision: NodeCoords, NodeConn = AdaptiveSubdivision(sdf, NodeCoords, NodeConn,threshold=1e-3)</span>
<span class="c1">#     NodeCoords,NodeConn = utils.DeleteDuplicateNodes(NodeCoords,NodeConn)</span>
<span class="c1">#     NewCoords = np.array(NodeCoords)</span>
<span class="c1">#     # mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>

<span class="c1">#     NodeNeighbors = utils.getNodeNeighbors(NewCoords, NodeConn) </span>
<span class="c1">#     ElemConn = utils.getElemConnectivity(NewCoords, NodeConn)</span>
<span class="c1">#     ElemNeighbors = utils.getElemNeighbors(NodeCoords,NodeConn,mode=&#39;edge&#39;)</span>
<span class="c1">#     # NodeConn, ElemNeighbors = improvement.ValenceImprovementFlips(NodeCoords,NodeConn,NodeNeighbors,ElemNeighbors)</span>
<span class="c1">#     # vE = [];    nE = []   </span>
<span class="c1">#     ElemNormals = utils.CalcFaceNormal(NewCoords, NodeConn)</span>
<span class="c1">#     NodeNormals = np.array(utils.Face2NodeNormal(NewCoords, NodeConn, ElemConn, ElemNormals))</span>
    
<span class="c1">#     tfs = np.linspace(1,0,ZRIter+1)</span>
<span class="c1">#     for i in range(ZRIter):</span>
<span class="c1">#         tf = tfs[i]</span>
<span class="c1">#         Points = NewCoords[np.array(NodeConn)]</span>
<span class="c1">#         Area = np.linalg.norm(np.cross(Points[:,1]-Points[:,0],Points[:,2]-Points[:,0]),axis=1)/2   </span>
<span class="c1">#         Centroids = utils.Centroids(NewCoords, NodeConn)</span>
<span class="c1">#         # v,n = Error(NewCoords, ElemConn, ElemNormals, Area, Centroids); vE.append(v); nE.append(n)</span>
<span class="c1">#         NewCoords[FreeNodes] += ZRFlow(NewCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids, tf=tf)[FreeNodes]</span>
<span class="c1">#         ElemNormals = utils.CalcFaceNormal(NewCoords, NodeConn)</span>
<span class="c1">#         NodeNormals = np.array(utils.Face2NodeNormal(NewCoords, NodeConn, ElemConn, ElemNormals))</span>
<span class="c1">#         # mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>
<span class="c1">#     for i in range(NZRIter):</span>
<span class="c1">#         Points = NewCoords[np.array(NodeConn)]</span>
<span class="c1">#         Area = np.linalg.norm(np.cross(Points[:,1]-Points[:,0],Points[:,2]-Points[:,0]),axis=1)/2   </span>
<span class="c1">#         Centroids = utils.Centroids(NewCoords, NodeConn)</span>
<span class="c1">#         # v,n = Error(NewCoords, ElemConn, ElemNormals, Area, Centroids); vE.append(v); nE.append(n)</span>
<span class="c1">#         NewCoords[FreeNodes] += NZRFlow(NewCoords, NodeConn, NodeNormals, NodeNeighbors, ElemConn, Area, Centroids)[FreeNodes]</span>
<span class="c1">#         ElemNormals = utils.CalcFaceNormal(NewCoords, NodeConn)</span>
<span class="c1">#         NodeNormals = np.array(utils.Face2NodeNormal(NewCoords, NodeConn, ElemConn, ElemNormals))</span>
<span class="c1">#         # mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>
<span class="c1">#     if NZIter &gt; 0:</span>
<span class="c1">#         if Subdivision: NewCoords, NodeConn = AdaptiveSubdivision(sdf, NewCoords.tolist(), NodeConn, threshold=1e-4)</span>
<span class="c1">#         NewCoords = np.array(NewCoords)</span>
<span class="c1">#         NodeNeighbors = utils.getNodeNeighbors(NewCoords, NodeConn)    </span>
<span class="c1">#         ElemConn = utils.getElemConnectivity(NewCoords, NodeConn)    </span>
<span class="c1">#         ElemNeighbors = utils.getElemNeighbors(NewCoords,NodeConn,mode=&#39;edge&#39;)</span>
<span class="c1">#         ElemNormals = utils.CalcFaceNormal(NewCoords, NodeConn)</span>
<span class="c1">#         tfs = np.linspace(1,0,NZIter+1)</span>
<span class="c1">#     for i in range(NZIter):</span>
<span class="c1">#         tf = tfs[i]</span>
<span class="c1">#         Points = NewCoords[np.array(NodeConn)]</span>
<span class="c1">#         Area = np.linalg.norm(np.cross(Points[:,1]-Points[:,0],Points[:,2]-Points[:,0]),axis=1)/2   </span>
<span class="c1">#         Centroids = utils.Centroids(NewCoords, NodeConn)</span>

<span class="c1">#         # v,n = Error(NewCoords, ElemConn, ElemNormals, Area, Centroids)</span>
<span class="c1">#         # vE.append(v); nE.append(n)</span>

<span class="c1">#         NewCoords[FreeNodes] += NZFlow(NewCoords, NodeConn, [], NodeNeighbors, ElemConn, Area, Centroids,tf=tf)[FreeNodes]</span>
        
<span class="c1">#         NewElemNormals = np.array(utils.CalcFaceNormal(NewCoords, NodeConn))</span>

<span class="c1">#         ### Check for near-intersections ###</span>
<span class="c1">#         # Angles:</span>
<span class="c1">#         Points = NewCoords[np.array(NodeConn)]</span>
<span class="c1">#         v01 = Points[:,1]-Points[:,0]; l01 = np.linalg.norm(v01,axis=1)</span>
<span class="c1">#         v12 = Points[:,2]-Points[:,1]; l12 = np.linalg.norm(v12,axis=1)</span>
<span class="c1">#         v20 = Points[:,0]-Points[:,2]; l20 = np.linalg.norm(v20,axis=1)</span>
<span class="c1">#         alpha = np.arccos(np.sum(v01*-v20,axis=1)/(l01*l20))</span>
<span class="c1">#         beta = np.arccos(np.sum(v12*-v01,axis=1)/(l12*l01))</span>
<span class="c1">#         gamma = np.arccos(np.sum(v20*-v12,axis=1)/(l20*l12))</span>
<span class="c1">#         angles = np.vstack([alpha,beta,gamma]).T</span>
<span class="c1">#         # Dihedrals:</span>
<span class="c1">#         dihedrals = quality.SurfDihedralAngles(NewElemNormals,ElemNeighbors)</span>
<span class="c1">#         # Normal Flipping:</span>
<span class="c1">#         NormDot = np.sum(NewElemNormals * ElemNormals,axis=1)</span>

<span class="c1">#         Risk = np.any(angles&lt;5*np.pi/180,axis=1) | np.any(dihedrals &gt; 175*np.pi/180,axis=1) | (NormDot &lt; 0)</span>
<span class="c1">#         Intersected = []</span>
<span class="c1">#         if i &gt;= NZIter-5:</span>
<span class="c1">#             # NodeConn, ElemNeighbors = Flip(NewCoords,NodeConn,ElemNormals,ElemNeighbors,Area,Centroids)</span>
<span class="c1">#             IntersectionPairs = rays.SurfSelfIntersection(NewCoords,NodeConn)</span>
<span class="c1">#             Intersected = np.unique(IntersectionPairs).tolist()</span>
            
<span class="c1">#         if np.any(Risk) or len(Intersected):</span>
<span class="c1">#             # print(&#39;possible intersection&#39;)</span>
<span class="c1">#             ArrayConn = np.array(NodeConn)</span>
<span class="c1">#             AtRiskElems = np.where(Risk)[0].tolist() + Intersected</span>
<span class="c1">#             NeighborhoodElems = np.unique([e for i in (ArrayConn[AtRiskElems]).flatten() for e in ElemConn[i]])</span>
<span class="c1">#             PatchConn = ArrayConn[NeighborhoodElems] </span>
<span class="c1">#             BoundaryEdges = converter.surf2edges(NewCoords,PatchConn)</span>
<span class="c1">#             FixedNodes = set([n for edge in BoundaryEdges for n in edge])</span>
<span class="c1">#             NewCoords = np.array(improvement.LocalLaplacianSmoothing(NewCoords,PatchConn,2,FixedNodes=FixedNodes))</span>

<span class="c1">#             # NodeConn = improvement.AngleReductionFlips(NewCoords,NodeConn,NodeNeighbors)</span>
<span class="c1">#             NodeNeighbors,ElemConn = utils.getNodeNeighbors(NewCoords, NodeConn)    </span>
<span class="c1">#             ElemNeighbors = utils.getElemNeighbors(NewCoords,NodeConn,mode=&#39;edge&#39;)</span>
<span class="c1">#             ElemNormals = np.array(utils.CalcFaceNormal(NewCoords, NodeConn))</span>
<span class="c1">#         else:</span>
<span class="c1">#             ElemNormals = NewElemNormals</span>
<span class="c1">#         # mesh.mesh(NewCoords,NodeConn).Mesh2Meshio().write(str(k)+&#39;.vtu&#39;);k+=1</span>
<span class="c1">#     # px.line(y=vE).show()</span>
<span class="c1">#     # px.line(y=nE).show()</span>
<span class="c1">#     return NewCoords.tolist(), NodeConn</span>





</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2023, Timothy O. Josephson.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>